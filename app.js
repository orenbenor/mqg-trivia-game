const DEFAULT_ADMIN_USERS = [];
const MIN_CONTENT_DATE = "2025-01-01";
const SEASONAL_MIN_DATE = "2025-10-01";
const QUESTION_TIMEOUT_SECONDS = 30;
const QUESTION_WARNING_AFTER_SECONDS = 15;
const MAX_POINTS_PER_QUESTION = 120;
const MIN_POINTS_PER_CORRECT = 20;
const ADAPTIVE_PLAYER_MIN_ATTEMPTS = 1;
const ADAPTIVE_SCORE_MIN_SIGNAL = 1.08;
const MIN_HUMAN_ANSWER_MS = 280;
const SEMANTIC_DUPLICATE_MIN_SIMILARITY = 0.76;
const AMBIGUOUS_QUESTION_MIN_SAMPLE = 6;
const SPACED_REPETITION_SETTINGS = {
  minDueBoost: 0.85,
  overdueBoostPerDay: 0.22,
  dueSoonWindowDays: 2,
  dueSoonBoost: 0.32,
};
const ANTI_SPAM_RULES = {
  quickStart: { windowMs: 60_000, maxEvents: 8, blockMs: 15_000 },
  adminLogin: { windowMs: 5 * 60_000, maxEvents: 7, blockMs: 5 * 60_000 },
  activitySubmit: { windowMs: 120_000, maxEvents: 5, blockMs: 60_000 },
  longTextGenerate: { windowMs: 120_000, maxEvents: 8, blockMs: 45_000 },
};
const MUSIC_DEFAULT_VOLUME = 0.12;
const QUALITY_MIN_QUESTION_LEN = 24;
const QUALITY_MIN_EXPLANATION_LEN = 42;
const LONG_TEXT_MIN_CHARS = 300;
const LONG_TEXT_PREVIEW_FACTS = 6;
const DRAFT_ACTION_LOG_LIMIT = 80;
const DRAFT_REJECT_REASON_MAX_LEN = 200;
const LONG_TEXT_QUESTION_STEMS = [
  "לפי הטקסט שהוזן, איזו מהטענות מופיעה בו במפורש?",
  "מה מהבאים תואם במדויק את הכתוב בטקסט?",
  "איזו קביעה מוצגת בטקסט כעובדה מרכזית?",
  "בהתאם לטקסט, מהו הניסוח הנכון?",
  "איזו אמירה נתמכת ישירות בטקסט?",
];

const STORAGE_KEYS = {
  attempts: "mqg_trivia_attempts_v3",
  activities: "mqg_trivia_activities_v3",
  drafts: "mqg_trivia_drafts_v3",
  customQuestions: "mqg_trivia_custom_questions_v3",
  disabledQuestionIds: "mqg_trivia_disabled_questions_v1",
  questionOverrides: "mqg_trivia_question_overrides_v1",
  draftActionLog: "mqg_trivia_draft_action_log_v1",
  musicSettings: "mqg_music_settings_v1",
  questionCycleUsedIds: "mqg_question_cycle_used_ids_v1",
  familyCycleUsedIds: "mqg_family_cycle_used_ids_v1",
  questionCycleByScope: "mqg_question_cycle_scope_used_ids_v1",
  familyCycleByScope: "mqg_family_cycle_scope_used_ids_v1",
  adminUsers: "mqg_admin_users_v1",
  learningAlertSettings: "mqg_learning_alert_settings_v1",
  playerSpacedMemory: "mqg_player_spaced_memory_v1",
  antiSpamState: "mqg_anti_spam_state_v1",
};
const REMOTE_SYNCABLE_KEYS = [
  STORAGE_KEYS.attempts,
  STORAGE_KEYS.activities,
  STORAGE_KEYS.drafts,
  STORAGE_KEYS.customQuestions,
  STORAGE_KEYS.disabledQuestionIds,
  STORAGE_KEYS.questionOverrides,
  STORAGE_KEYS.questionCycleUsedIds,
  STORAGE_KEYS.familyCycleUsedIds,
  STORAGE_KEYS.questionCycleByScope,
  STORAGE_KEYS.familyCycleByScope,
  STORAGE_KEYS.learningAlertSettings,
  STORAGE_KEYS.playerSpacedMemory,
];
const BACKEND_DEFAULT_CONFIG = {
  enabled: false,
  baseUrl: "",
  syncIntervalMs: 15000,
  publicWriteKey: "",
  allowInsecureLocalFallback: false,
};
const LEARNING_ALERT_SETTINGS_DEFAULT = {
  minAttemptsForAlerts: 4,
  categoryAccuracyWarn: 58,
  categoryAccuracyHigh: 52,
  categoryTimeoutWarn: 28,
  questionFailWarn: 50,
  questionFailHigh: 60,
  questionTimeoutWarn: 32,
};

const CATEGORY_COLORS = {
  "מערכת המשפט ומינויים": { start: "#0B427A", end: "#072D57", code: "LAW" },
  "שוויון בנטל": { start: "#0F5F9A", end: "#11497B", code: "EQL" },
  "תקשורת ושקיפות": { start: "#0A6178", end: "#0E4658", code: "MED" },
  "כלכלה ותחרות": { start: "#B2550A", end: "#8E3E06", code: "ECO" },
  "חברות ממשלתיות": { start: "#334155", end: "#1E293B", code: "GOV" },
  "חושפי שחיתות": { start: "#9A3412", end: "#7C2D12", code: "WBL" },
  "פעילות ציבורית": { start: "#1D4E89", end: "#163A64", code: "CIV" },
};

const ALL_CATEGORIES = Object.keys(CATEGORY_COLORS);
const SOURCE_TEXT_FRAGMENT_MAX_LEN = 92;
const CATEGORY_DISTRACTOR_FALLBACKS = {
  "מערכת המשפט ומינויים": [
    "הוגשה בקשה לעדכון בית המשפט",
    "המדינה ביקשה ארכה להגשת תגובה",
    "נקבע דיון המשך בפני ההרכב",
    "התקבלה תגובה מקדמית של היועצת המשפטית",
  ],
  "שוויון בנטל": [
    "יעד גיוס מדורג ללא סנקציות",
    "יישום חלקי של מנגנון אכיפה",
    "דחיית ההכרעה לשלב חקיקה נוסף",
    "הגברת מנגנוני פיקוח ויישום",
  ],
  "תקשורת ושקיפות": [
    "צו ביניים עד לבירור מלא",
    "חובת פרסום נתונים לציבור",
    "המשך בירור סמכות הגורמים",
    "הקפאה זמנית של המהלך",
  ],
  "כלכלה ותחרות": [
    "בדיקה רגולטורית משלימה",
    "קידום תהליך תחרותי פתוח",
    "פרסום עמדת גורמי המקצוע",
    "החזרת הנושא לבחינה במשרד האוצר",
  ],
  "חברות ממשלתיות": [
    "בדיקת ניגוד עניינים במינוי",
    "השלמת הליך ועדת המינויים",
    "פרסום נימוקים להחלטה",
    "העברת הנושא לבחינת רשות החברות",
  ],
  "חושפי שחיתות": [
    "פתיחת בדיקה מינהלית",
    "הגנת ביניים מפני פגיעה תעסוקתית",
    "קביעת מנגנון פיקוח בלתי תלוי",
    "בחינת התנהלות הגורם המדווח",
  ],
  "פעילות ציבורית": [
    "פנייה רשמית לרשויות הרלוונטיות",
    "דרישה לפרסום נתונים לציבור",
    "המשך מעקב ציבורי ומשפטי",
    "קידום מהלך תיקון מוסדי",
  ],
};
// For maximum source accuracy, fill `canonicalUrl` when you have a verified direct article URL.
const SOURCE_REGISTRY_BY_QUESTION_ID = {
  b01: {
    canonicalUrl: "https://mqg.org.il/%D7%AA%D7%92%D7%95%D7%91%D7%AA-%D7%94%D7%A2%D7%95%D7%AA%D7%A8%D7%AA-%D7%9C%D7%94%D7%97%D7%9C%D7%98%D7%AA-%D7%91%D7%92%D7%A5-%D7%A0%D7%99%D7%A6%D7%97%D7%95%D7%9F-%D7%9C%D7%A9%D7%9C%D7%98%D7%95/",
    searchQuery: "תגובת העותרת להחלטת בגץ ניצחון לשלטון החוק הדחת ראש השבכ 04.08.2025",
    anchorText: "בג\"ץ עצר את ההדחה והקפיא את החלטת הממשלה",
  },
  b02: {
    canonicalUrl: "https://mqg.org.il/%D7%AA%D7%92%D7%95%D7%91%D7%AA-%D7%94%D7%A2%D7%95%D7%AA%D7%A8%D7%AA-%D7%9C%D7%94%D7%97%D7%9C%D7%98%D7%AA-%D7%91%D7%92%D7%A5-%D7%A0%D7%99%D7%A6%D7%97%D7%95%D7%9F-%D7%9C%D7%A9%D7%9C%D7%98%D7%95/",
    searchQuery: "תגובת העותרת להחלטת בגץ 15000 עותרים 04.08.2025",
    anchorText: "התנועה ייצגה למעלה מ-15,000 עותרים",
  },
  b03: {
    canonicalUrl: "https://mqg.org.il/%D7%91%D7%92%D7%A5-%D7%99%D7%A7%D7%91%D7%A2-%D7%93%D7%99%D7%95%D7%9F-%D7%91%D7%A2%D7%AA%D7%99%D7%A8%D7%AA-%D7%94%D7%AA%D7%A0%D7%95%D7%A2%D7%94-%D7%9C%D7%90%D7%99%D7%9B%D7%95%D7%AA-%D7%94%D7%A9%D7%9C/",
    searchQuery: "בג\"ץ יקבע דיון בעתירה נגד מינוי דוד זיני 03.10.2025",
    anchorText: "בג\"ץ יקבע דיון בעתירה עד סוף נובמבר 2025",
  },
  b04: {
    canonicalUrl: "https://mqg.org.il/%D7%91%D7%92%D7%A5-%D7%99%D7%A7%D7%91%D7%A2-%D7%93%D7%99%D7%95%D7%9F-%D7%91%D7%A2%D7%AA%D7%99%D7%A8%D7%AA-%D7%94%D7%AA%D7%A0%D7%95%D7%A2%D7%94-%D7%9C%D7%90%D7%99%D7%9B%D7%95%D7%AA-%D7%94%D7%A9%D7%9C/",
    searchQuery: "מינוי דוד זיני 7 ימים לפני הדיון תגובות מקדמיות",
    anchorText: "התגובות המקדמיות נדרשו 7 ימים לפני הדיון",
  },
  b05: {
    canonicalUrl: "https://mqg.org.il/7055/",
    searchQuery: "מדובר במינוי מתריס ומחוצף נעתור לבג\"ץ 22.05.2025",
    anchorText: "התנועה תעתור לבג\"ץ נגד המינוי",
  },
  b06: {
    canonicalUrl: "https://mqg.org.il/%D7%91%D7%92%D7%A5-%D7%99%D7%A7%D7%99%D7%99%D7%9D-%D7%93%D7%99%D7%95%D7%9F-%D7%93%D7%97%D7%95%D7%A3-%D7%99%D7%95%D7%9D-%D7%91%D7%B3-13-1-%D7%91%D7%A2%D7%AA%D7%99%D7%A8%D7%AA-%D7%94%D7%AA%D7%A0/",
    searchQuery: "בג\"ץ יקיים דיון דחוף בעתירת התנועה 06.01.2025 רואי כחלון",
    anchorText: "הדיון הדחוף נקבע ל-13 בינואר 2025",
  },
  b07: {
    canonicalUrl: "https://mqg.org.il/%D7%A2%D7%93%D7%9B%D7%95%D7%9F-%D7%91%D7%92%D7%A5-%D7%93%D7%97%D7%94-%D7%90%D7%AA-%D7%A2%D7%AA%D7%99%D7%A8%D7%AA-%D7%94%D7%AA%D7%A0%D7%95%D7%A2%D7%94-%D7%9C%D7%90%D7%99%D7%9B%D7%95%D7%AA-%D7%94/",
    searchQuery: "תגובת התנועה להחלטת בג\"ץ 18.03.2025 עתירה מוקדמת ראש השב\"כ",
    anchorText: "לא התקבלה החלטת ממשלה סופית",
  },
  b08: {
    canonicalUrl: "https://mqg.org.il/%D7%94%D7%AA%D7%A0%D7%95%D7%A2%D7%94-%D7%9C%D7%90%D7%99%D7%9B%D7%95%D7%AA-%D7%94%D7%A9%D7%9C%D7%98%D7%95%D7%9F-%D7%91%D7%92%D7%A5-%D7%94%D7%A7%D7%A4%D7%99%D7%90-%D7%90%D7%AA-%D7%A1%D7%92%D7%99/",
    searchQuery: "בג\"ץ הקפיא את סגירת גלי צה\"ל 28.12.2025",
    anchorText: "בג\"ץ הקפיא את החלטת הממשלה על סגירת גל\"צ",
  },
  b09: {
    canonicalUrl: "https://mqg.org.il/%D7%94%D7%AA%D7%A0%D7%95%D7%A2%D7%94-%D7%9C%D7%90%D7%99%D7%9B%D7%95%D7%AA-%D7%94%D7%A9%D7%9C%D7%98%D7%95%D7%9F-%D7%91%D7%92%D7%A5-%D7%94%D7%A7%D7%A4%D7%99%D7%90-%D7%90%D7%AA-%D7%A1%D7%92%D7%99/",
    searchQuery: "בג\"ץ הקפיא את סגירת גל\"צ ניצחון לחופש הביטוי ולעצמאות התקשורת",
    anchorText: "ניצחון חשוב לחופש הביטוי ולעצמאות התקשורת",
  },
  b10: {
    canonicalUrl: "https://mqg.org.il/%D7%94%D7%AA%D7%A0%D7%95%D7%A2%D7%94-%D7%9C%D7%90%D7%99%D7%9B%D7%95%D7%AA-%D7%94%D7%A9%D7%9C%D7%98%D7%95%D7%9F-%D7%94%D7%97%D7%9C%D7%98%D7%AA-%D7%91%D7%92%D7%A5-%D7%9C%D7%94%D7%A7%D7%A4%D7%99/",
    searchQuery: "צו על תנאי וצו ביניים חקירת מבקר המדינה 31.12.2025",
    anchorText: "צו על תנאי וצו ביניים שהקפיאו את החקירה",
  },
  b11: {
    canonicalUrl: "https://mqg.org.il/%D7%94%D7%AA%D7%A0%D7%95%D7%A2%D7%94-%D7%9C%D7%90%D7%99%D7%9B%D7%95%D7%AA-%D7%94%D7%A9%D7%9C%D7%98%D7%95%D7%9F-%D7%94%D7%97%D7%9C%D7%98%D7%AA-%D7%91%D7%92%D7%A5-%D7%9C%D7%94%D7%A7%D7%A4%D7%99/",
    searchQuery: "ועדת חקירה ממלכתית ולא הליך חלופי 7 באוקטובר",
    anchorText: "יש צורך בוועדת חקירה ממלכתית",
  },
  b12: {
    canonicalUrl: "https://mqg.org.il/%D7%94%D7%AA%D7%A0%D7%95%D7%A2%D7%94-%D7%9C%D7%90%D7%99%D7%9B%D7%95%D7%AA-%D7%94%D7%A9%D7%9C%D7%98%D7%95%D7%9F-%D7%91%D7%AA%D7%92%D7%95%D7%91%D7%94-%D7%9C%D7%A4%D7%A1%D7%99%D7%A7%D7%AA-%D7%91%D7%92/",
    searchQuery: "תגובת התנועה לפסיקת בג\"ץ בנושא הגיוס 04.01.2026 12000",
    anchorText: "התנועה דרשה לגייס 12,000 לוחמים",
  },
  b13: {
    canonicalUrl: "https://mqg.org.il/%D7%94%D7%AA%D7%A0%D7%95%D7%A2%D7%94-%D7%9C%D7%90%D7%99%D7%9B%D7%95%D7%AA-%D7%94%D7%A9%D7%9C%D7%98%D7%95%D7%9F-%D7%91%D7%AA%D7%92%D7%95%D7%91%D7%94-%D7%9C%D7%A4%D7%A1%D7%99%D7%A7%D7%AA-%D7%91%D7%92/",
    searchQuery: "פסיקת בג\"ץ בנושא הגיוס אכיפה פלילית וכלכלית 04.01.2026",
    anchorText: "נדרשה אכיפה פלילית וכלכלית",
  },
  b14: {
    canonicalUrl: "https://mqg.org.il/%D7%95%D7%A2%D7%93%D7%AA-%D7%93%D7%95%D7%AA%D7%9F-%D7%A4%D7%A1%D7%9C%D7%94-%D7%90%D7%AA-%D7%9E%D7%99%D7%A0%D7%95%D7%99%D7%95-%D7%A9%D7%9C-%D7%AA%D7%9E%D7%99%D7%A8-%D7%A4%D7%A8%D7%A5-%D7%9C%D7%9E%D7%A9/",
    searchQuery: "ועדת דותן פסלה את מינוי תמיר פרץ שלוש פניות 15.01.2026",
    anchorText: "הפסילה באה בעקבות שלוש פניות",
  },
  b15: {
    canonicalUrl: "https://mqg.org.il/%D7%94%D7%AA%D7%A0%D7%95%D7%A2%D7%94-%D7%9C%D7%90%D7%99%D7%9B%D7%95%D7%AA-%D7%94%D7%A9%D7%9C%D7%98%D7%95%D7%9F-%D7%93%D7%95%D7%A8%D7%A9%D7%AA-%D7%9E%D7%A8%D7%90%D7%A9-%D7%94%D7%9E%D7%9E%D7%A9%D7%9C-2/",
    searchQuery: "דרישה לבטל את מינוי נ לסגן ראש השב\"כ 18.01.2026",
    anchorText: "לבטל את המינוי בשל אי תקינות ההליך וחשש לניגוד עניינים",
  },
  b16: {
    canonicalUrl: "https://mqg.org.il/%D7%94%D7%AA%D7%A0%D7%95%D7%A2%D7%94-%D7%9C%D7%90%D7%99%D7%9B%D7%95%D7%AA-%D7%94%D7%A9%D7%9C%D7%98%D7%95%D7%9F-%D7%91%D7%AA%D7%92%D7%95%D7%91%D7%94-%D7%9C%D7%97%D7%95%D7%95%D7%AA-%D7%94%D7%93%D7%A2/",
    searchQuery: "תגובה לחוות דעת היועמ\"שית 25.01.2026 שינוי תקנון עבודת הממשלה",
    anchorText: "להחלטות ללא בחינה משפטית מספקת",
  },
  b17: {
    searchQuery: "פנייה לרה\"מ ולשר אמסלם רשות החברות הממשלתיות 05.02.2026",
    anchorText: "הפנייה הופנתה לרה\"מ ולשר דודי אמסלם",
  },
  b18: {
    canonicalUrl: "https://mqg.org.il/%D7%A7%D7%A8%D7%90%D7%95-%D7%90%D7%AA-%D7%AA%D7%92%D7%95%D7%91%D7%AA-%D7%94%D7%AA%D7%A0%D7%95%D7%A2%D7%94-%D7%9C%D7%90%D7%99%D7%9B%D7%95%D7%AA-%D7%94%D7%A9%D7%9C%D7%98%D7%95%D7%9F-%D7%A2%D7%9C-%D7%94/",
    searchQuery: "תגובה להודעת לשכת רה\"מ בנושא מינוי ראש השב\"כ 12.06.2025",
    anchorText: "בג\"ץ כבר פסק לראש הממשלה ניגוד עניינים",
  },
  b19: {
    canonicalUrl: "https://mqg.org.il/%D7%94%D7%AA%D7%A0%D7%95%D7%A2%D7%94-%D7%9C%D7%90%D7%99%D7%9B%D7%95%D7%AA-%D7%94%D7%A9%D7%9C%D7%98%D7%95%D7%9F-%D7%A4%D7%95%D7%A0%D7%94-%D7%A0%D7%92%D7%93-%D7%94%D7%9B%D7%95%D7%95%D7%A0%D7%94-%D7%9C/",
    searchQuery: "התראה בנושא תוכנית הגבלת טיסות יציאה 18.06.2025 סעיף 6",
    anchorText: "הזכות לצאת מישראל המעוגנת בסעיף 6",
  },
  b20: {
    canonicalUrl: "https://mqg.org.il/%D7%94%D7%AA%D7%A0%D7%95%D7%A2%D7%94-%D7%9C%D7%90%D7%99%D7%9B%D7%95%D7%AA-%D7%94%D7%A9%D7%9C%D7%98%D7%95%D7%9F-%D7%A2%D7%9C-%D7%93%D7%91%D7%A8%D7%99-%D7%A9%D7%A8-%D7%94%D7%91%D7%99%D7%98%D7%97%D7%95/",
    searchQuery: "תגובה לדברי שר הביטחון בנושא שוויון בנטל 15.03.2025",
    anchorText: "לא התקיימה אכיפה רצינית לאורך השנים",
  },
};
const EDUCATIONAL_KEYWORDS = [
  "תוצאה",
  "השפעה",
  "משמעות",
  "הישג",
  "ביקורת",
  "דרישה",
  "ציבור",
  "שלטון",
  "אכיפה",
  "אחריות",
  "שקיפות",
  "יישום",
  "פעולה",
  "מהלך",
];
const LOW_QUALITY_DISTRACTOR_PATTERNS = [
  /משאל\s*עם/i,
  /יועץ\s*חינוכי/i,
  /ועדת\s*הבחירות/i,
  /בית\s*דין\s*צבאי/i,
];
const DISTRACTOR_FEEDBACK_LIBRARY = {
  default: [
    {
      pattern: /(ללא|בלי)\s+(אכיפה|סנקציות|בדיקה)/i,
      reason: "האפשרות הזו מתארת היעדר יישום, בזמן שהקו במשחק מדגיש אחריות ויישום בפועל.",
    },
    {
      pattern: /(נדחה|בוטל|לא נקבע)/i,
      reason: "האפשרות מתארת חוסר התקדמות, אך המקור מצביע על מהלך פעיל או דרישה אופרטיבית.",
    },
    {
      pattern: /(יחסי ציבור|הסברה בלבד|סמלי בלבד)/i,
      reason: "זו הצגה מצמצמת מדי; הנושאים במשחק מבוססים על צעדים משפטיים/מוסדיים ממשיים.",
    },
  ],
  "שוויון בנטל": [
    {
      pattern: /(תמריצים בלבד|ללא אכיפה|ללא סנקציות)/i,
      reason: "בהקשר של שוויון בנטל, הדגש הוא על אכיפה ומדדי ביצוע ולא רק תמריצים.",
    },
    {
      pattern: /(פטורים רחבים|פטור גורף)/i,
      reason: "האפשרות סותרת את עקרון השוויון; פטורים אמורים להיות חריגים ומנומקים.",
    },
  ],
  "מערכת המשפט ומינויים": [
    {
      pattern: /(ללא ביקורת שיפוטית|ללא בחינה משפטית)/i,
      reason: "האפשרות מפחיתה את מנגנוני הבקרה, בעוד שהחומר מדגיש הליך תקין ובלמים מוסדיים.",
    },
    {
      pattern: /(מינוי אוטומטי|אישור מיידי ללא בדיקה)/i,
      reason: "מינויים מחייבים הליך תקין ובקרה; האופציה הזו מדלגת על שלבי בקרה מרכזיים.",
    },
  ],
  "תקשורת ושקיפות": [
    {
      pattern: /(ללא פרסום|דיון פנימי בלבד|ללא שקיפות)/i,
      reason: "בנושא זה הדגש הוא שקיפות ואמון ציבורי, ולכן אפשרות שסוגרת מידע לציבור אינה תואמת.",
    },
  ],
};
const OFFICIAL_BANNER_IMAGES = [
  "https://mqg.org.il/wp-content/uploads/old/2015/10/rsz_mg_8514.jpg",
  "https://mqg.org.il/wp-content/uploads/old/2015/01/New-Rights-with-Nitzan.jpg",
  "https://mqg.org.il/wp-content/uploads/2017/03/Training-session-for-activists.jpg",
  "https://mqg.org.il/wp-content/uploads/2016/02/cityoflaw.jpg",
  "https://mqg.org.il/wp-content/uploads/2017/11/36906678_2090317451211576_7722012771540928512_o.jpg",
];
const HE_MONTHS = [
  "ינואר",
  "פברואר",
  "מרץ",
  "אפריל",
  "מאי",
  "יוני",
  "יולי",
  "אוגוסט",
  "ספטמבר",
  "אוקטובר",
  "נובמבר",
  "דצמבר",
];

const QUESTION_VARIANT_PREFIXES = [
  "לפי פעילות התנועה,",
  "בהתאם לעמדת התנועה,",
  "לאור ההתערבות של התנועה,",
  "בהמשך לעתירה או לפנייה הציבורית,",
  "במבט מעשי על האירוע,",
  "בהיבט של שמירה על מנהל תקין,",
  "בהקשר של שלטון החוק,",
  "בבחינה אזרחית של המקרה,",
  "לפי המסר המרכזי של התנועה,",
  "בהתאם לעקרונות שהתנועה קידמה,",
  "במיקוד על התוצאה לציבור,",
  "בהמשך למהלך שהובילה התנועה,",
  "בפרשנות פשוטה לציבור הרחב,",
  "מתוך היעד שהתנועה הגדירה,",
  "בהיבט של אחריות שלטונית,",
  "בהתאם לפעולה שנדרשה מהרשויות,",
  "בקריאה מעשית של המהלך,",
  "לפי הקו הציבורי שהתנועה הציגה,",
  "בהמשך לפעילות האכיפה והפיקוח,",
  "בהתאם להישג שהתנועה ביקשה לקבע,",
  "במיקוד על היישום בפועל,",
  "בהסתכלות על טובת הציבור,",
  "בהמשך למסר נגד שחיתות שלטונית,",
  "בהתאם לפעילות הנוכחית של התנועה,",
];

const ENTRY_DEPARTMENTS = {
  TELEMARKETING: "telemarketing",
  EDUCATION: "education",
};

const QUICK_MODES = {
  REGULAR: "regular",
  SEASONAL: "seasonal",
  ACTIVITY: "activity",
};

const GENERATED_TOPIC_STEMS = [
  "איזו קביעה משקפת בצורה הטובה ביותר את עמדת התנועה בנושא {topic}?",
  "לפי עקרונות המהלך בנושא {topic}, מהו הצעד הנכון ביותר?",
  "מה מהבאים תואם למדיניות אחראית שנדרשת בנושא {topic}?",
  "בהיבט של שלטון החוק, איזו אמירה נכונה לגבי {topic}?",
  "איזה מהמשפטים הבאים מתאר נכון את היעד המרכזי בנושא {topic}?",
  "מהו הדגש העיקרי שעליו מצביע הדיון הציבורי סביב {topic}?",
  "כאשר בוחנים יישום בפועל של {topic}, מה נכון לומר?",
  "איזו אפשרות מייצגת גישה מוסדית תקינה בנושא {topic}?",
];
const SOURCE_BACKED_TOPIC_PROMPTS = [
  "לפי פרסומי התנועה, איזו קביעה משקפת נכון את המסר בנושא {topic}?",
  "איזו מהאפשרויות נתמכת ישירות במקור שפורסם בנושא {topic}?",
  "בהתאם לפרסום הרשמי בנושא {topic}, מה נכון לומר?",
];

const TELEMARKETING_ACTIVITY_TOPIC_CONFIGS = [
  {
    id: "oct7",
    title: "הקמת ועדת חקירה ממלכתית על השביעי באוקטובר",
    shortTitle: "הקמת ועדת חקירה ממלכתית על 7 באוקטובר",
    category: "מערכת המשפט ומינויים",
    kind: "activity",
    date: "2026-02-09",
    learn:
      "הדגש בנושא זה הוא חקירה עצמאית, אמינה ומבוססת נתונים, עם מסקנות שניתנות ליישום ממשי.",
    facts: [
      "ועדת חקירה ממלכתית אמורה לפעול באופן עצמאי מהדרג הפוליטי.",
      "מטרת הוועדה היא בירור עומק של הכשלים שהובילו לאירועי 7 באוקטובר.",
      "לוועדה ממלכתית יש סמכות לזמן עדים ולדרוש מסמכים רלוונטיים.",
      "אמון ציבורי דורש הליך בדיקה מקצועי ושקוף ככל האפשר.",
      "קביעת לוחות זמנים ברורים מונעת דחיות בלתי סבירות.",
      "הבדיקה צריכה לכלול אחריות בדרג המדיני והמקצועי גם יחד.",
      "דוחות ביניים יכולים לשפר מוכנות עוד לפני הדוח הסופי.",
      "המלצות אופרטיביות נדרשות כדי למנוע חזרה על כשלים.",
      "תיעוד מלא של שרשרת קבלת ההחלטות הוא תנאי להפקת לקחים.",
      "שיתוף ציבור ומשפחות הנפגעים מחזק את אמינות התהליך.",
      "בחינה של מערכי התרעה ומענה היא חלק מרכזי במנדט הוועדה.",
      "דו\"ח נגיש לציבור מסייע לבקרה אזרחית על יישום המלצות.",
      "פיקוח מתמשך לאחר פרסום המסקנות חיוני להטמעתן.",
      "בירור בלתי תלוי עדיף על מנגנון בדיקה הנתון לניגוד עניינים.",
      "חקירה ממלכתית אמורה לבחון לא רק מה קרה אלא גם למה זה קרה.",
    ],
    distractors: [
      "הוועדה נועדה בעיקר ליחסי ציבור ללא סמכויות חקירה מעשיות.",
      "אין צורך בבדיקת הדרג המדיני אם נבדקים רק גורמי שטח.",
      "פרסום מסקנות לציבור אינו חשוב כל עוד מתקיים דיון פנימי.",
      "אפשר לדחות את הבדיקה לשנים קדימה בלי לפגוע בהפקת לקחים.",
      "מספיק לפרסם סיכום קצר ללא המלצות יישומיות.",
      "עדיף להימנע מזימון עדים כדי לקצר הליכים.",
      "בדיקה אפקטיבית לא מחייבת נתונים או מסמכים רשמיים.",
      "אין ערך לדוחות ביניים בזמן שהאירוע עדיין נבחן.",
      "הפרדת אחריות בין דרגים אינה רלוונטית לחקירה מערכתית.",
      "אמון ציבורי נשמר גם כשאין שקיפות על עבודת הוועדה.",
      "אין צורך לעקוב אחרי יישום ההמלצות לאחר פרסום הדוח.",
      "מנגנון תלוי ממשלה מספק אותה רמת עצמאות כמו ועדה ממלכתית.",
    ],
  },
  {
    id: "burden",
    title: "שוויון בנטל",
    shortTitle: "שוויון בנטל",
    category: "שוויון בנטל",
    kind: "activity",
    date: "2026-02-09",
    learn:
      "הקו המרכזי הוא חובת שירות הוגנת, שקופה ואכיפה עקבית שמגובה בנתונים ומדדי ביצוע.",
    facts: [
      "שוויון בנטל מחייב מסגרת שירות הוגנת לכלל האוכלוסיות.",
      "יעדי גיוס חייבים להיות מדידים, שקופים ומבוססי ביצוע.",
      "אכיפה אפקטיבית כוללת כלים כלכליים ואישיים לפי חוק.",
      "פרסום נתונים שוטף מאפשר בקרה ציבורית אמינה.",
      "פטורים צריכים להיות חריגים, ממוקדים ומנומקים.",
      "שירות חלופי חייב להיות משמעותי ומפוקח ברמה לאומית.",
      "לכידות חברתית מתחזקת כשחלוקת הנטל נתפסת כהוגנת.",
      "המדינה אחראית ליישום בפועל ולא רק להצגת יעדים.",
      "תמריצים לבדם לא מספיקים ללא מנגנון אכיפה ברור.",
      "פיקוח פרלמנטרי קבוע מחזק אמון בהחלטות בנושא השירות.",
      "ניטור חודשי של נתוני גיוס מאפשר תיקון מהיר בזמן אמת.",
      "הסדרה ארוכת טווח דורשת מדדי הצלחה ברורים מראש.",
      "השתמטות שיטתית פוגעת בעיקרון השוויון בפני החוק.",
      "מסלולי שירות מותאמים יכולים לשפר השתלבות בלי לפגוע בעיקרון השוויון.",
      "שילוב בין יעדים, אכיפה ושקיפות הוא בסיס למדיניות יציבה.",
    ],
    distractors: [
      "שוויון בנטל יכול להישען על הצהרות בלבד ללא מדדי ביצוע.",
      "פטורים רחבים ללא נימוק מחזקים את אמון הציבור במערכת.",
      "אין צורך בפרסום נתונים אם קיימת הערכה פנימית.",
      "תמריצים מספיקים לחלוטין גם בלי אכיפה בכלל.",
      "פיקוח שוטף של הכנסת מיותר כאשר נקבעת מדיניות ממשלתית.",
      "מדיניות שירות יעילה לא דורשת בדיקת תוצאות תקופתית.",
      "ניתן להשיג שוויון גם כשאכיפה מופעלת באופן לא אחיד.",
      "שירות חלופי יכול להיות סמלי בלבד בלי סטנדרטים ברורים.",
      "אין קשר בין חלוקת הנטל לבין תחושת הלכידות החברתית.",
      "היעדר נתונים לא פוגע ביכולת להעריך עמידה ביעדים.",
      "החלת כללים שונים לקבוצות שונות מחזקת שוויון משפטי.",
      "מדיניות יציבה לא מחייבת כלל מנגנון בקרה.",
    ],
  },
  {
    id: "judicial",
    title: "ההפיכה המשפטית",
    shortTitle: "ההפיכה המשפטית",
    category: "מערכת המשפט ומינויים",
    kind: "activity",
    date: "2026-02-09",
    learn:
      "הדגש הוא שמירה על איזונים ובלמים, עצמאות שיפוטית והליכי חקיקה אחראיים שמגנים על זכויות יסוד.",
    facts: [
      "עצמאות מערכת המשפט היא רכיב יסודי בהגנה על זכויות אדם.",
      "איזונים ובלמים נועדו למנוע ריכוז כוח בידי גורם שלטוני יחיד.",
      "ביקורת שיפוטית בוחנת את חוקיות פעולות הרשות המבצעת והמחוקקת.",
      "שינויים מבניים דורשים דיון ציבורי רחב ושקוף.",
      "חקיקה מהירה מדי עלולה לפגוע באיכות ההסדרים.",
      "שקיפות עבודת הוועדות חיונית לאמון הציבור בתהליך.",
      "מנגנון מינוי שופטים מאוזן חשוב לשמירה על עצמאות מקצועית.",
      "ייעוץ משפטי עצמאי מסייע למנוע החלטות בלתי חוקיות.",
      "פגיעה בביקורת החוקתית עלולה להשפיע על קבוצות מיעוט.",
      "יציבות משפטית תורמת גם לוודאות כלכלית ומשילות תקינה.",
      "שיח ציבורי אחראי מפחית קיטוב סביב מערכת המשפט.",
      "בדיקת השלכות רוחב צריכה להקדים כל שינוי מוסדי עמוק.",
      "אמון ציבורי נשען על תפיסה של עצמאות מקצועית ולא תלות פוליטית.",
      "הגבלת כוח שלטוני דורשת כללים ברורים ואכיפים.",
      "רפורמה מאוזנת נמדדת ביכולת לשמור על משילות לצד זכויות.",
    ],
    distractors: [
      "עצמאות שיפוטית פוגעת מטבעה במשילות ולכן אין בה צורך.",
      "ריכוז כוח בידי גורם אחד מייעל שלטון ולכן עדיף על איזונים.",
      "ביקורת שיפוטית מיותרת כאשר יש רוב פוליטי ברור.",
      "חקיקה מבנית יכולה להתקדם ללא דיון ציבורי כלל.",
      "שקיפות הוועדות אינה משפיעה על אמון הציבור.",
      "מינוי שופטים פוליטי בלבד מספק אותה עצמאות מקצועית.",
      "ייעוץ משפטי תלוי דרג פוליטי יעיל יותר לשמירה על חוקיות.",
      "אין השפעה לשינויים חוקתיים על קבוצות מיעוט.",
      "יציבות משפטית אינה קשורה כלל לכלכלה או להשקעות.",
      "שיח מקטב מסייע לבניית אמון סביב מערכת המשפט.",
      "אפשר לבצע שינוי מוסדי עמוק בלי לבחון השלכות רוחב.",
      "משילות וזכויות יסוד הן מטרות סותרות שאי אפשר לאזן ביניהן.",
    ],
  },
];

const TELEMARKETING_ACTIVITY_SOURCE_FACTS = {
  oct7: [
    {
      fact: "התנועה דרשה הקמת ועדת חקירה ממלכתית עצמאית שאינה כפופה לדרג הפוליטי.",
      sourceLabel: "צו על תנאי וצו ביניים בנושא חקירת המבקר (31.12.2025)",
      canonicalUrl:
        "https://mqg.org.il/%d7%91%d7%92%d7%a5-%d7%94%d7%95%d7%a8%d7%94-%d7%9c%d7%94%d7%95%d7%a6%d7%99%d7%90-%d7%a6%d7%95-%d7%a2%d7%9c-%d7%aa%d7%a0%d7%90%d7%99-%d7%95%d7%a6%d7%95-%d7%91%d7%99%d7%a0%d7%99%d7%99%d7%9d-%d7%94%d7%9e/",
      anchorText: "יש צורך בוועדת חקירה ממלכתית",
    },
    {
      fact: "בג\"ץ הוציא צו על תנאי וצו ביניים שהקפיאו את חקירת המבקר בנושא מחדל 7 באוקטובר.",
      sourceLabel: "צו על תנאי וצו ביניים בנושא חקירת המבקר (31.12.2025)",
      canonicalUrl:
        "https://mqg.org.il/%d7%91%d7%92%d7%a5-%d7%94%d7%95%d7%a8%d7%94-%d7%9c%d7%94%d7%95%d7%a6%d7%99%d7%90-%d7%a6%d7%95-%d7%a2%d7%9c-%d7%aa%d7%a0%d7%90%d7%99-%d7%95%d7%a6%d7%95-%d7%91%d7%99%d7%a0%d7%99%d7%99%d7%9d-%d7%94%d7%9e/",
      anchorText: "צו על תנאי וצו ביניים שהקפיאו את החקירה",
    },
    {
      fact: "חקירה ממלכתית נדרשת לברר לעומק גם את האחריות המדינית וגם את האחריות המקצועית.",
      sourceLabel: "ועדת חקירה ממלכתית 7 באוקטובר - עמדת התנועה",
      sourceQuery: "ועדת חקירה ממלכתית 7 באוקטובר אחריות מדינית ומקצועית",
      anchorText: "בירור אחריות בדרג המדיני והמקצועי",
    },
    {
      fact: "לוועדת חקירה ממלכתית יש חשיבות בזימון עדים ודרישת מסמכים לצורך בדיקה מלאה.",
      sourceLabel: "ועדת חקירה ממלכתית 7 באוקטובר - עמדת התנועה",
      sourceQuery: "ועדת חקירה ממלכתית זימון עדים דרישת מסמכים",
      anchorText: "סמכות לזמן עדים ולדרוש מסמכים",
    },
    {
      fact: "התנועה הדגישה שמנגנון חלופי אינו תחליף לוועדה ממלכתית בלתי תלויה.",
      sourceLabel: "צו על תנאי וצו ביניים בנושא חקירת המבקר (31.12.2025)",
      canonicalUrl:
        "https://mqg.org.il/%d7%91%d7%92%d7%a5-%d7%94%d7%95%d7%a8%d7%94-%d7%9c%d7%94%d7%95%d7%a6%d7%99%d7%90-%d7%a6%d7%95-%d7%a2%d7%9c-%d7%aa%d7%a0%d7%90%d7%99-%d7%95%d7%a6%d7%95-%d7%91%d7%99%d7%a0%d7%99%d7%99%d7%9d-%d7%94%d7%9e/",
      anchorText: "ועדה ממלכתית ולא הליך חלופי",
    },
    {
      fact: "פרסום מסקנות לציבור וחיזוק שקיפות נתפסים כתנאי לאמון ציבורי בתהליך הבדיקה.",
      sourceLabel: "ועדת חקירה ממלכתית 7 באוקטובר - עמדת התנועה",
      sourceQuery: "ועדת חקירה ממלכתית שקיפות אמון ציבורי",
      anchorText: "אמון ציבורי דורש הליך בדיקה מקצועי ושקוף",
    },
    {
      fact: "קביעת לוחות זמנים מחייבים נתפסת כדרך למנוע מריחה ודחיות לא סבירות בבדיקה.",
      sourceLabel: "ועדת חקירה ממלכתית 7 באוקטובר - עמדת התנועה",
      sourceQuery: "ועדת חקירה ממלכתית לוחות זמנים ברורים",
      anchorText: "לוחות זמנים ברורים מונעים דחיות",
    },
    {
      fact: "דוחות ביניים נועדו לאפשר תיקונים מבצעיים מוקדמים עוד לפני הדוח הסופי.",
      sourceLabel: "ועדת חקירה ממלכתית 7 באוקטובר - עמדת התנועה",
      sourceQuery: "ועדת חקירה ממלכתית דוחות ביניים המלצות אופרטיביות",
      anchorText: "דוחות ביניים לשיפור מוכנות",
    },
    {
      fact: "התנועה הדגישה את הצורך במנגנון פיקוח על יישום ההמלצות גם לאחר פרסום הדוח.",
      sourceLabel: "ועדת חקירה ממלכתית 7 באוקטובר - עמדת התנועה",
      sourceQuery: "ועדת חקירה ממלכתית פיקוח על יישום המלצות",
      anchorText: "פיקוח מתמשך לאחר פרסום המסקנות",
    },
    {
      fact: "שיתוף משפחות הנפגעים וציבור רחב מחזק את הלגיטימציה והאמינות של הוועדה.",
      sourceLabel: "ועדת חקירה ממלכתית 7 באוקטובר - עמדת התנועה",
      sourceQuery: "ועדת חקירה ממלכתית שיתוף משפחות נפגעים אמון ציבורי",
      anchorText: "שיתוף ציבור ומשפחות הנפגעים מחזק אמינות",
    },
  ],
  burden: [
    {
      fact: "בהודעת התנועה הודגש יעד גיוס של 12,000 לוחמים כחלק מיישום שוויון בנטל.",
      sourceLabel: "תגובת התנועה לפסיקת בג\"ץ בנושא הגיוס (04.01.2026)",
      canonicalUrl:
        "https://mqg.org.il/%d7%aa%d7%92%d7%95%d7%91%d7%aa-%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94%d7%a9%d7%9c%d7%98%d7%95%d7%9f-%d7%9c%d7%a4%d7%a1%d7%99%d7%a7%d7%aa-%d7%91%d7%92/",
      anchorText: "התנועה דרשה לגייס 12,000 לוחמים",
    },
    {
      fact: "התנועה דרשה אכיפה פלילית וכלכלית ולא הסתפקה בהצהרות כלליות.",
      sourceLabel: "תגובת התנועה לפסיקת בג\"ץ בנושא הגיוס (04.01.2026)",
      canonicalUrl:
        "https://mqg.org.il/%d7%aa%d7%92%d7%95%d7%91%d7%aa-%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94%d7%a9%d7%9c%d7%98%d7%95%d7%9f-%d7%9c%d7%a4%d7%a1%d7%99%d7%a7%d7%aa-%d7%91%d7%92/",
      anchorText: "נדרשה אכיפה פלילית וכלכלית",
    },
    {
      fact: "שוויון בנטל מוצג כעיקרון המחייב מסגרת שירות הוגנת לכלל האוכלוסיות.",
      sourceLabel: "שוויון בנטל - עמדת התנועה",
      sourceQuery: "שוויון בנטל מסגרת שירות הוגנת לכלל האוכלוסיות",
      anchorText: "מסגרת שירות הוגנת לכלל האוכלוסיות",
    },
    {
      fact: "פרסום נתוני גיוס שוטפים נדרש כדי לאפשר בקרה ציבורית אמינה.",
      sourceLabel: "שוויון בנטל - עמדת התנועה",
      sourceQuery: "שוויון בנטל פרסום נתוני גיוס שקיפות בקרה ציבורית",
      anchorText: "פרסום נתונים שוטף מאפשר בקרה ציבורית",
    },
    {
      fact: "פטורים רחבים ללא נימוק אינם עולים בקנה אחד עם עקרון השוויון בפני החוק.",
      sourceLabel: "שוויון בנטל - עמדת התנועה",
      sourceQuery: "שוויון בנטל פטורים חריגים ממוקדים מנומקים",
      anchorText: "פטורים צריכים להיות חריגים ומנומקים",
    },
    {
      fact: "שירות חלופי אמור להיות משמעותי ומפוקח ולא מסלול סמלי בלבד.",
      sourceLabel: "שוויון בנטל - עמדת התנועה",
      sourceQuery: "שוויון בנטל שירות חלופי משמעותי מפוקח",
      anchorText: "שירות חלופי חייב להיות משמעותי ומפוקח",
    },
    {
      fact: "ניטור חודשי של נתוני הגיוס נתפס ככלי מרכזי לתיקון מהיר בזמן אמת.",
      sourceLabel: "שוויון בנטל - עמדת התנועה",
      sourceQuery: "שוויון בנטל ניטור חודשי נתוני גיוס תיקון מהיר",
      anchorText: "ניטור חודשי מאפשר תיקון מהיר",
    },
    {
      fact: "פיקוח פרלמנטרי קבוע מוצג כחלק מחיזוק אמון הציבור בהחלטות בנושא השירות.",
      sourceLabel: "שוויון בנטל - עמדת התנועה",
      sourceQuery: "שוויון בנטל פיקוח פרלמנטרי קבוע אמון הציבור",
      anchorText: "פיקוח פרלמנטרי קבוע מחזק אמון",
    },
    {
      fact: "התנועה הדגישה שתמריצים לבדם אינם מספיקים ללא מנגנון אכיפה ברור.",
      sourceLabel: "תגובה לדברי שר הביטחון בנושא שוויון בנטל (15.03.2025)",
      canonicalUrl:
        "https://mqg.org.il/%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94%d7%a9%d7%9c%d7%98%d7%95%d7%9f-%d7%91%d7%aa%d7%92%d7%95%d7%91%d7%94-%d7%9c%d7%93%d7%91%d7%a8%d7%99-%d7%a9%d7%a8-3/",
      anchorText: "לא התקיימה אכיפה רצינית לאורך השנים",
    },
    {
      fact: "יישום בפועל מוצג כאחריות המדינה ולא כיעד תיאורטי בלבד.",
      sourceLabel: "שוויון בנטל - עמדת התנועה",
      sourceQuery: "שוויון בנטל אחריות המדינה ליישום בפועל",
      anchorText: "המדינה אחראית ליישום בפועל",
    },
  ],
  judicial: [
    {
      fact: "התנועה מציגה את עצמאות מערכת המשפט כרכיב יסודי בהגנה על זכויות אדם.",
      sourceLabel: "ההפיכה המשפטית - עמדת התנועה",
      sourceQuery: "ההפיכה המשפטית עצמאות מערכת המשפט הגנה על זכויות אדם",
      anchorText: "עצמאות מערכת המשפט היא רכיב יסודי",
    },
    {
      fact: "איזונים ובלמים נועדו למנוע ריכוז כוח שלטוני בידי גורם אחד.",
      sourceLabel: "ההפיכה המשפטית - עמדת התנועה",
      sourceQuery: "ההפיכה המשפטית איזונים ובלמים מניעת ריכוז כוח",
      anchorText: "איזונים ובלמים למניעת ריכוז כוח",
    },
    {
      fact: "ביקורת שיפוטית מוצגת ככלי לבחינת חוקיות פעולות הרשות המבצעת והמחוקקת.",
      sourceLabel: "ההפיכה המשפטית - עמדת התנועה",
      sourceQuery: "ההפיכה המשפטית ביקורת שיפוטית חוקיות פעולות הרשות המבצעת",
      anchorText: "ביקורת שיפוטית בוחנת חוקיות",
    },
    {
      fact: "שינויים מוסדיים עמוקים צריכים להתבצע לאחר דיון ציבורי רחב ושקוף.",
      sourceLabel: "ההפיכה המשפטית - עמדת התנועה",
      sourceQuery: "ההפיכה המשפטית דיון ציבורי רחב ושקוף",
      anchorText: "שינויים מבניים דורשים דיון ציבורי רחב",
    },
    {
      fact: "חקיקה מהירה מדי נתפסת כסיכון לאיכות ההסדרים ולבדיקת השלכות רוחב.",
      sourceLabel: "ההפיכה המשפטית - עמדת התנועה",
      sourceQuery: "ההפיכה המשפטית חקיקה מהירה מדי סיכון לאיכות ההסדרים",
      anchorText: "חקיקה מהירה עלולה לפגוע באיכות ההסדרים",
    },
    {
      fact: "שקיפות עבודת ועדות החקיקה חיונית לשמירה על אמון הציבור.",
      sourceLabel: "תגובה לחוות דעת היועמ\"שית (25.01.2026)",
      canonicalUrl:
        "https://mqg.org.il/%d7%aa%d7%92%d7%95%d7%91%d7%aa-%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94%d7%a9%d7%9c%d7%98%d7%95%d7%9f-%d7%9c%d7%97%d7%95%d7%95%d7%aa-%d7%93%d7%a2%d7%aa/",
      anchorText: "שינוי תקנון עבודת הממשלה ללא בחינה מספקת",
    },
    {
      fact: "מנגנון מאוזן למינוי שופטים מוצג כתנאי לשמירה על עצמאות מקצועית.",
      sourceLabel: "ההפיכה המשפטית - עמדת התנועה",
      sourceQuery: "ההפיכה המשפטית מנגנון מינוי שופטים מאוזן עצמאות מקצועית",
      anchorText: "מנגנון מינוי שופטים מאוזן חשוב",
    },
    {
      fact: "ייעוץ משפטי עצמאי נתפס ככלי שמונע החלטות בלתי חוקיות בממשלה.",
      sourceLabel: "תגובה לחוות דעת היועמ\"שית (25.01.2026)",
      canonicalUrl:
        "https://mqg.org.il/%d7%aa%d7%92%d7%95%d7%91%d7%aa-%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94%d7%a9%d7%9c%d7%98%d7%95%d7%9f-%d7%9c%d7%97%d7%95%d7%95%d7%aa-%d7%93%d7%a2%d7%aa/",
      anchorText: "להחלטות ללא בחינה משפטית מספקת",
    },
    {
      fact: "פגיעה בביקורת החוקתית נתפסת כמסכנת במיוחד קבוצות מיעוט.",
      sourceLabel: "ההפיכה המשפטית - עמדת התנועה",
      sourceQuery: "ההפיכה המשפטית פגיעה בביקורת החוקתית קבוצות מיעוט",
      anchorText: "פגיעה בביקורת החוקתית משפיעה על קבוצות מיעוט",
    },
    {
      fact: "רפורמה מאוזנת נבחנת לפי יכולתה לשמור גם על משילות וגם על זכויות יסוד.",
      sourceLabel: "ההפיכה המשפטית - עמדת התנועה",
      sourceQuery: "ההפיכה המשפטית איזון בין משילות לזכויות יסוד",
      anchorText: "משילות וזכויות יסוד דורשות איזון",
    },
  ],
};

const EDUCATION_DEPARTMENT_TOPIC_CONFIG = {
  id: "education_core",
  title: "אגף חינוך",
  shortTitle: "חינוך אזרחי ודמוקרטי",
  category: "פעילות ציבורית",
  kind: "activity",
  date: "2026-02-09",
  learn:
    "המשחק של אגף החינוך מתמקד בעקרונות יסוד של אזרחות פעילה, דמוקרטיה, אחריות ציבורית ושלטון חוק.",
  facts: [
    "אזרחות פעילה כוללת מעורבות, ביקורת ושיח מכבד.",
    "שלטון החוק מחייב שכל גורם ציבורי כפוף לאותם כללים.",
    "שקיפות ציבורית מאפשרת לתלמידים לבחון החלטות שלטוניות באופן ביקורתי.",
    "חשיבה ביקורתית דורשת בדיקת עובדות מכמה מקורות אמינים.",
    "זכויות אדם מחייבות גם אחריות כלפי זכויות הזולת.",
    "דיאלוג דמוקרטי כולל הקשבה לעמדות שונות גם במחלוקת.",
    "הבחנה בין עובדה לדעה היא מיומנות יסוד בחינוך אזרחי.",
    "השתתפות תלמידים ביוזמות קהילתיות מחזקת תחושת שייכות.",
    "מנהל תקין נשען על נהלים ברורים ובקרה מתמדת.",
    "כיבוד מוסדות המדינה חשוב לצד ביקורת עניינית על פעולתם.",
    "דיון ערכי איכותי מבוסס טיעון ולא התקפה אישית.",
    "מעקב אחרי יישום החלטות ציבוריות הוא חלק מחינוך לאחריות.",
    "דמוקרטיה יציבה נשענת על אמון, שקיפות ואכיפת כללים.",
    "הבנת תהליכי קבלת החלטות משפרת מעורבות אזרחית מושכלת.",
    "חינוך לערכים משלב ידע, מיומנויות ופעולה מעשית בקהילה.",
  ],
  distractors: [
    "אזרחות פעילה מסתכמת רק בצפייה מהצד ללא מעורבות.",
    "שלטון החוק חל רק על חלק מהציבור לפי נסיבות פוליטיות.",
    "אין צורך לבדוק מקורות אם המידע כתוב בביטחון.",
    "שיח דמוקרטי מחייב ניצחון בוויכוח ולא הקשבה.",
    "זכויות אדם עומדות מעל כל אחריות חברתית.",
    "שקיפות אינה חשובה במוסדות ציבור כל עוד יש הנהלה.",
    "אפשר להחליף טיעונים אישיים במקום דיון עובדתי.",
    "מנהל תקין אינו דורש נהלים או בקרה קבועה.",
    "מעורבות קהילתית אינה קשורה לחינוך אזרחי.",
    "אמון ציבורי לא מושפע מאכיפת כללים או שקיפות.",
    "דמוקרטיה יציבה אינה תלויה בהבנת תהליכי קבלת החלטות.",
    "חינוך לערכים הוא תיאורטי בלבד ללא יישום מעשי.",
  ],
};

const BASE_QUESTIONS = [
  {
    id: "b01",
    category: "מערכת המשפט ומינויים",
    kind: "success",
    date: "2025-08-04",
    learn:
      "בהודעת התנועה מ-04.08.2025 הודגש שבית המשפט עצר מהלך שלטענתם היה בלתי חוקי.",
    question:
      "לפי הודעת התנועה, מה הייתה התוצאה המרכזית בהחלטת בג\"ץ בעניין הדחת ראש השב\"כ?",
    options: [
      "בג\"ץ אישר את ההדחה המיידית",
      "בג\"ץ עצר את ההדחה והקפיא את החלטת הממשלה",
      "בג\"ץ קבע שהממשלה חייבת להשלים הליך תקין לפני כל החלטה",
      "בג\"ץ קבע שהנושא אינו שפיט ולכן לא התערב",
    ],
    answer: 1,
    explanation:
      "לפי הודעת התנועה, בג\"ץ עצר את ההדחה הבלתי חוקית והקפיא את החלטת הממשלה.",
    sources: [
      {
        label: "תגובת העותרת להחלטת בג\"ץ (04.08.2025)",
        url: "https://mqg.org.il/%d7%aa%d7%92%d7%95%d7%91%d7%aa-%d7%94%d7%a2%d7%95%d7%aa%d7%a8%d7%aa-%d7%9c%d7%94%d7%97%d7%9c%d7%98%d7%aa-%d7%91%d7%92%d7%a5-%d7%a0%d7%99%d7%a6%d7%97%d7%95%d7%9f-%d7%9c%d7%a9%d7%9c/",
      },
    ],
  },
  {
    id: "b02",
    category: "פעילות ציבורית",
    kind: "activity",
    date: "2025-08-04",
    learn:
      "התנועה הדגישה שהעתירה נשענה גם על היקף ציבורי רחב.",
    question:
      "כמה עותרים ייצגה התנועה בעתירה, לפי ההודעה מ-04.08.2025?",
    options: ["כ-1,500", "כ-5,000", "מעל 15,000", "מעל 150,000"],
    answer: 2,
    explanation:
      "בהודעה נכתב כי התנועה ייצגה למעלה מ-15,000 עותרים.",
    sources: [
      {
        label: "תגובת העותרת להחלטת בג\"ץ (04.08.2025)",
        url: "https://mqg.org.il/%d7%aa%d7%92%d7%95%d7%91%d7%aa-%d7%94%d7%a2%d7%95%d7%aa%d7%a8%d7%aa-%d7%9c%d7%94%d7%97%d7%9c%d7%98%d7%aa-%d7%91%d7%92%d7%a5-%d7%a0%d7%99%d7%a6%d7%97%d7%95%d7%9f-%d7%9c%d7%a9%d7%9c/",
      },
    ],
  },
  {
    id: "b03",
    category: "מערכת המשפט ומינויים",
    kind: "activity",
    date: "2025-10-03",
    learn:
      "עתירת התנועה נגד מינוי דוד זיני קיבלה מסלול דיון מהיר יחסית בבג\"ץ.",
    question:
      "מה נקבע לגבי מועד הדיון בעתירה נגד מינוי דוד זיני?",
    options: [
      "הדיון נקבע עד סוף נובמבר 2025",
      "הדיון נקבע לאפריל 2026",
      "העתירה נמחקה ללא דיון",
      "הדיון עוכב עד להשלמת חוות דעת משלימה של המדינה",
    ],
    answer: 0,
    explanation:
      "בהודעה צוין שבג\"ץ יקבע דיון בעתירה עד סוף נובמבר 2025.",
    sources: [
      {
        label: "בג\"ץ יקבע דיון בעתירה נגד מינוי דוד זיני (03.10.2025)",
        url: "https://mqg.org.il/%d7%91%d7%92%d7%a5-%d7%99%d7%a7%d7%91%d7%a2-%d7%93%d7%99%d7%95%d7%9f-%d7%91%d7%a2%d7%aa%d7%99%d7%a8%d7%aa-%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94/",
      },
    ],
  },
  {
    id: "b04",
    category: "מערכת המשפט ומינויים",
    kind: "activity",
    date: "2025-10-03",
    learn:
      "בהליך זה בג\"ץ חייב גם לוח זמנים להגשת תגובות מקדמיות של המדינה.",
    question:
      "כמה זמן לפני הדיון נדרשה המדינה להגיש תגובות מקדמיות בעתירת זיני?",
    options: [
      "48 שעות לפני הדיון",
      "3 ימים לפני הדיון",
      "7 ימים לפני הדיון",
      "30 ימים לפני הדיון",
    ],
    answer: 2,
    explanation:
      "לפי ההודעה, התגובות המקדמיות נדרשו 7 ימים לפני הדיון.",
    sources: [
      {
        label: "בג\"ץ יקבע דיון בעתירה נגד מינוי דוד זיני (03.10.2025)",
        url: "https://mqg.org.il/%d7%91%d7%92%d7%a5-%d7%99%d7%a7%d7%91%d7%a2-%d7%93%d7%99%d7%95%d7%9f-%d7%91%d7%a2%d7%aa%d7%99%d7%a8%d7%aa-%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94/",
      },
    ],
  },
  {
    id: "b05",
    category: "מערכת המשפט ומינויים",
    kind: "activity",
    date: "2025-05-22",
    learn:
      "בעקבות הודעה על מינוי דוד זיני, התנועה הודיעה על צעד משפטי מיידי.",
    question: "איזה צעד הודיעה התנועה שתנקוט בעקבות מינוי דוד זיני?",
    options: [
      "הקמת ועדת בדיקה פנימית",
      "עתירה לבג\"ץ",
      "פנייה ליועצת המשפטית לממשלה ללא הליך שיפוטי",
      "פנייה לוועדת המינויים בלבד ללא עתירה",
    ],
    answer: 1,
    explanation:
      "בכותרת ההודעה נכתב במפורש שהתנועה תעתור לבג\"ץ נגד המינוי.",
    sources: [
      {
        label: "מדובר במינוי מתריס ומחוצף - נעתור לבג\"ץ (22.05.2025)",
        url: "https://mqg.org.il/%d7%93%d7%a8-%d7%90%d7%9c%d7%99%d7%a2%d7%93-%d7%a9%d7%a8%d7%92%d7%90-%d7%9e%d7%93%d7%95%d7%91%d7%a8-%d7%91%d7%9e%d7%99%d7%a0%d7%95%d7%99-%d7%9e%d7%aa%d7%a8%d7%99%d7%a1-%d7%95%d7%9e%d7%97%d7%95/",
      },
    ],
  },
  {
    id: "b06",
    category: "מערכת המשפט ומינויים",
    kind: "activity",
    date: "2025-01-06",
    learn:
      "בעתירת התנועה נגד מינוי רואי כחלון נקבע דיון דחוף כבר בתחילת ינואר.",
    question:
      "לאיזה תאריך נקבע הדיון הדחוף בבג\"ץ בעתירה נגד מינוי רואי כחלון?",
    options: ["13.01.2025", "26.01.2025", "13.02.2025", "01.03.2025"],
    answer: 0,
    explanation:
      "לפי ההודעה, הדיון הדחוף נקבע ל-13 בינואר 2025.",
    sources: [
      {
        label: "בג\"ץ יקיים דיון דחוף בעתירת התנועה (06.01.2025)",
        url: "https://mqg.org.il/%d7%91%d7%92%d7%a5-%d7%99%d7%a7%d7%99%d7%99%d7%9d-%d7%93%d7%99%d7%95%d7%9f-%d7%93%d7%97%d7%95%d7%a3-%d7%91%d7%a2%d7%aa%d7%99%d7%a8%d7%aa-%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b/",
      },
    ],
  },
  {
    id: "b07",
    category: "מערכת המשפט ומינויים",
    kind: "activity",
    date: "2025-03-18",
    learn:
      "העתירה בנושא ראש השב\"כ נדחתה אז כמוקדמת, אבל התנועה הדגישה שהסוגיה לא הסתיימה.",
    question:
      "מה הייתה הסיבה לדחיית העתירה כמוקדמת בהחלטת בג\"ץ מ-18.03.2025?",
    options: [
      "לא הייתה לתנועה זכות עמידה",
      "המדינה כבר יישמה את הסעדים",
      "הממשלה טרם קיבלה החלטה סופית",
      "בג\"ץ הפנה את הנושא לבחינה מקדמית בממשלה",
    ],
    answer: 2,
    explanation:
      "בהודעה צוין שהעתירה נדחתה כמוקדמת משום שבאותו שלב לא התקבלה החלטת ממשלה סופית.",
    sources: [
      {
        label: "תגובת התנועה להחלטת בג\"ץ (18.03.2025)",
        url: "https://mqg.org.il/%d7%aa%d7%92%d7%95%d7%91%d7%aa-%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94%d7%a9%d7%9c%d7%98%d7%95%d7%9f-%d7%9c%d7%94%d7%97%d7%9c%d7%98%d7%aa-%d7%91%d7%92/",
      },
    ],
  },
  {
    id: "b08",
    category: "תקשורת ושקיפות",
    kind: "success",
    date: "2025-12-28",
    learn:
      "התנועה הובילה עתירה בסוגיית סגירת גל\"צ, וביקשה בלימת צעד מיידי.",
    question: "מה הייתה תוצאת הביניים המרכזית בעתירה בעניין גל\"צ?",
    options: [
      "בג\"ץ הקפיא את החלטת הסגירה",
      "בג\"ץ אישר את הסגירה המיידית",
      "התיק הועבר לבית משפט מחוזי",
      "העתירה נמחקה בהסכמה",
    ],
    answer: 0,
    explanation:
      "בהודעת התנועה מ-28.12.2025 נכתב שבג\"ץ הקפיא את החלטת הממשלה על סגירת גל\"צ.",
    sources: [
      {
        label: "בג\"ץ הקפיא את סגירת גל\"צ (28.12.2025)",
        url: "https://mqg.org.il/%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94%d7%a9%d7%9c%d7%98%d7%95%d7%9f-%d7%91%d7%92%d7%a5-%d7%94%d7%a7%d7%a4%d7%99%d7%90-%d7%90%d7%aa-%d7%a1%d7%92%d7%99/",
      },
    ],
  },
  {
    id: "b09",
    category: "תקשורת ושקיפות",
    kind: "success",
    date: "2025-12-28",
    learn:
      "התנועה תיארה את ההחלטה לא רק משפטית אלא גם ציבורית-ערכית.",
    question: "לפי הודעת התנועה, הקפאת סגירת גל\"צ הוגדרה כניצחון עבור מה?",
    options: [
      "חופש הביטוי ועצמאות התקשורת",
      "חיזוק רציפות השידור המבצעי בלבד",
      "העברת ניהול התחנה למודל ממשלתי מרוכז",
      "דחיית הדיון הציבורי בסוגיית עצמאות התקשורת",
    ],
    answer: 0,
    explanation:
      "בהודעת התנועה נכתב שמדובר בניצחון חשוב לחופש הביטוי ולעצמאות התקשורת.",
    sources: [
      {
        label: "בג\"ץ הקפיא את סגירת גל\"צ (28.12.2025)",
        url: "https://mqg.org.il/%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94%d7%a9%d7%9c%d7%98%d7%95%d7%9f-%d7%91%d7%92%d7%a5-%d7%94%d7%a7%d7%a4%d7%99%d7%90-%d7%90%d7%aa-%d7%a1%d7%92%d7%99/",
      },
    ],
  },
  {
    id: "b10",
    category: "תקשורת ושקיפות",
    kind: "success",
    date: "2025-12-31",
    learn:
      "במהלך נפרד בסוף 2025 התנועה תקפה את סמכות מבקר המדינה לחקור את אירועי 7 באוקטובר.",
    question:
      "איזו החלטה פרוצדורלית קיבל בג\"ץ בעתירה נגד חקירת מבקר המדינה בנושא מחדל 7 באוקטובר?",
    options: [
      "צו על תנאי וצו ביניים שהקפיאו את עבודת המבקר בנושא",
      "דחיית העתירה על הסף",
      "הפניית הסוגיה לבחינת היועצת המשפטית לממשלה בלבד",
      "החלטה שאין סמכות שיפוטית לבג\"ץ",
    ],
    answer: 0,
    explanation:
      "לפי הודעת התנועה, בג\"ץ הוציא צו על תנאי וצו ביניים שהקפיאו את החקירה של המבקר בנושא זה.",
    sources: [
      {
        label: "צו על תנאי וצו ביניים בנושא חקירת המבקר (31.12.2025)",
        url: "https://mqg.org.il/%d7%91%d7%92%d7%a5-%d7%94%d7%95%d7%a8%d7%94-%d7%9c%d7%94%d7%95%d7%a6%d7%99%d7%90-%d7%a6%d7%95-%d7%a2%d7%9c-%d7%aa%d7%a0%d7%90%d7%99-%d7%95%d7%a6%d7%95-%d7%91%d7%99%d7%a0%d7%99%d7%99%d7%9d-%d7%94%d7%9e/",
      },
    ],
  },
  {
    id: "b11",
    category: "תקשורת ושקיפות",
    kind: "activity",
    date: "2025-12-31",
    learn:
      "בעתירה הודגש ההבדל בין עבודת ביקורת לבין חקירה ממלכתית רחבה של כשל לאומי.",
    question:
      "מה הייתה הטענה המבנית המרכזית של התנועה ביחס לבדיקת מחדל 7 באוקטובר?",
    options: [
      "רק ועדת חקירה ממלכתית מוסמכת לבדוק את הכשלים לעומק",
      "אין צורך בבדיקה מוסדית כלשהי",
      "יש להסתפק בדוח פנימי של משרד הביטחון",
      "המבקר הוא הגוף היחיד שמוסמך לכך בחוק",
    ],
    answer: 0,
    explanation:
      "לפי ההודעה, התנועה טענה שיש צורך בוועדת חקירה ממלכתית ולא בהליך חלופי.",
    sources: [
      {
        label: "צו על תנאי וצו ביניים בנושא חקירת המבקר (31.12.2025)",
        url: "https://mqg.org.il/%d7%91%d7%92%d7%a5-%d7%94%d7%95%d7%a8%d7%94-%d7%9c%d7%94%d7%95%d7%a6%d7%99%d7%90-%d7%a6%d7%95-%d7%a2%d7%9c-%d7%aa%d7%a0%d7%90%d7%99-%d7%95%d7%a6%d7%95-%d7%91%d7%99%d7%a0%d7%99%d7%99%d7%9d-%d7%94%d7%9e/",
      },
    ],
  },
  {
    id: "b12",
    category: "שוויון בנטל",
    kind: "activity",
    date: "2026-01-04",
    learn:
      "בתגובה לפסיקת בג\"ץ בנושא הגיוס, התנועה הדגישה דרישות יישום מיידיות במספרים ברורים.",
    question: "איזה יעד גיוס הודגש בהודעת התנועה מ-04.01.2026?",
    options: [
      "יעד גיוס של 3,000 מתגייסים",
      "יעד גיוס של 6,000 מתגייסים",
      "יעד גיוס של 12,000 מתגייסים",
      "יעד גיוס של 24,000 מתגייסים",
    ],
    answer: 2,
    explanation:
      "לפי ההודעה, התנועה דרשה לגייס 12,000 לוחמים ולגנוז את מה שכונה חוק ההשתמטות.",
    sources: [
      {
        label: "תגובת התנועה לפסיקת בג\"ץ בנושא הגיוס (04.01.2026)",
        url: "https://mqg.org.il/%d7%aa%d7%92%d7%95%d7%91%d7%aa-%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94%d7%a9%d7%9c%d7%98%d7%95%d7%9f-%d7%9c%d7%a4%d7%a1%d7%99%d7%a7%d7%aa-%d7%91%d7%92/",
      },
    ],
  },
  {
    id: "b13",
    category: "שוויון בנטל",
    kind: "activity",
    date: "2026-01-04",
    learn:
      "בנוסף ליעדי הגיוס, ההודעה כללה דרישה לאכיפה מעשית.",
    question:
      "איזו אכיפה דרשה התנועה בהמשך להודעתה על יישום פסיקת בג\"ץ בגיוס?",
    options: [
      "אכיפה פלילית וכלכלית",
      "אכיפה הסברתית בלבד",
      "אכיפה פנימית בצה\"ל בלבד",
      "ללא אכיפה, רק המלצות",
    ],
    answer: 0,
    explanation:
      "בהודעה נדרשה אכיפה פלילית וכלכלית כחלק מיישום שוויון בנטל.",
    sources: [
      {
        label: "תגובת התנועה לפסיקת בג\"ץ בנושא הגיוס (04.01.2026)",
        url: "https://mqg.org.il/%d7%aa%d7%92%d7%95%d7%91%d7%aa-%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94%d7%a9%d7%9c%d7%98%d7%95%d7%9f-%d7%9c%d7%a4%d7%a1%d7%99%d7%a7%d7%aa-%d7%91%d7%92/",
      },
    ],
  },
  {
    id: "b14",
    category: "מערכת המשפט ומינויים",
    kind: "success",
    date: "2026-01-15",
    learn:
      "סדרת פניות של התנועה הביאה להכרעת ועדת המינויים בעניינו של תמיר פרץ.",
    question: "כמה פניות של התנועה הוזכרו כבסיס לפסילת מינוי תמיר פרץ?",
    options: ["פנייה אחת", "שתי פניות", "שלוש פניות", "חמש פניות"],
    answer: 2,
    explanation:
      "בהודעת התנועה נכתב שהפסילה באה בעקבות שלוש פניות שהוגשו על ידה.",
    sources: [
      {
        label: "ועדת דותן פסלה את מינוי תמיר פרץ (15.01.2026)",
        url: "https://mqg.org.il/%d7%95%d7%a2%d7%93%d7%aa-%d7%93%d7%95%d7%aa%d7%9f-%d7%a4%d7%a1%d7%9c%d7%94-%d7%90%d7%aa-%d7%9e%d7%99%d7%a0%d7%95%d7%99%d7%95-%d7%a9%d7%9c-%d7%aa%d7%9e%d7%99%d7%a8-%d7%a4%d7%a8%d7%a5-%d7%9c%d7%9e%d7%a9/",
      },
    ],
  },
  {
    id: "b15",
    category: "מערכת המשפט ומינויים",
    kind: "activity",
    date: "2026-01-18",
    learn:
      "בתחילת 2026 התנועה דרשה לבטל מינוי בכיר בשב\"כ בעקבות טענות להליך לא תקין.",
    question: "מה הייתה דרישת התנועה בעניין מינוי נ' לסגן ראש השב\"כ?",
    options: [
      "לאשר את המינוי בכפוף לשימוע",
      "לבטל את המינוי עקב פגמים וניגוד עניינים",
      "להעביר את המינוי לאישור הכנסת",
      "לדחות את הבדיקה בשנה",
    ],
    answer: 1,
    explanation:
      "בהודעה התנועה קראה לבטל את המינוי בשל אי תקינות ההליך וחשש לניגוד עניינים.",
    sources: [
      {
        label: "דרישה לבטל את מינוי נ' לסגן ראש השב\"כ (18.01.2026)",
        url: "https://mqg.org.il/%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94%d7%a9%d7%9c%d7%98%d7%95%d7%9f-%d7%93%d7%95%d7%a8%d7%a9%d7%aa-%d7%9c%d7%91%d7%98%d7%9c-%d7%90%d7%aa-%d7%9e%d7%99/",
      },
    ],
  },
  {
    id: "b16",
    category: "מערכת המשפט ומינויים",
    kind: "activity",
    date: "2026-01-25",
    learn:
      "בתגובה לחוות דעת היועמ\"שית, התנועה טענה לניסיון לשנות את כללי עבודת הממשלה.",
    question:
      "מה הייתה טענת התנועה לגבי שינוי תקנון עבודת הממשלה, לפי ההודעה מ-25.01.2026?",
    options: [
      "להרחיב פיקוח משפטי על החלטות",
      "לאפשר קבלת החלטות ללא בחינה משפטית מספקת",
      "להעביר סמכויות ליועצים חיצוניים",
      "להגדיל את סמכויות הכנסת על הממשלה",
    ],
    answer: 1,
    explanation:
      "בהודעה נטען שהמהלך נועד לאפשר החלטות ללא בחינה משפטית מספקת ולצמצם בלמים מקצועיים.",
    sources: [
      {
        label: "תגובה לחוות דעת היועמ\"שית (25.01.2026)",
        url: "https://mqg.org.il/%d7%aa%d7%92%d7%95%d7%91%d7%aa-%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94%d7%a9%d7%9c%d7%98%d7%95%d7%9f-%d7%9c%d7%97%d7%95%d7%95%d7%aa-%d7%93%d7%a2%d7%aa/",
      },
    ],
  },
  {
    id: "b17",
    category: "חברות ממשלתיות",
    kind: "activity",
    date: "2026-02-05",
    learn:
      "בפנייה לרה\"מ ולשר האחראי, התנועה התנגדה למינויי מקורבים ברשות החברות הממשלתיות.",
    question:
      "למי הופנתה הפנייה המרכזית נגד מינויי מקורבים ברשות החברות הממשלתיות?",
    options: [
      "ליועצת המשפטית לממשלה ולמבקר המדינה",
      "לראש הממשלה ולשר דודי אמסלם",
      "ליו\"ר רשות החברות ולשר המשפטים",
      "לוועדת המינויים בשירות המדינה",
    ],
    answer: 1,
    explanation:
      "לפי ההודעה מ-05.02.2026, הפנייה הופנתה לרה\"מ ולשר דודי אמסלם.",
    sources: [
      {
        label: "פנייה לרה\"מ ולשר אמסלם (05.02.2026)",
        url: "https://mqg.org.il/%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94%d7%a9%d7%9c%d7%98%d7%95%d7%9f-%d7%91%d7%a4%d7%a0%d7%99%d7%99%d7%94-%d7%9c%d7%a8%d7%94%d7%9e-%d7%95%d7%9c%d7%a9/",
      },
    ],
  },
  {
    id: "b18",
    category: "מערכת המשפט ומינויים",
    kind: "activity",
    date: "2025-06-12",
    learn:
      "בתגובה להודעת לשכת רה\"מ על מינוי ראש השב\"כ, התנועה הפנתה לפסיקת בג\"ץ קודמת.",
    question:
      "מה נטען בהודעת התנועה לגבי מעורבות רה\"מ במינוי ראש השב\"כ?",
    options: [
      "הנושא נתון לשיקול דעתו של רה\"מ בכפוף לאישור ממשלה",
      "בג\"ץ כבר קבע שיש ניגוד עניינים ולכן אסור לו לעסוק בכך",
      "הנושא חייב לעבור הכרעה מוקדמת של ועדת חוץ וביטחון",
      "התנועה דרשה להמתין לבחינה משפטית משלימה לפני הכרעה",
    ],
    answer: 1,
    explanation:
      "בהודעה נאמר שבג\"ץ כבר פסק לראש הממשלה ניגוד עניינים ולכן הוא מנוע מעיסוק בנושא.",
    sources: [
      {
        label: "תגובה להודעת לשכת רה\"מ בנושא מינוי ראש השב\"כ (12.06.2025)",
        url: "https://mqg.org.il/%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94%d7%a9%d7%9c%d7%98%d7%95%d7%9f-%d7%91%d7%aa%d7%92%d7%95%d7%91%d7%94-%d7%9c%d7%94%d7%95%d7%93%d7%a2%d7%aa-%d7%9c%d7%a9/",
      },
    ],
  },
  {
    id: "b19",
    category: "פעילות ציבורית",
    kind: "activity",
    date: "2025-06-18",
    learn:
      "התנועה התריעה על פגיעה בזכות יסוד בעקבות תוכנית להגבלת טיסות יציאה מישראל.",
    question:
      "איזו זכות חוקתית צוין שעלולה להיפגע בתוכנית להגבלת טיסות יציאה מהארץ?",
    options: [
      "הזכות לבחור ולהיבחר",
      "הזכות לחופש העיסוק",
      "הזכות לצאת מישראל",
      "הזכות להתאגד",
    ],
    answer: 2,
    explanation:
      "בהודעת התנועה צוין שהתוכנית עלולה להפר את הזכות לצאת מישראל המעוגנת בסעיף 6 לחוק יסוד: כבוד האדם וחירותו.",
    sources: [
      {
        label: "התראה בנושא תוכנית הגבלת טיסות יציאה (18.06.2025)",
        url: "https://mqg.org.il/%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94%d7%a9%d7%9c%d7%98%d7%95%d7%9f-%d7%9e%d7%aa%d7%a8%d7%99%d7%a2%d7%94-%d7%94%d7%aa%d7%95%d7%9b%d7%a0%d7%99%d7%aa-%d7%9c/",
      },
    ],
  },
  {
    id: "b20",
    category: "שוויון בנטל",
    kind: "activity",
    date: "2025-03-15",
    learn:
      "בתגובה לדברי שר הביטחון, התנועה טענה שהמדינה לא מיישמת אכיפה אפקטיבית לאורך זמן.",
    question:
      "מה הייתה הביקורת המרכזית של התנועה בעניין השוויון בנטל בתגובה מ-15.03.2025?",
    options: [
      "קיימת אכיפה מלאה וסנקציות אפקטיביות",
      "לא התקיימה אכיפה רצינית לאורך השנים והסנקציות לא יושמו",
      "האכיפה החלה רק לאחרונה ולכן מוקדם להסיק מסקנות",
      "יש להעדיף תמריצים בלבד ללא סנקציות מחייבות",
    ],
    answer: 1,
    explanation:
      "לפי הודעת התנועה, לאורך שנים לא התקיימה אכיפה רצינית של חובות הגיוס והסנקציות לא הופעלו בפועל.",
    sources: [
      {
        label: "תגובה לדברי שר הביטחון בנושא שוויון בנטל (15.03.2025)",
        url: "https://mqg.org.il/%d7%94%d7%aa%d7%a0%d7%95%d7%a2%d7%94-%d7%9c%d7%90%d7%99%d7%9b%d7%95%d7%aa-%d7%94%d7%a9%d7%9c%d7%98%d7%95%d7%9f-%d7%91%d7%aa%d7%92%d7%95%d7%91%d7%94-%d7%9c%d7%93%d7%91%d7%a8%d7%99-%d7%a9%d7%a8-3/",
      },
    ],
  },
];

const TELEMARKETING_ACTIVITY_TOPICS = TELEMARKETING_ACTIVITY_TOPIC_CONFIGS.map((item) => ({
  id: item.id,
  title: item.title,
  shortTitle: item.shortTitle,
}));
const TELEMARKETING_ACTIVITY_TOPIC_BY_ID = TELEMARKETING_ACTIVITY_TOPICS.reduce((acc, item) => {
  acc[item.id] = item;
  return acc;
}, {});
const TELEMARKETING_ACTIVITY_QUESTIONS_BY_TOPIC = buildTelemarketingActivityQuestionPools();
const EDUCATION_DEPARTMENT_QUESTIONS = buildGeneratedTopicQuestions(EDUCATION_DEPARTMENT_TOPIC_CONFIG, 30);

const BASE_QUESTION_CONTENT_AUDIT = auditQuestionBankContent(BASE_QUESTIONS);
if (BASE_QUESTION_CONTENT_AUDIT.totalIssues > 0) {
  console.warn(
    `[MQG Quiz] נמצאו ${BASE_QUESTION_CONTENT_AUDIT.totalIssues} הערות איכות בבנק השאלות הבסיסי. מומלץ לבדוק במסך הניהול.`,
  );
}

const EXPANDED_BASE_QUESTIONS = buildExpandedQuestionBank(BASE_QUESTIONS);

const screenIds = [
  "screenLanding",
  "screenQuickSetup",
  "screenAdminLogin",
  "screenQuiz",
  "screenResult",
  "screenAdminPanel",
];

const gameState = {
  quickMode: QUICK_MODES.REGULAR,
  entryDepartment: "",
  activityTopic: TELEMARKETING_ACTIVITY_TOPICS[0]?.id || "oct7",
  playerName: "",
  questions: [],
  index: 0,
  score: 0,
  correctCount: 0,
  answerTimes: [],
  timeoutCount: 0,
  categoryStats: {},
  questionStats: {},
  startAt: 0,
  questionStartedAt: 0,
  questionRenderedAt: 0,
  timerIntervalId: null,
  remainingSeconds: QUESTION_TIMEOUT_SECONDS,
  showLearning: true,
  locked: false,
  feedbackDeepOpen: false,
  wrong: [],
  musicStarted: false,
  adaptiveMode: false,
  adaptiveConfidence: 0,
  adaptiveSignals: 0,
};

const adminState = {
  mode: "main",
  tab: "dashboard",
  currentAdmin: null,
  systemCheckInFlight: false,
  lastSystemCheck: null,
  draftSelectionIds: [],
  lastVisibleDraftIds: [],
  longTextAnalysis: null,
  lastLongTextBatchDraftIds: [],
  questionAuditReport: null,
  questionEditTargetId: "",
  syncTimerId: null,
  syncInFlight: false,
  isHydratingRemote: false,
};

const appUpdateState = {
  waitingWorker: null,
  isApplying: false,
  reloadTimerId: null,
};

const dom = {
  appUpdateBanner: document.getElementById("appUpdateBanner"),
  appUpdateReloadBtn: document.getElementById("appUpdateReloadBtn"),
  appUpdateDismissBtn: document.getElementById("appUpdateDismissBtn"),
  screenQuiz: document.getElementById("screenQuiz"),
  bgMusic: document.getElementById("bgMusic"),
  musicControls: document.getElementById("musicControls"),
  musicDownBtn: document.getElementById("musicDownBtn"),
  musicUpBtn: document.getElementById("musicUpBtn"),
  musicMuteBtn: document.getElementById("musicMuteBtn"),
  musicLevelText: document.getElementById("musicLevelText"),
  newGameAnytimeBtn: document.getElementById("newGameAnytimeBtn"),
  homeAnytimeBtn: document.getElementById("homeAnytimeBtn"),
  chooseTelemarketingBtn: document.getElementById("chooseTelemarketingBtn"),
  chooseEducationBtn: document.getElementById("chooseEducationBtn"),
  entryTelemarketingCard: document.getElementById("entryTelemarketingCard"),
  entryEducationCard: document.getElementById("entryEducationCard"),
  entryModesWrap: document.getElementById("entryModesWrap"),
  entrySeasonalCard: document.getElementById("entrySeasonalCard"),
  entryActivityCard: document.getElementById("entryActivityCard"),
  entryDepartmentState: document.getElementById("entryDepartmentState"),
  entryDepartmentMsg: document.getElementById("entryDepartmentMsg"),
  goQuickBtn: document.getElementById("goQuickBtn"),
  goSeasonalQuickBtn: document.getElementById("goSeasonalQuickBtn"),
  goActivityQuickBtn: document.getElementById("goActivityQuickBtn"),
  goAdminBtn: document.getElementById("goAdminBtn"),
  quickSetupTitle: document.getElementById("quickSetupTitle"),
  quickModeNote: document.getElementById("quickModeNote"),
  playerNameInput: document.getElementById("playerNameInput"),
  questionCountSelect: document.getElementById("questionCountSelect"),
  activityTopicField: document.getElementById("activityTopicField"),
  activityTopicSelect: document.getElementById("activityTopicSelect"),
  showLearningToggle: document.getElementById("showLearningToggle"),
  startQuickBtn: document.getElementById("startQuickBtn"),
  quickSetupError: document.getElementById("quickSetupError"),
  adminUsernameInput: document.getElementById("adminUsernameInput"),
  adminPasswordInput: document.getElementById("adminPasswordInput"),
  loginAdminBtn: document.getElementById("loginAdminBtn"),
  adminLoginError: document.getElementById("adminLoginError"),
  adminLogoutBtn: document.getElementById("adminLogoutBtn"),
  adminSessionInfo: document.getElementById("adminSessionInfo"),
  adminUserForm: document.getElementById("adminUserForm"),
  adminUserNewUsername: document.getElementById("adminUserNewUsername"),
  adminUserNewPassword: document.getElementById("adminUserNewPassword"),
  createAdminUserBtn: document.getElementById("createAdminUserBtn"),
  adminUserFormMsg: document.getElementById("adminUserFormMsg"),
  adminPasswordForm: document.getElementById("adminPasswordForm"),
  adminCurrentPassword: document.getElementById("adminCurrentPassword"),
  adminNewPassword: document.getElementById("adminNewPassword"),
  adminConfirmPassword: document.getElementById("adminConfirmPassword"),
  changeOwnPasswordBtn: document.getElementById("changeOwnPasswordBtn"),
  adminPasswordFormMsg: document.getElementById("adminPasswordFormMsg"),
  adminUsersList: document.getElementById("adminUsersList"),
  quizPlayerName: document.getElementById("quizPlayerName"),
  quizProgress: document.getElementById("quizProgress"),
  quizScore: document.getElementById("quizScore"),
  timerWrap: document.getElementById("timerWrap"),
  hourglassIcon: document.getElementById("hourglassIcon"),
  timerText: document.getElementById("timerText"),
  quizProgressFill: document.getElementById("quizProgressFill"),
  questionBanner: document.getElementById("questionBanner"),
  questionLearn: document.getElementById("questionLearn"),
  questionTitle: document.getElementById("questionTitle"),
  optionsWrap: document.getElementById("optionsWrap"),
  feedbackCard: document.getElementById("feedbackCard"),
  feedbackHeadline: document.getElementById("feedbackHeadline"),
  feedbackText: document.getElementById("feedbackText"),
  feedbackWrongReasons: document.getElementById("feedbackWrongReasons"),
  feedbackDeepExplainBtn: document.getElementById("feedbackDeepExplainBtn"),
  feedbackDeepReasons: document.getElementById("feedbackDeepReasons"),
  feedbackSources: document.getElementById("feedbackSources"),
  nextQuestionBtn: document.getElementById("nextQuestionBtn"),
  resultMain: document.getElementById("resultMain"),
  resultSub: document.getElementById("resultSub"),
  wrongAnswersWrap: document.getElementById("wrongAnswersWrap"),
  playAgainBtn: document.getElementById("playAgainBtn"),
  adminSystemCheckBtn: document.getElementById("adminSystemCheckBtn"),
  adminSystemCheckStatus: document.getElementById("adminSystemCheckStatus"),
  adminSystemCheckRows: document.getElementById("adminSystemCheckRows"),
  adminStats: document.getElementById("adminStats"),
  attemptsTableBody: document.getElementById("attemptsTableBody"),
  learningMetricsList: document.getElementById("learningMetricsList"),
  exportAttemptsCsvBtn: document.getElementById("exportAttemptsCsvBtn"),
  exportHardestCsvBtn: document.getElementById("exportHardestCsvBtn"),
  clearAttemptsBtn: document.getElementById("clearAttemptsBtn"),
  resetQuestionCyclesPublicBtn: document.getElementById("resetQuestionCyclesPublicBtn"),
  questionCycleResetMsg: document.getElementById("questionCycleResetMsg"),
  openQuestionBankBtn: document.getElementById("openQuestionBankBtn"),
  openAdminManagersBtn: document.getElementById("openAdminManagersBtn"),
  backToAdminMainBtn: document.getElementById("backToAdminMainBtn"),
  adminMainSections: document.getElementById("adminMainSections"),
  adminQuestionBankSection: document.getElementById("adminQuestionBankSection"),
  activityForm: document.getElementById("activityForm"),
  adminFilesInput: document.getElementById("adminFilesInput"),
  activityFormMsg: document.getElementById("activityFormMsg"),
  activitiesList: document.getElementById("activitiesList"),
  draftQueueSummary: document.getElementById("draftQueueSummary"),
  draftQueueStatusFilter: document.getElementById("draftQueueStatusFilter"),
  draftQueueSearchInput: document.getElementById("draftQueueSearchInput"),
  selectVisibleDraftsBtn: document.getElementById("selectVisibleDraftsBtn"),
  clearDraftSelectionBtn: document.getElementById("clearDraftSelectionBtn"),
  moveDraftsToReviewBtn: document.getElementById("moveDraftsToReviewBtn"),
  moveDraftsToDraftBtn: document.getElementById("moveDraftsToDraftBtn"),
  approveSelectedDraftsBtn: document.getElementById("approveSelectedDraftsBtn"),
  rejectSelectedDraftsBtn: document.getElementById("rejectSelectedDraftsBtn"),
  undoDraftActionBtn: document.getElementById("undoDraftActionBtn"),
  draftQueueMsg: document.getElementById("draftQueueMsg"),
  draftsList: document.getElementById("draftsList"),
  customQuestionsList: document.getElementById("customQuestionsList"),
  longTextInput: document.getElementById("longTextInput"),
  longTextFileInput: document.getElementById("longTextFileInput"),
  longTextQuestionCount: document.getElementById("longTextQuestionCount"),
  longTextCategory: document.getElementById("longTextCategory"),
  longTextKind: document.getElementById("longTextKind"),
  longTextDate: document.getElementById("longTextDate"),
  longTextSourceLabel: document.getElementById("longTextSourceLabel"),
  longTextSourceUrl: document.getElementById("longTextSourceUrl"),
  analyzeLongTextBtn: document.getElementById("analyzeLongTextBtn"),
  generateLongTextDraftsBtn: document.getElementById("generateLongTextDraftsBtn"),
  approveAllTextDraftsBtn: document.getElementById("approveAllTextDraftsBtn"),
  longTextMsg: document.getElementById("longTextMsg"),
  longTextTopicTitle: document.getElementById("longTextTopicTitle"),
  longTextDraftsPreview: document.getElementById("longTextDraftsPreview"),
  questionCountExact: document.getElementById("questionCountExact"),
  questionSearchInput: document.getElementById("questionSearchInput"),
  questionCategoryFilter: document.getElementById("questionCategoryFilter"),
  questionKindFilter: document.getElementById("questionKindFilter"),
  questionVisibilityFilter: document.getElementById("questionVisibilityFilter"),
  questionSourceFilter: document.getElementById("questionSourceFilter"),
  questionDateFrom: document.getElementById("questionDateFrom"),
  questionDateTo: document.getElementById("questionDateTo"),
  questionSortMode: document.getElementById("questionSortMode"),
  resetQuestionFiltersBtn: document.getElementById("resetQuestionFiltersBtn"),
  runQuestionAuditBtn: document.getElementById("runQuestionAuditBtn"),
  clearQuestionAuditBtn: document.getElementById("clearQuestionAuditBtn"),
  questionAuditStatus: document.getElementById("questionAuditStatus"),
  questionAuditResults: document.getElementById("questionAuditResults"),
  allQuestionsList: document.getElementById("allQuestionsList"),
  learningInsightsSummary: document.getElementById("learningInsightsSummary"),
  learningAlertsList: document.getElementById("learningAlertsList"),
  questionDifficultyList: document.getElementById("questionDifficultyList"),
  learningRecommendationsList: document.getElementById("learningRecommendationsList"),
  learningAlertMinAttempts: document.getElementById("learningAlertMinAttempts"),
  learningAlertCategoryWarn: document.getElementById("learningAlertCategoryWarn"),
  learningAlertCategoryHigh: document.getElementById("learningAlertCategoryHigh"),
  learningAlertCategoryTimeoutWarn: document.getElementById("learningAlertCategoryTimeoutWarn"),
  learningAlertQuestionFailWarn: document.getElementById("learningAlertQuestionFailWarn"),
  learningAlertQuestionFailHigh: document.getElementById("learningAlertQuestionFailHigh"),
  learningAlertQuestionTimeoutWarn: document.getElementById("learningAlertQuestionTimeoutWarn"),
  saveLearningAlertSettingsBtn: document.getElementById("saveLearningAlertSettingsBtn"),
  resetLearningAlertSettingsBtn: document.getElementById("resetLearningAlertSettingsBtn"),
  learningAlertSettingsMsg: document.getElementById("learningAlertSettingsMsg"),
  questionEditModal: document.getElementById("questionEditModal"),
  questionEditForm: document.getElementById("questionEditForm"),
  questionEditQuestionInput: document.getElementById("questionEditQuestionInput"),
  questionEditLearnInput: document.getElementById("questionEditLearnInput"),
  questionEditExplanationInput: document.getElementById("questionEditExplanationInput"),
  questionEditOptionsWrap: document.getElementById("questionEditOptionsWrap"),
  questionEditAnswerSelect: document.getElementById("questionEditAnswerSelect"),
  questionEditSaveBtn: document.getElementById("questionEditSaveBtn"),
  questionEditCancelBtn: document.getElementById("questionEditCancelBtn"),
  questionEditCloseBtn: document.getElementById("questionEditCloseBtn"),
  questionEditMsg: document.getElementById("questionEditMsg"),
  adminTabButtons: Array.from(document.querySelectorAll("[data-admin-tab-target]")),
  adminTabPanels: Array.from(document.querySelectorAll("[data-admin-tab-panel]")),
};

const backendConfig = resolveBackendConfig();

ensureAdminUsersSeeded();
bindEvents();
setDefaultDateFields();
setQuickMode(QUICK_MODES.REGULAR);
setEntryDepartment("");
showScreen("screenLanding");
updateTimerUI(QUESTION_TIMEOUT_SECONDS);
dom.hourglassIcon.style.animationPlayState = "paused";
initMusic();

function bindEvents() {
  dom.musicDownBtn.addEventListener("click", () => {
    updateMusicVolume((dom.bgMusic.volume || MUSIC_DEFAULT_VOLUME) - 0.06);
    ensureMusicPlayback();
  });
  dom.musicUpBtn.addEventListener("click", () => {
    updateMusicVolume((dom.bgMusic.volume || MUSIC_DEFAULT_VOLUME) + 0.06);
    ensureMusicPlayback();
  });
  dom.musicMuteBtn.addEventListener("click", () => {
    dom.bgMusic.muted = !dom.bgMusic.muted;
    saveMusicSettings();
    renderMusicUi();
    ensureMusicPlayback();
  });

  dom.newGameAnytimeBtn.addEventListener("click", () => {
    resetAndGoToNewGame();
    ensureMusicPlayback();
  });

  dom.homeAnytimeBtn.addEventListener("click", () => {
    stopQuestionTimer();
    showScreen("screenLanding");
    ensureMusicPlayback();
  });

  dom.chooseTelemarketingBtn?.addEventListener("click", () => {
    setEntryDepartment(ENTRY_DEPARTMENTS.TELEMARKETING);
    ensureMusicPlayback();
  });

  dom.chooseEducationBtn?.addEventListener("click", () => {
    setEntryDepartment(ENTRY_DEPARTMENTS.EDUCATION);
    ensureMusicPlayback();
  });

  dom.goQuickBtn?.addEventListener("click", () => {
    openQuickSetupByMode(QUICK_MODES.REGULAR);
    ensureMusicPlayback();
  });

  dom.goSeasonalQuickBtn?.addEventListener("click", () => {
    openQuickSetupByMode(QUICK_MODES.SEASONAL);
    ensureMusicPlayback();
  });

  dom.goActivityQuickBtn?.addEventListener("click", () => {
    openQuickSetupByMode(QUICK_MODES.ACTIVITY);
    ensureMusicPlayback();
  });

  dom.activityTopicSelect?.addEventListener("change", () => {
    gameState.activityTopic = normalizeActivityTopicId(dom.activityTopicSelect.value);
    if (normalizeQuickMode(gameState.quickMode) === QUICK_MODES.ACTIVITY) {
      setQuickMode(QUICK_MODES.ACTIVITY);
    }
  });

  dom.goAdminBtn.addEventListener("click", () => {
    dom.adminUsernameInput.value = "";
    dom.adminPasswordInput.value = "";
    hideMessage(dom.adminLoginError);
    showScreen("screenAdminLogin");
    ensureMusicPlayback();
  });

  document.querySelectorAll("[data-go]").forEach((button) => {
    button.addEventListener("click", () => {
      const target = button.dataset.go || "landing";
      showScreen(resolveScreenId(target));
    });
  });

  dom.startQuickBtn.addEventListener("click", startQuickGame);

  dom.loginAdminBtn.addEventListener("click", async () => {
    const username = normalizeSpace(dom.adminUsernameInput.value);
    const password = dom.adminPasswordInput.value.trim();
    const loginBlock = checkAntiSpamBlock("adminLogin");
    if (loginBlock.blocked) {
      showMessage(
        dom.adminLoginError,
        `יותר מדי ניסיונות התחברות. נסה שוב בעוד ${formatCooldownMs(loginBlock.remainingMs)}.`,
        false,
      );
      return;
    }

    try {
      if (isBackendEnabled()) {
        const payload = await loginWithBackend(username, password);
        const remoteUsername = normalizeSpace(payload?.admin?.username);
        if (!remoteUsername) {
          throw new Error("LOGIN_FAILED");
        }
        adminState.currentAdmin = {
          id: normalizeSpace(payload?.admin?.id) || uid("admin"),
          username: remoteUsername,
          role: normalizeAdminRole(payload?.admin?.role),
          isOwner: normalizeAdminRole(payload?.admin?.role) === "owner",
          createdAt: normalizeSpace(payload?.admin?.createdAt) || new Date().toISOString(),
          createdBy: normalizeSpace(payload?.admin?.createdBy) || "remote",
        };
        hideMessage(dom.adminLoginError);
        clearAntiSpamEvents("adminLogin");
        await hydrateFromBackendState();
        openAdminPanel();
        startRemoteSyncLoop();
        ensureMusicPlayback();
        return;
      }

      if (!backendConfig.allowInsecureLocalFallback) {
        showMessage(
          dom.adminLoginError,
          "ניהול מנהלים מאובטח דורש backend פעיל. הפעל backend ועדכן config.js.",
          false,
        );
        return;
      }

      const adminUser = authenticateAdminUser(username, password);
      if (!adminUser) {
        const antiSpamAttempt = recordAntiSpamEvent("adminLogin", `fail:${username}`);
        if (antiSpamAttempt.blocked) {
          showMessage(
            dom.adminLoginError,
            `יותר מדי ניסיונות התחברות. נסה שוב בעוד ${formatCooldownMs(antiSpamAttempt.remainingMs)}.`,
            false,
          );
          return;
        }
        showMessage(dom.adminLoginError, "שם משתמש או סיסמה שגויים. נסה שוב.", false);
        return;
      }
      hideMessage(dom.adminLoginError);
      clearAntiSpamEvents("adminLogin");
      adminState.currentAdmin = adminUser;
      openAdminPanel();
      ensureMusicPlayback();
    } catch (_err) {
      const antiSpamAttempt = recordAntiSpamEvent("adminLogin", `fail:${username}`);
      if (antiSpamAttempt.blocked) {
        showMessage(
          dom.adminLoginError,
          `יותר מדי ניסיונות התחברות. נסה שוב בעוד ${formatCooldownMs(antiSpamAttempt.remainingMs)}.`,
          false,
        );
        return;
      }
      const backendErrorCode = normalizeSpace(_err?.message).toUpperCase();
      const backendLoginErrorMessages = {
        INVALID_CREDENTIALS: "שם משתמש או סיסמה שגויים.",
        LOGIN_LOCKED: "יותר מדי ניסיונות התחברות. נסה שוב בעוד כמה דקות.",
        RATE_LIMITED: "יותר מדי בקשות בזמן קצר. נסה שוב בעוד דקה.",
        CORS_BLOCKED: "הדומיין הנוכחי לא מורשה מול ה-backend. עדכן CORS_ORIGIN ב-Render.",
        BACKEND_NOT_CONFIGURED: "ה-Backend לא מוגדר נכון. בדוק את baseUrl בקובץ config.js.",
      };
      const loginErrorMessage = backendLoginErrorMessages[backendErrorCode]
        || "התחברות למערכת הענן נכשלה. בדוק חיבור או פרטי התחברות.";
      showMessage(
        dom.adminLoginError,
        isBackendEnabled()
          ? loginErrorMessage
          : "שם משתמש או סיסמה שגויים. נסה שוב.",
        false,
      );
    }
  });

  dom.adminLogoutBtn.addEventListener("click", async () => {
    stopRemoteSyncLoop();
    if (isBackendEnabled()) {
      await logoutFromBackend();
    }
    adminState.currentAdmin = null;
    adminState.lastSystemCheck = null;
    adminState.systemCheckInFlight = false;
    adminState.draftSelectionIds = [];
    adminState.lastVisibleDraftIds = [];
    adminState.longTextAnalysis = null;
    adminState.lastLongTextBatchDraftIds = [];
    adminState.questionAuditReport = null;
    dom.adminUsernameInput.value = "";
    dom.adminPasswordInput.value = "";
    dom.adminUserForm.reset();
    dom.adminPasswordForm.reset();
    dom.longTextInput.value = "";
    dom.longTextSourceLabel.value = "";
    dom.longTextSourceUrl.value = "";
    hideMessage(dom.adminUserFormMsg);
    hideMessage(dom.adminPasswordFormMsg);
    hideMessage(dom.longTextMsg);
    clearLongTextTopicTitle();
    hideDraftQueueMessage();
    setAdminMode("main");
    stopQuestionTimer();
    showScreen("screenLanding");
    ensureMusicPlayback();
  });

  if (dom.openQuestionBankBtn) {
    dom.openQuestionBankBtn.addEventListener("click", () => {
      setAdminMode("questionBank");
      renderAllQuestionsManager();
    });
  }

  if (dom.openAdminManagersBtn) {
    dom.openAdminManagersBtn.addEventListener("click", () => {
      setAdminTab("security");
    });
  }

  if (dom.backToAdminMainBtn) {
    dom.backToAdminMainBtn.addEventListener("click", () => {
      setAdminMode("main");
    });
  }

  dom.adminTabButtons.forEach((button) => {
    button.addEventListener("click", () => {
      const tab = normalizeSpace(button.dataset.adminTabTarget);
      setAdminTab(tab);
    });
  });

  document.querySelectorAll("[data-admin-jump-tab]").forEach((button) => {
    button.addEventListener("click", () => {
      const tab = normalizeSpace(button.dataset.adminJumpTab);
      setAdminTab(tab);
    });
  });

  if (dom.adminSystemCheckBtn) {
    dom.adminSystemCheckBtn.addEventListener("click", () => {
      runAdminSystemCheck({ isManual: true }).catch(() => {});
    });
  }

  dom.resetQuestionCyclesPublicBtn.addEventListener("click", resetQuestionCyclesFlow);

  dom.nextQuestionBtn.addEventListener("click", () => {
    if (!gameState.locked) {
      return;
    }

    gameState.index += 1;
    gameState.locked = false;

    if (gameState.index >= gameState.questions.length) {
      finishGame();
      return;
    }

    renderQuestion();
  });

  dom.feedbackDeepExplainBtn.addEventListener("click", () => {
    gameState.feedbackDeepOpen = !gameState.feedbackDeepOpen;
    dom.feedbackDeepReasons.classList.toggle("hidden", !gameState.feedbackDeepOpen);
    dom.feedbackDeepExplainBtn.textContent = gameState.feedbackDeepOpen
      ? "סגור הסבר מעמיק"
      : "הסבר יותר לעומק";
  });

  dom.playAgainBtn.addEventListener("click", () => {
    dom.playerNameInput.value = gameState.playerName;
    hideMessage(dom.questionCycleResetMsg);
    stopQuestionTimer();
    showScreen("screenQuickSetup");
    ensureMusicPlayback();
  });

  dom.clearAttemptsBtn.addEventListener("click", () => {
    const shouldClear = window.confirm("למחוק את כל נתוני הניסיונות של השחקנים?");
    if (!shouldClear) {
      return;
    }

    const saved = writeStorage(STORAGE_KEYS.attempts, []);
    if (!saved) {
      showMessage(
        dom.activityFormMsg,
        "ניקוי הנתונים נכשל בגלל מגבלת אחסון בדפדפן.",
        false,
      );
      return;
    }

    renderAdminStats();
    renderAttemptsTable();
    renderLearningMetrics();
  });

  dom.exportAttemptsCsvBtn?.addEventListener("click", exportAttemptsCsv);
  dom.exportHardestCsvBtn?.addEventListener("click", exportHardestQuestionsCsv);
  dom.saveLearningAlertSettingsBtn?.addEventListener("click", saveLearningAlertSettingsFromForm);
  dom.resetLearningAlertSettingsBtn?.addEventListener("click", resetLearningAlertSettingsToDefault);

  dom.activityForm.addEventListener("submit", handleActivitySubmit);
  dom.adminUserForm.addEventListener("submit", handleAdminUserCreate);
  dom.adminPasswordForm.addEventListener("submit", handleOwnPasswordChange);
  dom.longTextFileInput.addEventListener("change", handleLongTextFileUpload);
  dom.longTextInput.addEventListener("input", markLongTextAsChangedAfterAnalysis);
  dom.longTextInput.addEventListener("keydown", (event) => {
    if (event.key !== "Enter" || event.shiftKey || event.altKey || event.ctrlKey || event.metaKey) {
      return;
    }

    const longTextValue = normalizeLongTextInput(dom.longTextInput.value);
    if (longTextValue.length < LONG_TEXT_MIN_CHARS) {
      return;
    }

    event.preventDefault();
    analyzeLongTextInput({ autoSuggest: true });
  });
  dom.analyzeLongTextBtn.addEventListener("click", () => {
    analyzeLongTextInput({ autoSuggest: true });
  });
  dom.generateLongTextDraftsBtn.addEventListener("click", () => {
    generateDraftsFromLongTextInput({ replacePreviousBatch: true });
  });
  dom.approveAllTextDraftsBtn.addEventListener("click", approveAllLongTextDrafts);
  dom.questionSearchInput.addEventListener("input", () => {
    renderAllQuestionsManager();
  });
  dom.draftQueueStatusFilter?.addEventListener("change", () => {
    renderDrafts();
  });
  dom.draftQueueSearchInput?.addEventListener("input", () => {
    renderDrafts();
  });
  dom.selectVisibleDraftsBtn?.addEventListener("click", selectVisibleDrafts);
  dom.clearDraftSelectionBtn?.addEventListener("click", clearDraftSelection);
  dom.moveDraftsToReviewBtn?.addEventListener("click", () => {
    moveSelectedDraftsToStatus("review");
  });
  dom.moveDraftsToDraftBtn?.addEventListener("click", () => {
    moveSelectedDraftsToStatus("draft");
  });
  dom.approveSelectedDraftsBtn?.addEventListener("click", approveSelectedDrafts);
  dom.rejectSelectedDraftsBtn?.addEventListener("click", rejectSelectedDrafts);
  dom.undoDraftActionBtn?.addEventListener("click", undoLastDraftAction);

  [
    dom.questionCategoryFilter,
    dom.questionKindFilter,
    dom.questionVisibilityFilter,
    dom.questionSourceFilter,
    dom.questionDateFrom,
    dom.questionDateTo,
    dom.questionSortMode,
  ].forEach((node) => {
    node?.addEventListener("change", () => {
      renderAllQuestionsManager();
    });
  });
  dom.resetQuestionFiltersBtn?.addEventListener("click", resetQuestionFilters);
  dom.runQuestionAuditBtn.addEventListener("click", runQuestionBankAudit);
  dom.clearQuestionAuditBtn.addEventListener("click", clearQuestionBankAuditReport);

  dom.questionEditForm?.addEventListener("submit", submitQuestionEditModal);
  dom.questionEditCancelBtn?.addEventListener("click", closeQuestionEditModal);
  dom.questionEditCloseBtn?.addEventListener("click", closeQuestionEditModal);
  dom.questionEditModal?.addEventListener("click", (event) => {
    if (event.target === dom.questionEditModal) {
      closeQuestionEditModal();
    }
  });
  window.addEventListener("keydown", (event) => {
    if (event.key === "Escape" && dom.questionEditModal && !dom.questionEditModal.classList.contains("hidden")) {
      closeQuestionEditModal();
    }
  });

  window.addEventListener("mqg-sw-update-ready", (event) => {
    const waitingWorker = event?.detail?.worker;
    if (waitingWorker) {
      appUpdateState.waitingWorker = waitingWorker;
    }
    showAppUpdateBanner();
  });
  dom.appUpdateDismissBtn?.addEventListener("click", () => {
    hideAppUpdateBanner();
  });
  dom.appUpdateReloadBtn?.addEventListener("click", applyAppUpdateNow);
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.addEventListener("controllerchange", handleAppServiceWorkerControllerChange);
  }

  window.addEventListener(
    "pointerdown",
    () => {
      ensureMusicPlayback();
    },
    { passive: true },
  );
}

function resetQuestionCyclesFlow() {
  const shouldReset = window.confirm(
    "לאתחל את מחזור השאלות ולהתחיל ערבוב מחדש כבר עכשיו?",
  );
  if (!shouldReset) {
    return;
  }

  const savedQuestions = writeStorage(STORAGE_KEYS.questionCycleUsedIds, []);
  const savedFamilies = writeStorage(STORAGE_KEYS.familyCycleUsedIds, []);
  const savedScopedQuestions = writeStorage(STORAGE_KEYS.questionCycleByScope, {});
  const savedScopedFamilies = writeStorage(STORAGE_KEYS.familyCycleByScope, {});
  if (!savedQuestions || !savedFamilies || !savedScopedQuestions || !savedScopedFamilies) {
    showMessage(
      dom.questionCycleResetMsg,
      "האיפוס נכשל בגלל מגבלת אחסון בדפדפן.",
      false,
    );
    return;
  }

  showMessage(
    dom.questionCycleResetMsg,
    "האיפוס הצליח. מחזור השאלות אותחל והמערכת תתחיל ערבוב חדש.",
    true,
  );
}

function formatCooldownMs(remainingMs) {
  const safeMs = Math.max(0, Number(remainingMs) || 0);
  const totalSec = Math.ceil(safeMs / 1000);
  if (totalSec < 60) {
    return `${totalSec} שניות`;
  }
  const min = Math.floor(totalSec / 60);
  const sec = totalSec % 60;
  return sec ? `${min} דק׳ ו-${sec} שנ׳` : `${min} דק׳`;
}

function readAntiSpamState() {
  return readObjectStorage(STORAGE_KEYS.antiSpamState, {});
}

function writeAntiSpamState(nextState) {
  return writeStorage(STORAGE_KEYS.antiSpamState, nextState);
}

function getAntiSpamBucket(state, actionKey) {
  const safeKey = normalizeSpace(actionKey);
  if (!safeKey) {
    return null;
  }
  const current = state[safeKey];
  if (current && typeof current === "object") {
    return current;
  }
  state[safeKey] = {
    events: [],
    blockedUntil: 0,
    lastPayloadHash: "",
    lastPayloadAt: 0,
  };
  return state[safeKey];
}

function pruneAntiSpamEvents(bucket, windowMs, nowTs) {
  if (!bucket || !Array.isArray(bucket.events)) {
    return;
  }
  const minTs = nowTs - windowMs;
  bucket.events = bucket.events.filter((item) => Number(item) >= minTs);
}

function checkAntiSpamBlock(actionKey) {
  const rule = ANTI_SPAM_RULES[actionKey];
  if (!rule) {
    return { blocked: false, remainingMs: 0 };
  }

  const state = readAntiSpamState();
  const bucket = getAntiSpamBucket(state, actionKey);
  const nowTs = Date.now();
  const blockedUntil = Number(bucket?.blockedUntil || 0);
  const remainingMs = Math.max(0, blockedUntil - nowTs);
  return {
    blocked: remainingMs > 0,
    remainingMs,
  };
}

function clearAntiSpamEvents(actionKey) {
  const state = readAntiSpamState();
  const bucket = getAntiSpamBucket(state, actionKey);
  if (!bucket) {
    return;
  }
  bucket.events = [];
  bucket.blockedUntil = 0;
  writeAntiSpamState(state);
}

function recordAntiSpamEvent(actionKey, payloadHash = "") {
  const rule = ANTI_SPAM_RULES[actionKey];
  if (!rule) {
    return { blocked: false, remainingMs: 0, duplicate: false };
  }

  const state = readAntiSpamState();
  const bucket = getAntiSpamBucket(state, actionKey);
  const nowTs = Date.now();
  pruneAntiSpamEvents(bucket, rule.windowMs, nowTs);

  const normalizedPayloadHash = normalizeSpace(payloadHash);
  const isDuplicatePayload = Boolean(
    normalizedPayloadHash
      && normalizedPayloadHash === normalizeSpace(bucket.lastPayloadHash)
      && nowTs - Number(bucket.lastPayloadAt || 0) < 8_000,
  );

  bucket.events.push(nowTs);
  bucket.lastPayloadHash = normalizedPayloadHash;
  bucket.lastPayloadAt = nowTs;

  if (bucket.events.length > rule.maxEvents) {
    bucket.blockedUntil = nowTs + rule.blockMs;
  }

  writeAntiSpamState(state);

  const remainingMs = Math.max(0, Number(bucket.blockedUntil || 0) - nowTs);
  return {
    blocked: remainingMs > 0,
    remainingMs,
    duplicate: isDuplicatePayload,
  };
}

function showAppUpdateBanner() {
  dom.appUpdateBanner?.classList.remove("hidden");
}

function hideAppUpdateBanner() {
  if (appUpdateState.isApplying) {
    return;
  }
  dom.appUpdateBanner?.classList.add("hidden");
}

function clearAppUpdateReloadTimer() {
  if (appUpdateState.reloadTimerId) {
    window.clearTimeout(appUpdateState.reloadTimerId);
    appUpdateState.reloadTimerId = null;
  }
}

function handleAppServiceWorkerControllerChange() {
  if (!appUpdateState.isApplying) {
    return;
  }
  clearAppUpdateReloadTimer();
  window.location.reload();
}

function applyAppUpdateNow() {
  if (appUpdateState.isApplying) {
    return;
  }

  appUpdateState.isApplying = true;
  dom.appUpdateReloadBtn.disabled = true;
  dom.appUpdateDismissBtn.disabled = true;

  const fallbackReload = () => {
    clearAppUpdateReloadTimer();
    appUpdateState.reloadTimerId = window.setTimeout(() => {
      window.location.reload();
    }, 1600);
  };

  const waitingWorker = appUpdateState.waitingWorker;
  if (waitingWorker && typeof waitingWorker.postMessage === "function") {
    waitingWorker.postMessage({ type: "SKIP_WAITING" });
    fallbackReload();
    return;
  }

  if (!("serviceWorker" in navigator) || !navigator.serviceWorker.getRegistration) {
    window.location.reload();
    return;
  }

  navigator.serviceWorker.getRegistration()
    .then((registration) => {
      if (registration?.waiting && typeof registration.waiting.postMessage === "function") {
        appUpdateState.waitingWorker = registration.waiting;
        registration.waiting.postMessage({ type: "SKIP_WAITING" });
        fallbackReload();
        return;
      }
      window.location.reload();
    })
    .catch(() => {
      window.location.reload();
    });
}

function escapeCsvCell(value) {
  const raw = value === null || value === undefined ? "" : String(value);
  if (/[",\n]/.test(raw)) {
    return `"${raw.replace(/"/g, "\"\"")}"`;
  }
  return raw;
}

function buildCsvContent(headers, rows) {
  const allRows = [headers, ...rows];
  return allRows.map((row) => row.map((cell) => escapeCsvCell(cell)).join(",")).join("\n");
}

function downloadCsvFile(filename, headers, rows) {
  const csvText = buildCsvContent(headers, rows);
  const blob = new Blob([`\uFEFF${csvText}`], { type: "text/csv;charset=utf-8;" });
  const href = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = href;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(href);
}

function buildExportTimestamp() {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const day = String(now.getDate()).padStart(2, "0");
  const hour = String(now.getHours()).padStart(2, "0");
  const minute = String(now.getMinutes()).padStart(2, "0");
  return `${year}${month}${day}-${hour}${minute}`;
}

function exportAttemptsCsv() {
  const attempts = readStorage(STORAGE_KEYS.attempts, []);
  if (!attempts.length) {
    window.alert("אין עדיין נתוני תוצאות לייצוא.");
    return;
  }

  const headers = [
    "player_name",
    "score",
    "correct",
    "total",
    "percent",
    "duration_seconds",
    "avg_answer_seconds",
    "timeouts",
    "adaptive_mode",
    "adaptive_confidence",
    "adaptive_signals",
    "played_at",
  ];
  const rows = attempts.map((attempt) => [
    normalizeSpace(attempt?.playerName) || "ללא שם",
    Number(attempt?.score || 0),
    Number(attempt?.correct || 0),
    Number(attempt?.total || 0),
    Number(attempt?.percent || 0),
    Number(attempt?.durationSec || 0),
    Number(attempt?.avgAnswerSec || 0).toFixed(2),
    Number(attempt?.timeoutCount || 0),
    Boolean(attempt?.adaptiveMode),
    Number(attempt?.adaptiveConfidence || 0),
    Number(attempt?.adaptiveSignals || 0),
    normalizeSpace(attempt?.playedAt),
  ]);

  downloadCsvFile(`mqg-attempts-${buildExportTimestamp()}.csv`, headers, rows);
}

function exportHardestQuestionsCsv() {
  const rows = buildQuestionLearningRows(readStorage(STORAGE_KEYS.attempts, []));
  const actionable = rows.filter((item) => item.total >= 1);
  if (!actionable.length) {
    window.alert("אין עדיין נתונים ברמת שאלה לייצוא.");
    return;
  }

  const headers = [
    "question_id",
    "category",
    "question",
    "sample_size",
    "correct",
    "wrong",
    "timeouts",
    "accuracy_percent",
    "fail_rate_percent",
    "timeout_rate_percent",
    "risk_score",
    "avg_answer_seconds",
    "issue_cause",
    "ambiguity_score",
    "ambiguous_signal",
  ];
  const csvRows = actionable.map((item) => [
    item.id,
    item.category,
    item.question,
    item.total,
    item.correct,
    item.wrong,
    item.timeouts,
    item.accuracy,
    item.failRate,
    item.timeoutRate,
    item.riskScore,
    Number(item.avgSec || 0).toFixed(2),
    getQuestionIssueCauseLabel(item.issueCause),
    Number(item.ambiguityScore || 0),
    Boolean(item.ambiguousSignal),
  ]);

  downloadCsvFile(`mqg-hardest-questions-${buildExportTimestamp()}.csv`, headers, csvRows);
}

function showScreen(screenId) {
  if (screenId !== "screenQuiz") {
    stopQuestionTimer();
    dom.screenQuiz.classList.remove("time-warning", "time-critical");
    hideMessage(dom.questionCycleResetMsg);
  }

  screenIds.forEach((id) => {
    const node = document.getElementById(id);
    if (!node) {
      return;
    }

    if (id === screenId) {
      node.classList.remove("hidden");
    } else {
      node.classList.add("hidden");
    }
  });

  if (screenId === "screenQuiz") {
    dom.newGameAnytimeBtn.textContent = "התחל משחק חדש";
  } else {
    dom.newGameAnytimeBtn.textContent = "משחק חדש בכל שלב";
  }

  const hideMusicControls = screenId === "screenAdminPanel" || screenId === "screenAdminLogin";
  dom.musicControls.classList.toggle("hidden", hideMusicControls);

  if (screenId === "screenLanding") {
    updateLandingModeCards();
    if (dom.entryDepartmentMsg) {
      hideMessage(dom.entryDepartmentMsg);
    }
  }
}

function resolveScreenId(shortName) {
  if (!shortName) {
    return "screenLanding";
  }

  if (shortName.startsWith("screen")) {
    return shortName;
  }

  const mapping = {
    landing: "screenLanding",
    quicksetup: "screenQuickSetup",
    adminlogin: "screenAdminLogin",
    quiz: "screenQuiz",
    result: "screenResult",
    adminpanel: "screenAdminPanel",
  };

  return mapping[shortName.toLowerCase()] || "screenLanding";
}

function initMusic() {
  const settings = readObjectStorage(STORAGE_KEYS.musicSettings, {});
  const volume = clampNumber(
    Number.isFinite(settings.volume) ? settings.volume : MUSIC_DEFAULT_VOLUME,
    0,
    1,
  );
  const muted = Boolean(settings.muted);

  dom.bgMusic.volume = volume;
  dom.bgMusic.muted = muted;
  dom.bgMusic.loop = true;
  renderMusicUi();
}

function ensureMusicPlayback() {
  if (!dom.bgMusic.paused) {
    return;
  }
  const playPromise = dom.bgMusic.play();
  if (playPromise && typeof playPromise.then === "function") {
    playPromise
      .then(() => {
        gameState.musicStarted = true;
      })
      .catch(() => {});
  }
}

function updateMusicVolume(nextValue) {
  const volume = clampNumber(nextValue, 0, 1);
  dom.bgMusic.volume = volume;
  if (volume > 0 && dom.bgMusic.muted) {
    dom.bgMusic.muted = false;
  }
  saveMusicSettings();
  renderMusicUi();
}

function saveMusicSettings() {
  writeStorage(STORAGE_KEYS.musicSettings, {
    volume: dom.bgMusic.volume,
    muted: dom.bgMusic.muted,
  });
}

function renderMusicUi() {
  const volumePercent = Math.round((dom.bgMusic.volume || 0) * 100);
  dom.musicLevelText.textContent = dom.bgMusic.muted
    ? `עוצמה: ${volumePercent}% (מושתק)`
    : `עוצמה: ${volumePercent}%`;
  dom.musicMuteBtn.textContent = dom.bgMusic.muted ? "בטל השתקה" : "השתק";
}

function resetAndGoToNewGame() {
  stopQuestionTimer();
  gameState.locked = false;
  gameState.index = 0;
  gameState.questions = [];
  gameState.score = 0;
  gameState.correctCount = 0;
  gameState.answerTimes = [];
  gameState.timeoutCount = 0;
  gameState.categoryStats = {};
  gameState.questionStats = {};
  gameState.wrong = [];
  gameState.feedbackDeepOpen = false;
  gameState.questionStartedAt = 0;
  gameState.questionRenderedAt = 0;
  gameState.remainingSeconds = QUESTION_TIMEOUT_SECONDS;
  gameState.adaptiveMode = false;
  gameState.adaptiveConfidence = 0;
  gameState.adaptiveSignals = 0;
  dom.screenQuiz.classList.remove("time-warning", "time-critical");
  hideMessage(dom.questionCycleResetMsg);
  hideMessage(dom.quickSetupError);
  showScreen("screenQuickSetup");
}

function startQuickGame() {
  hideMessage(dom.quickSetupError);
  hideMessage(dom.questionCycleResetMsg);
  stopQuestionTimer();
  const antiSpam = recordAntiSpamEvent("quickStart");
  if (antiSpam.blocked) {
    showMessage(
      dom.quickSetupError,
      `זוהו יותר מדי ניסיונות התחלה בזמן קצר. נסה שוב בעוד ${formatCooldownMs(antiSpam.remainingMs)}.`,
      false,
    );
    return;
  }

  const playerName = dom.playerNameInput.value.trim();
  if (!playerName) {
    showMessage(dom.quickSetupError, "יש להזין שם כדי להתחיל משחק.", false);
    return;
  }

  const department = normalizeEntryDepartment(gameState.entryDepartment);
  if (!department) {
    showMessage(dom.quickSetupError, "יש לבחור קודם אגף במסך הכניסה.", false);
    return;
  }

  const quickMode = normalizeQuickMode(gameState.quickMode);
  const activityTopicId = getCurrentActivityTopicId();
  gameState.activityTopic = activityTopicId;

  const questionPool = getGameQuestionPoolByContext();
  if (!questionPool.length) {
    const activityTopicTitle = TELEMARKETING_ACTIVITY_TOPIC_BY_ID[activityTopicId]?.title || "הנושא שנבחר";
    showMessage(
      dom.quickSetupError,
      department === ENTRY_DEPARTMENTS.EDUCATION
        ? "אין כרגע שאלות זמינות למסלול אגף חינוך."
        : quickMode === QUICK_MODES.SEASONAL
          ? "אין כרגע שאלות זמינות במצב עונתי (מאוקטובר 2025 ומעלה)."
          : quickMode === QUICK_MODES.ACTIVITY
            ? `אין כרגע שאלות זמינות למשחק על פי פעילות בנושא "${activityTopicTitle}".`
            : "אין כרגע שאלות זמינות במאגר.",
      false,
    );
    return;
  }

  const countValue = dom.questionCountSelect.value;
  const count = countValue === "all" ? questionPool.length : Number(countValue);
  const cycleScope = buildCycleScopeKey();
  const adaptiveSelection = buildPlayerAdaptiveSelectionOptions(playerName, questionPool);
  const gameQuestions = pickGameQuestions(
    questionPool,
    Math.min(count, questionPool.length),
    cycleScope,
    adaptiveSelection,
  );

  gameState.playerName = playerName;
  gameState.questions = gameQuestions;
  gameState.index = 0;
  gameState.score = 0;
  gameState.correctCount = 0;
  gameState.answerTimes = [];
  gameState.timeoutCount = 0;
  gameState.categoryStats = {};
  gameState.questionStats = {};
  gameState.startAt = Date.now();
  gameState.questionStartedAt = 0;
  gameState.questionRenderedAt = 0;
  gameState.remainingSeconds = QUESTION_TIMEOUT_SECONDS;
  gameState.showLearning = dom.showLearningToggle.checked;
  gameState.locked = false;
  gameState.feedbackDeepOpen = false;
  gameState.wrong = [];
  gameState.adaptiveMode = adaptiveSelection.strategy === "adaptive";
  gameState.adaptiveConfidence = Number(adaptiveSelection.confidence || 0);
  gameState.adaptiveSignals = Number(adaptiveSelection.matchedSignals || 0);

  showScreen("screenQuiz");
  renderQuestion();
}

function pickGameQuestions(questionPool, count, scopeKey = "default", options = {}) {
  const safeScope = normalizeSpace(scopeKey) || "default";
  const targetCount = Math.min(questionPool.length, Math.max(1, Number(count) || 1));
  const families = groupQuestionsByFamily(questionPool);
  const familyKeys = Array.from(families.keys());
  const adaptiveScores = options?.adaptiveScores instanceof Map ? options.adaptiveScores : null;
  const useAdaptiveStrategy = normalizeSpace(options?.strategy).toLowerCase() === "adaptive" && Boolean(adaptiveScores);
  const allQuestionIds = questionPool
    .map((question) => String(question?.id || "").trim())
    .filter(Boolean);

  let usedQuestionIds = readCycleSetByScope(STORAGE_KEYS.questionCycleByScope, safeScope, allQuestionIds);
  if (!usedQuestionIds.size) {
    usedQuestionIds = readCycleSet(STORAGE_KEYS.questionCycleUsedIds, allQuestionIds);
  }
  if (usedQuestionIds.size >= questionPool.length) {
    usedQuestionIds = new Set();
  }

  let usedFamilyIds = readCycleSetByScope(STORAGE_KEYS.familyCycleByScope, safeScope, familyKeys);
  if (!usedFamilyIds.size) {
    usedFamilyIds = readCycleSet(STORAGE_KEYS.familyCycleUsedIds, familyKeys);
  }
  if (usedFamilyIds.size >= familyKeys.length) {
    usedFamilyIds = new Set();
  }

  let freshPool = questionPool.filter((question) => !usedQuestionIds.has(question.id));
  if (freshPool.length < targetCount) {
    usedQuestionIds = new Set();
    freshPool = questionPool.slice();
  }

  const freshFamilies = groupQuestionsByFamily(freshPool);
  let availableFreshFamilyKeys = familyKeys.filter(
    (familyKey) => freshFamilies.has(familyKey) && !usedFamilyIds.has(familyKey),
  );
  if (!availableFreshFamilyKeys.length) {
    usedFamilyIds = new Set();
    availableFreshFamilyKeys = familyKeys.filter((familyKey) => freshFamilies.has(familyKey));
  }

  const selected = [];
  const selectedIds = new Set();
  const selectedFamilies = [];
  const maxDiversified = Math.min(targetCount, availableFreshFamilyKeys.length);
  const diversifiedFamilyOrder = useAdaptiveStrategy
    ? rankFamiliesByAdaptiveScore(availableFreshFamilyKeys, freshFamilies, adaptiveScores)
    : pickRandom(availableFreshFamilyKeys, availableFreshFamilyKeys.length);

  for (let i = 0; i < diversifiedFamilyOrder.length; i += 1) {
    if (selected.length >= maxDiversified) {
      break;
    }

    const familyKey = diversifiedFamilyOrder[i];
    const familyQuestions = (freshFamilies.get(familyKey) || []).filter(
      (question) => !selectedIds.has(question.id),
    );
    if (!familyQuestions.length) {
      continue;
    }

    const picked = useAdaptiveStrategy
      ? pickAdaptiveQuestionFromPool(familyQuestions, adaptiveScores)
      : pickRandom(familyQuestions, 1)[0];
    if (!picked) {
      continue;
    }

    selected.push(picked);
    selectedIds.add(picked.id);
    selectedFamilies.push(familyKey);
  }

  if (selected.length < targetCount) {
    const leftovers = freshPool.filter((question) => !selectedIds.has(question.id));
    const extra = useAdaptiveStrategy
      ? pickAdaptiveQuestionsFromPool(leftovers, targetCount - selected.length, adaptiveScores)
      : pickRandom(leftovers, targetCount - selected.length);
    extra.forEach((question) => {
      selected.push(question);
      selectedIds.add(question.id);
      const family = getQuestionFamilyKey(question);
      if (!selectedFamilies.includes(family)) {
        selectedFamilies.push(family);
      }
    });
  }

  selected.forEach((question) => {
    usedQuestionIds.add(question.id);
  });
  writeCycleSetByScope(STORAGE_KEYS.questionCycleByScope, safeScope, usedQuestionIds);
  if (safeScope === "telemarketing_regular") {
    writeStorage(STORAGE_KEYS.questionCycleUsedIds, Array.from(usedQuestionIds));
  }

  selectedFamilies.forEach((family) => {
    usedFamilyIds.add(family);
  });
  writeCycleSetByScope(
    STORAGE_KEYS.familyCycleByScope,
    safeScope,
    Array.from(usedFamilyIds).slice(-Math.max(1, familyKeys.length)),
  );
  if (safeScope === "telemarketing_regular") {
    writeStorage(
      STORAGE_KEYS.familyCycleUsedIds,
      Array.from(usedFamilyIds).slice(-Math.max(1, familyKeys.length)),
    );
  }

  return selected;
}

function getAdaptiveQuestionScore(question, adaptiveScores) {
  const questionId = normalizeSpace(question?.id);
  if (!adaptiveScores || !questionId || !adaptiveScores.has(questionId)) {
    return 1;
  }
  const raw = Number(adaptiveScores.get(questionId));
  if (!Number.isFinite(raw) || raw <= 0) {
    return 1;
  }
  return raw;
}

function getFamilyAdaptiveScore(familyKey, familyMap, adaptiveScores) {
  const rows = familyMap.get(familyKey) || [];
  if (!rows.length) {
    return 1;
  }
  return rows.reduce((maxScore, row) => Math.max(maxScore, getAdaptiveQuestionScore(row, adaptiveScores)), 1);
}

function rankFamiliesByAdaptiveScore(familyKeys, familyMap, adaptiveScores) {
  return familyKeys.slice().sort((a, b) => {
    const scoreDiff = getFamilyAdaptiveScore(b, familyMap, adaptiveScores)
      - getFamilyAdaptiveScore(a, familyMap, adaptiveScores);
    if (Math.abs(scoreDiff) < 0.0001) {
      return Math.random() > 0.5 ? 1 : -1;
    }
    return scoreDiff;
  });
}

function pickAdaptiveQuestionFromPool(questionPool, adaptiveScores) {
  if (!Array.isArray(questionPool) || !questionPool.length) {
    return null;
  }
  const sorted = questionPool
    .slice()
    .sort((a, b) => getAdaptiveQuestionScore(b, adaptiveScores) - getAdaptiveQuestionScore(a, adaptiveScores));
  const topScore = getAdaptiveQuestionScore(sorted[0], adaptiveScores);
  const nearTop = sorted.filter(
    (item) => getAdaptiveQuestionScore(item, adaptiveScores) >= topScore - 0.06,
  );
  return pickRandom(nearTop, 1)[0] || sorted[0] || null;
}

function pickAdaptiveQuestionsFromPool(questionPool, count, adaptiveScores) {
  const safeCount = Math.max(0, Number(count) || 0);
  if (!safeCount || !Array.isArray(questionPool) || !questionPool.length) {
    return [];
  }
  return questionPool
    .slice()
    .sort((a, b) => getAdaptiveQuestionScore(b, adaptiveScores) - getAdaptiveQuestionScore(a, adaptiveScores))
    .slice(0, safeCount);
}

function groupQuestionsByFamily(questionPool) {
  const families = new Map();
  questionPool.forEach((question) => {
    const family = getQuestionFamilyKey(question);
    if (!families.has(family)) {
      families.set(family, []);
    }
    families.get(family).push(question);
  });
  return families;
}

function getQuestionFamilyKey(question) {
  const id = String((question && question.id) || "").trim();
  if (!id) {
    return clampText(question?.question || "unknown_question", 80);
  }

  if (/_v\d+$/.test(id)) {
    return id.replace(/_v\d+$/, "");
  }
  if (/_base$/.test(id)) {
    return id.replace(/_base$/, "");
  }

  return id;
}

function readCycleSet(storageKey, allowedValues) {
  const allowed = new Set(
    (allowedValues || [])
      .map((value) => String(value || "").trim())
      .filter(Boolean),
  );
  const current = readStorage(storageKey, []);
  const filtered = (current || [])
    .map((value) => String(value || "").trim())
    .filter((value) => allowed.has(value));
  return new Set(filtered);
}

function readCycleSetByScope(storageKey, scopeKey, allowedValues) {
  const safeScope = normalizeSpace(scopeKey) || "default";
  const scopedMap = readObjectStorage(storageKey, {});
  const scopedRaw = Array.isArray(scopedMap?.[safeScope]) ? scopedMap[safeScope] : [];
  const allowed = new Set(
    (allowedValues || [])
      .map((value) => String(value || "").trim())
      .filter(Boolean),
  );
  const filtered = scopedRaw
    .map((value) => String(value || "").trim())
    .filter((value) => allowed.has(value));
  return new Set(filtered);
}

function writeCycleSetByScope(storageKey, scopeKey, values) {
  const safeScope = normalizeSpace(scopeKey) || "default";
  const scopedMap = readObjectStorage(storageKey, {});
  const nextValues = Array.isArray(values) ? values : Array.from(values || []);
  scopedMap[safeScope] = nextValues.map((value) => String(value || "").trim()).filter(Boolean);
  return writeStorage(storageKey, scopedMap);
}

function renderQuestion() {
  const question = gameState.questions[gameState.index];
  const current = gameState.index + 1;
  const total = gameState.questions.length;

  const adaptiveSuffix = gameState.adaptiveMode
    ? ` | מצב מותאם (${gameState.adaptiveConfidence}%)`
    : "";
  dom.quizPlayerName.textContent = `שחקן: ${gameState.playerName}${adaptiveSuffix}`;
  dom.quizProgress.textContent = `שאלה ${current}/${total}`;
  dom.quizScore.textContent = `ניקוד: ${Math.round(gameState.score)} נק'`;
  dom.quizProgressFill.style.width = `${Math.round((current / total) * 100)}%`;
  dom.questionBanner.onerror = () => {
    dom.questionBanner.onerror = null;
    dom.questionBanner.src = buildFallbackBannerImage(question);
  };
  dom.questionBanner.src = buildBannerImage(question);
  dom.questionTitle.textContent = question.question;

  if (gameState.showLearning) {
    dom.questionLearn.textContent = `רקע קצר: ${question.learn}`;
    dom.questionLearn.classList.remove("hidden");
  } else {
    dom.questionLearn.classList.add("hidden");
  }

  dom.feedbackCard.classList.add("hidden");
  dom.feedbackWrongReasons.innerHTML = "";
  dom.feedbackDeepReasons.innerHTML = "";
  dom.feedbackDeepReasons.classList.add("hidden");
  dom.feedbackDeepExplainBtn.classList.add("hidden");
  dom.feedbackDeepExplainBtn.textContent = "הסבר יותר לעומק";
  gameState.feedbackDeepOpen = false;
  dom.optionsWrap.innerHTML = "";
  dom.screenQuiz.classList.remove("time-warning", "time-critical");

  question.options.forEach((optionText, index) => {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "option-btn";
    btn.textContent = optionText;
    btn.addEventListener("click", () => answerQuestion(index));
    dom.optionsWrap.appendChild(btn);
  });

  gameState.questionRenderedAt = Date.now();
  startQuestionTimer();
}

function answerQuestion(selectedIndex, options = {}) {
  const { timedOut = false } = options;

  if (gameState.locked) {
    return;
  }

  if (
    !timedOut
    && gameState.questionRenderedAt
    && Date.now() - gameState.questionRenderedAt < MIN_HUMAN_ANSWER_MS
  ) {
    return;
  }

  gameState.locked = true;
  stopQuestionTimer();
  dom.screenQuiz.classList.remove("time-warning", "time-critical");

  const question = gameState.questions[gameState.index];
  const elapsedSeconds = timedOut ? QUESTION_TIMEOUT_SECONDS : getCurrentElapsedSeconds();
  gameState.answerTimes.push(elapsedSeconds);
  if (timedOut) {
    gameState.timeoutCount += 1;
  }
  const isCorrect = !timedOut && selectedIndex === question.answer;
  updateCategoryPerformance(question, isCorrect, timedOut, elapsedSeconds);
  updateQuestionPerformance(question, isCorrect, timedOut, elapsedSeconds, selectedIndex);
  updatePlayerSpacedMemory(gameState.playerName, question, {
    isCorrect,
    timedOut,
    elapsedSeconds,
  });
  const optionButtons = Array.from(dom.optionsWrap.querySelectorAll(".option-btn"));

  optionButtons.forEach((button, index) => {
    button.disabled = true;

    if (index === question.answer) {
      button.classList.add("correct");
    } else if (index === selectedIndex) {
      button.classList.add("wrong");
    }
  });

  if (isCorrect) {
    const earnedPoints = calcPointsForSpeed(elapsedSeconds);
    gameState.score += earnedPoints;
    gameState.correctCount += 1;
    dom.feedbackHeadline.textContent = `נכון מאוד (+${earnedPoints} נק')`;
  } else {
    gameState.wrong.push({ question, selectedIndex, timedOut });
    dom.feedbackHeadline.textContent = timedOut
      ? "נגמר הזמן - השאלה נפסלה"
      : "לא מדויק";
  }

  dom.quizScore.textContent = `ניקוד: ${Math.round(gameState.score)} נק'`;
  if (timedOut) {
    dom.feedbackText.textContent = `לא נענתה תשובה בתוך ${QUESTION_TIMEOUT_SECONDS} שניות, ולכן לא התקבל ניקוד. ${question.explanation}`;
  } else {
    dom.feedbackText.textContent = question.explanation;
  }
  renderAnswerFeedbackDetails({
    question,
    isCorrect,
    timedOut,
    selectedIndex,
  });
  renderSources(dom.feedbackSources, question.sources, question);
  dom.feedbackCard.classList.remove("hidden");
}

function updateCategoryPerformance(question, isCorrect, timedOut, elapsedSeconds) {
  const category = String(question?.category || "ללא קטגוריה");
  if (!gameState.categoryStats[category]) {
    gameState.categoryStats[category] = {
      total: 0,
      correct: 0,
      timeouts: 0,
      totalAnswerSec: 0,
    };
  }

  const stat = gameState.categoryStats[category];
  stat.total += 1;
  stat.totalAnswerSec += Number(elapsedSeconds || 0);
  if (isCorrect) {
    stat.correct += 1;
  }
  if (timedOut) {
    stat.timeouts += 1;
  }
}

function updateQuestionPerformance(question, isCorrect, timedOut, elapsedSeconds, selectedIndex = -1) {
  const questionId = normalizeSpace(question?.id);
  if (!questionId) {
    return;
  }

  if (!gameState.questionStats[questionId]) {
    gameState.questionStats[questionId] = {
      questionId,
      questionText: normalizeSpace(question?.question),
      category: normalizeSpace(question?.category) || "ללא קטגוריה",
      correctAnswerIndex: Number.isInteger(Number(question?.answer)) ? Number(question.answer) : -1,
      total: 0,
      correct: 0,
      wrong: 0,
      timeouts: 0,
      totalAnswerSec: 0,
      optionCount: Array.isArray(question?.options) ? question.options.length : 0,
      selectedOptionCounts: {},
    };
  }

  const stat = gameState.questionStats[questionId];
  stat.total += 1;
  stat.totalAnswerSec += Number(elapsedSeconds || 0);
  if (isCorrect) {
    stat.correct += 1;
  } else {
    stat.wrong += 1;
  }
  if (timedOut) {
    stat.timeouts += 1;
  }

  if (!stat.selectedOptionCounts || typeof stat.selectedOptionCounts !== "object") {
    stat.selectedOptionCounts = {};
  }
  if (timedOut || selectedIndex < 0) {
    stat.selectedOptionCounts.timeout = Number(stat.selectedOptionCounts.timeout || 0) + 1;
    return;
  }

  const selectedKey = `opt_${selectedIndex}`;
  stat.selectedOptionCounts[selectedKey] = Number(stat.selectedOptionCounts[selectedKey] || 0) + 1;
}

function renderAnswerFeedbackDetails(payload) {
  const {
    question,
    isCorrect = false,
    timedOut = false,
    selectedIndex = -1,
  } = payload || {};

  dom.feedbackWrongReasons.innerHTML = "";
  dom.feedbackDeepReasons.innerHTML = "";
  dom.feedbackDeepReasons.classList.add("hidden");
  dom.feedbackDeepExplainBtn.classList.add("hidden");
  dom.feedbackDeepExplainBtn.textContent = "הסבר יותר לעומק";
  gameState.feedbackDeepOpen = false;

  if (!question || !Array.isArray(question.options) || question.options.length < 2) {
    return;
  }

  const reasons = getOptionExplanations(question);

  if (!isCorrect) {
    const shortItems = buildShortWrongFeedbackItems({
      question,
      selectedIndex,
      timedOut,
      reasons,
    });
    shortItems.forEach((text) => {
      const li = document.createElement("li");
      li.className = "option-reason compact";
      li.textContent = text;
      dom.feedbackWrongReasons.appendChild(li);
    });
  }

  question.options.forEach((optionText, index) => {
    const li = document.createElement("li");
    const isAnswer = index === question.answer;
    li.className = `option-reason ${isAnswer ? "correct-note" : "detail-note"}`;
    if (isAnswer) {
      li.textContent = `למה "${optionText}" נכונה: ${reasons[index] || "זו האפשרות שתואמת למקור ולפעילות המתוארת."}`;
    } else {
      li.textContent = `למה "${optionText}" שגויה: ${reasons[index] || buildFallbackWrongReason(question, index)}`;
    }
    dom.feedbackDeepReasons.appendChild(li);
  });

  if (dom.feedbackDeepReasons.children.length) {
    dom.feedbackDeepExplainBtn.classList.remove("hidden");
  }
}

function buildShortWrongFeedbackItems(payload) {
  const {
    question,
    selectedIndex,
    timedOut,
    reasons,
  } = payload || {};
  const items = [];

  if (timedOut) {
    items.push("לא נבחרה תשובה בזמן, ולכן השאלה נפסלה.");
    items.push(`התשובה הנכונה: ${question.options[question.answer]}`);
    return items;
  }

  const selectedText = question.options[selectedIndex];
  if (typeof selectedText === "string") {
    const rawReason = reasons[selectedIndex] || buildFallbackWrongReason(question, selectedIndex);
    const shortReason = clampText(rawReason, 135);
    items.push(`"${selectedText}" לא מדויקת: ${shortReason}`);
  } else {
    items.push("התשובה שנבחרה לא תואמת למידע המתואר בשאלה.");
  }
  items.push(`מה נכון לזכור: ${question.options[question.answer]}`);
  return items;
}

function getOptionExplanations(question) {
  return ensureOptionExplanations(question);
}

function splitMeaningfulWords(text) {
  return normalizeSpace(text)
    .replace(/[^\p{L}\p{N}\s]/gu, " ")
    .split(" ")
    .map((word) => normalizeSpace(word))
    .filter((word) => word.length >= 3);
}

function buildDistractorLibraryReason(question, optionText) {
  const category = normalizeSpace(question?.category);
  const pools = [
    ...(DISTRACTOR_FEEDBACK_LIBRARY[category] || []),
    ...(DISTRACTOR_FEEDBACK_LIBRARY.default || []),
  ];
  for (let i = 0; i < pools.length; i += 1) {
    const rule = pools[i];
    if (!rule?.pattern || !(rule.pattern instanceof RegExp)) {
      continue;
    }
    if (rule.pattern.test(optionText)) {
      return rule.reason;
    }
  }
  return "";
}

function buildDistractorContrastReason(optionText, correctText) {
  const optionWords = splitMeaningfulWords(optionText);
  const correctWords = new Set(splitMeaningfulWords(correctText));
  if (!optionWords.length || !correctWords.size) {
    return "";
  }
  const overlap = optionWords.filter((word) => correctWords.has(word));
  if (overlap.length >= 2) {
    return "האפשרות נשמעת קרובה לנכון, אבל משנה רכיב מרכזי ולכן מובילה למסקנה שגויה.";
  }
  if (overlap.length === 0) {
    return "המילים המרכזיות באפשרות לא תואמות למסר העיקרי של השאלה.";
  }
  return "";
}

function buildFallbackWrongReason(question, index) {
  const correct = String(question?.options?.[question.answer] || "").trim();
  const option = String(question?.options?.[index] || "").trim();
  const explanation = clampText(String(question?.explanation || "").trim(), 150);
  const libraryReason = buildDistractorLibraryReason(question, option);
  const contrastReason = buildDistractorContrastReason(option, correct);

  if (option && correct) {
    const parts = [
      libraryReason,
      contrastReason,
      `המסקנה הנכונה היא "${correct}".`,
      explanation,
    ]
      .map((item) => normalizeSpace(item))
      .filter(Boolean);
    return parts.join(" ");
  }

  return `האפשרות הזו לא נתמכת במידע המתואר. ${explanation}`;
}

function ensureOptionExplanations(question) {
  const options = Array.isArray(question?.options)
    ? question.options.map((option) => String(option || "").trim())
    : [];
  const answer = Number(question?.answer);
  if (!options.length || !Number.isInteger(answer) || answer < 0 || answer >= options.length) {
    return [];
  }

  const existing = Array.isArray(question?.optionExplanations)
    ? question.optionExplanations.map((value) => String(value || "").trim())
    : [];

  if (existing.length === options.length && existing.every(Boolean)) {
    return existing;
  }

  return options.map((_, index) => {
    if (index === answer) {
      return `זו התשובה הנכונה לפי המקור: ${clampText(question.explanation || "", 150)}`;
    }
    return buildFallbackWrongReason(question, index);
  });
}

function startQuestionTimer() {
  stopQuestionTimer();
  gameState.questionStartedAt = Date.now();
  gameState.remainingSeconds = QUESTION_TIMEOUT_SECONDS;
  dom.hourglassIcon.style.animationPlayState = "running";
  updateTimerUI(gameState.remainingSeconds);

  gameState.timerIntervalId = window.setInterval(() => {
    const elapsed = (Date.now() - gameState.questionStartedAt) / 1000;
    const remaining = Math.max(0, QUESTION_TIMEOUT_SECONDS - elapsed);
    gameState.remainingSeconds = remaining;
    updateTimerUI(remaining);

    if (elapsed >= QUESTION_WARNING_AFTER_SECONDS) {
      dom.screenQuiz.classList.add("time-warning");
    }
    if (remaining <= 5) {
      dom.screenQuiz.classList.add("time-critical");
    }

    if (remaining <= 0) {
      stopQuestionTimer();
      if (!gameState.locked) {
        handleQuestionTimeout();
      }
    }
  }, 100);
}

function stopQuestionTimer() {
  if (gameState.timerIntervalId) {
    window.clearInterval(gameState.timerIntervalId);
    gameState.timerIntervalId = null;
  }
  dom.hourglassIcon.style.animationPlayState = "paused";
}

function updateTimerUI(remainingSeconds) {
  const sec = Math.max(0, remainingSeconds);
  dom.timerText.textContent = `${Math.ceil(sec)}`;
}

function getCurrentElapsedSeconds() {
  if (!gameState.questionStartedAt) {
    return 0;
  }

  return Math.min(
    QUESTION_TIMEOUT_SECONDS,
    Math.max(0, (Date.now() - gameState.questionStartedAt) / 1000),
  );
}

function calcPointsForSpeed(elapsedSeconds) {
  const earlyPenaltyPerSecond = 4;
  const latePenaltyPerSecond = 3;
  const pointsAtWarning = MAX_POINTS_PER_QUESTION - QUESTION_WARNING_AFTER_SECONDS * earlyPenaltyPerSecond;

  if (elapsedSeconds <= QUESTION_WARNING_AFTER_SECONDS) {
    return Math.max(
      MIN_POINTS_PER_CORRECT,
      Math.round(MAX_POINTS_PER_QUESTION - elapsedSeconds * earlyPenaltyPerSecond),
    );
  }

  const afterWarning = elapsedSeconds - QUESTION_WARNING_AFTER_SECONDS;
  return Math.max(
    MIN_POINTS_PER_CORRECT,
    Math.round(pointsAtWarning - afterWarning * latePenaltyPerSecond),
  );
}

function handleQuestionTimeout() {
  answerQuestion(-1, { timedOut: true });
}

function finishGame() {
  stopQuestionTimer();
  dom.screenQuiz.classList.remove("time-warning", "time-critical");

  const total = gameState.questions.length;
  const percent = total ? Math.round((gameState.correctCount / total) * 100) : 0;
  const durationSec = Math.max(1, Math.round((Date.now() - gameState.startAt) / 1000));
  const totalAnswerSec = gameState.answerTimes.reduce((sum, value) => sum + value, 0);
  const avgAnswerSec = gameState.answerTimes.length
    ? Number((totalAnswerSec / gameState.answerTimes.length).toFixed(2))
    : 0;
  const adaptiveText = gameState.adaptiveMode
    ? ` | מצב מותאם אישי: פעיל (${gameState.adaptiveConfidence}% ביטחון)`
    : "";

  saveAttempt({
    id: uid("attempt"),
    playerName: gameState.playerName,
    score: Math.round(gameState.score),
    correct: gameState.correctCount,
    total,
    percent,
    durationSec,
    avgAnswerSec,
    timeoutCount: gameState.timeoutCount,
    categoryStats: gameState.categoryStats,
    questionStats: gameState.questionStats,
    adaptiveMode: gameState.adaptiveMode,
    adaptiveConfidence: gameState.adaptiveConfidence,
    adaptiveSignals: gameState.adaptiveSignals,
    playedAt: new Date().toISOString(),
  });

  dom.resultMain.textContent = resultHeadline(percent);
  dom.resultSub.textContent = `ענית נכון על ${gameState.correctCount} מתוך ${total} שאלות (${percent}%). ניקוד סופי: ${Math.round(gameState.score)} נק'. זמן משחק: ${formatDuration(durationSec)} | זמן מענה ממוצע: ${avgAnswerSec.toFixed(1)} שניות | פקיעות זמן: ${gameState.timeoutCount}.${adaptiveText}`;

  renderWrongAnswers();
  showScreen("screenResult");
}

function resultHeadline(percent) {
  if (percent >= 90) {
    return "בקיאות גבוהה מאוד בפעילות העדכנית";
  }

  if (percent >= 70) {
    return "תוצאה טובה, יש עוד כמה נקודות לחידוד";
  }

  if (percent >= 50) {
    return "בסיס טוב, כדאי לחזור על ההסברים והמקורות";
  }

  return "מומלץ לעבור שוב על כרטיסי הלמידה ולנסות סבב נוסף";
}

function renderWrongAnswers() {
  dom.wrongAnswersWrap.innerHTML = "";

  if (!gameState.wrong.length) {
    const successLine = document.createElement("p");
    successLine.textContent = "לא היו טעויות בסבב הזה.";
    dom.wrongAnswersWrap.appendChild(successLine);
    return;
  }

  gameState.wrong.forEach((item) => {
    const card = document.createElement("article");
    card.className = "wrong-card";

    const title = document.createElement("strong");
    title.textContent = item.question.question;

    const answerLine = document.createElement("p");
    const status = item.timedOut ? "סטטוס: נגמר הזמן." : "סטטוס: תשובה שגויה.";
    answerLine.textContent = `${status} תשובה נכונה: ${item.question.options[item.question.answer]}`;

    const explainLine = document.createElement("p");
    explainLine.textContent = item.question.explanation;
    const compactLine = document.createElement("p");
    if (item.timedOut) {
      compactLine.textContent = "לא נבחרה תשובה בזמן לשאלה הזו.";
    } else {
      const reasons = getOptionExplanations(item.question);
      const selectedReason = reasons[item.selectedIndex]
        || buildFallbackWrongReason(item.question, item.selectedIndex);
      compactLine.textContent = `למה התשובה שנבחרה הייתה שגויה: ${clampText(selectedReason, 140)}`;
    }

    card.appendChild(title);
    card.appendChild(answerLine);
    card.appendChild(compactLine);
    card.appendChild(explainLine);
    dom.wrongAnswersWrap.appendChild(card);
  });
}

function buildExpandedQuestionBank(seedQuestions) {
  const normalizedSeeds = seedQuestions.map((question, idx) => {
    const seedOptions = sanitizeOptionsList(question?.options);
    const resolvedAnswerIndex = resolveAnswerIndex(
      question?.answer,
      seedOptions,
      question?.options,
    );
    const correctAnswer = seedOptions[resolvedAnswerIndex] || seedOptions[0] || "אין נתון";
    const safeOptions = ensureVariantOptions(seedOptions, correctAnswer, question?.category);
    const safeAnswer = safeOptions.indexOf(correctAnswer);
    return {
      ...question,
      id: question.id || `seed_${idx + 1}`,
      options: safeOptions,
      answer: safeAnswer >= 0 ? safeAnswer : 0,
      sources: normalizeQuestionSources(question?.sources, question),
    };
  });
  const expanded = [];

  normalizedSeeds.forEach((seed, index) => {
    const seedId = `${seed.id}_${index + 1}`;
    const correctAnswer = seed.options[seed.answer];

    expanded.push({
      ...seed,
      id: `${seedId}_base`,
      isGeneratedVariant: false,
    });


    QUESTION_VARIANT_PREFIXES.forEach((prefix, stemIndex) => {
      const mixedOptions = shuffleArray(seed.options.slice());
      expanded.push({
        id: `${seedId}_v${stemIndex + 1}`,
        kind: seed.kind,
        date: seed.date,
        category: seed.category,
        learn: seed.learn,
        question: buildSingleQuestionVariant(seed.question, prefix),
        options: mixedOptions,
        answer: mixedOptions.indexOf(correctAnswer),
        explanation: `${seed.explanation} זהו הרעיון המרכזי שכדאי לזכור מהאירוע הזה.`,
        sources: seed.sources,
        isGeneratedVariant: true,
      });
    });
  });

  return expanded.slice(0, 500);
}

function sanitizeOptionsList(options) {
  if (!Array.isArray(options)) {
    return [];
  }

  const seen = new Set();
  const uniqueOptions = [];

  options.forEach((option) => {
    const normalized = normalizeSpace(option);
    if (!normalized) {
      return;
    }
    const key = normalized.toLowerCase();
    if (seen.has(key)) {
      return;
    }
    seen.add(key);
    uniqueOptions.push(normalized);
  });

  return uniqueOptions;
}

function resolveAnswerIndex(answer, sanitizedOptions, originalOptions) {
  const parsed = Number(answer);
  const originalList = Array.isArray(originalOptions) ? originalOptions : [];
  const correctTextFromOriginal =
    Number.isInteger(parsed) && parsed >= 0 && parsed < originalList.length
      ? normalizeSpace(originalList[parsed])
      : "";

  if (correctTextFromOriginal) {
    const foundByText = sanitizedOptions.findIndex((option) => option === correctTextFromOriginal);
    if (foundByText >= 0) {
      return foundByText;
    }
  }

  if (Number.isInteger(parsed) && parsed >= 0 && parsed < sanitizedOptions.length) {
    return parsed;
  }

  return 0;
}

function ensureVariantOptions(options, correctAnswer, category) {
  const safeOptions = sanitizeOptionsList(options);
  const correct = normalizeSpace(correctAnswer);
  const finalOptions = safeOptions.slice();

  if (correct && !finalOptions.includes(correct)) {
    finalOptions.unshift(correct);
  }

  const categoryPool = CATEGORY_DISTRACTOR_FALLBACKS[category] || CATEGORY_DISTRACTOR_FALLBACKS["פעילות ציבורית"];
  for (let i = 0; i < categoryPool.length && finalOptions.length < 4; i += 1) {
    const candidate = normalizeSpace(categoryPool[i]);
    if (!candidate || finalOptions.includes(candidate)) {
      continue;
    }
    finalOptions.push(candidate);
  }

  while (finalOptions.length < 4) {
    finalOptions.push(`חלופה עניינית ${finalOptions.length + 1}`);
  }

  return finalOptions;
}

function buildSingleQuestionVariant(questionText, prefixText) {
  const normalizedQuestion = String(questionText || "")
    .replace(/\s+/g, " ")
    .replace(/^[\s"“”']+|[\s"“”']+$/g, "")
    .trim();
  if (!normalizedQuestion) {
    return "מה הייתה עמדת התנועה במקרה המתואר?";
  }

  const withQuestionMark = /[?؟]$/.test(normalizedQuestion)
    ? normalizedQuestion
    : `${normalizedQuestion}?`;
  const prefix = String(prefixText || "").trim();
  if (!prefix) {
    return withQuestionMark;
  }

  return `${prefix} ${withQuestionMark}`.replace(/\s+/g, " ").trim();
}

function buildTelemarketingActivityQuestionPools() {
  const output = {};
  TELEMARKETING_ACTIVITY_TOPIC_CONFIGS.forEach((topicConfig) => {
    const sourceFacts = TELEMARKETING_ACTIVITY_SOURCE_FACTS[topicConfig.id];
    if (Array.isArray(sourceFacts) && sourceFacts.length >= 8) {
      output[topicConfig.id] = buildSourceBackedTopicQuestions(topicConfig, sourceFacts, 30);
      return;
    }
    output[topicConfig.id] = buildGeneratedTopicQuestions(topicConfig, 30);
  });
  return output;
}

function buildSourceBackedTopicQuestions(config, sourceFactsInput, totalQuestions) {
  const sourceFacts = Array.isArray(sourceFactsInput) ? sourceFactsInput : [];
  const count = Math.max(1, Number(totalQuestions) || 1);
  const topicTitle = normalizeSpace(config?.shortTitle || config?.title || "הנושא");
  const learnText = normalizeSpace(config?.learn) || `רקע לנושא: ${topicTitle}`;
  const baseCategory = normalizeSpace(config?.category) || "פעילות ציבורית";
  const baseKind = normalizeSpace(config?.kind) || "activity";
  const baseDate = normalizeSpace(config?.date) || "2026-02-09";
  const idPrefix = normalizeSpace(config?.id) || "topic";
  const safeFacts = sourceFacts
    .map((item) => ({
      fact: normalizeSpace(item?.fact),
      sourceLabel: normalizeSpace(item?.sourceLabel) || "מקור",
      canonicalUrl: normalizeSpace(item?.canonicalUrl),
      sourceQuery: normalizeSpace(item?.sourceQuery),
      anchorText: trimForTextFragment(normalizeSpace(item?.anchorText) || normalizeSpace(item?.fact)),
    }))
    .filter((item) => item.fact);

  if (safeFacts.length < 4) {
    return buildGeneratedTopicQuestions(config, count);
  }

  const rows = [];
  for (let i = 0; i < count; i += 1) {
    const factRow = safeFacts[i % safeFacts.length];
    const promptTemplate = SOURCE_BACKED_TOPIC_PROMPTS[i % SOURCE_BACKED_TOPIC_PROMPTS.length];
    const question = promptTemplate.replace("{topic}", topicTitle);
    const correct = factRow.fact;
    const distractors = buildSourceBackedQuestionDistractors(correct, safeFacts, i);
    const options = shuffleArray([correct, ...distractors]).slice(0, 4);
    const answer = options.indexOf(correct);

    if (answer < 0) {
      continue;
    }

    rows.push({
      id: `${idPrefix}_src_${String(i + 1).padStart(2, "0")}`,
      category: baseCategory,
      kind: baseKind,
      date: baseDate,
      learn: learnText,
      question,
      options,
      answer,
      explanation: `${correct} זו הקביעה שמופיעה במקור שעליו מבוססת השאלה.`,
      sources: [
        {
          label: factRow.sourceLabel,
          url: factRow.canonicalUrl || buildMqgSearchUrl(factRow.sourceQuery || factRow.sourceLabel),
          anchorText: factRow.anchorText,
        },
      ],
    });
  }

  return rows;
}

function buildSourceBackedQuestionDistractors(correctFact, sourceFacts, indexSeed) {
  const unique = new Set();
  const output = [];
  const factsPool = sourceFacts
    .map((item) => normalizeSpace(item?.fact))
    .filter((item) => item && item !== correctFact);

  for (let i = 0; i < factsPool.length && output.length < 3; i += 1) {
    const candidate = factsPool[(indexSeed + i * 3) % factsPool.length];
    const safe = normalizeSpace(candidate);
    if (!safe) {
      continue;
    }
    const key = safe.toLowerCase();
    if (unique.has(key)) {
      continue;
    }
    unique.add(key);
    output.push(safe);
  }

  while (output.length < 3) {
    output.push(`האפשרות הזו אינה נתמכת במקור (${output.length + 1}).`);
  }

  return output.slice(0, 3);
}

function buildGeneratedTopicQuestions(config, totalQuestions) {
  const count = Math.max(1, Number(totalQuestions) || 1);
  const facts = (config?.facts || []).map((item) => normalizeSpace(item)).filter(Boolean);
  const distractorPool = (config?.distractors || []).map((item) => normalizeSpace(item)).filter(Boolean);
  const stems = GENERATED_TOPIC_STEMS.slice();
  const topicTitle = normalizeSpace(config?.shortTitle || config?.title || "הנושא");
  const learnText = normalizeSpace(config?.learn) || `רקע לנושא: ${topicTitle}`;
  const baseCategory = normalizeSpace(config?.category) || "פעילות ציבורית";
  const baseKind = normalizeSpace(config?.kind) || "activity";
  const baseDate = normalizeSpace(config?.date) || "2026-02-09";
  const idPrefix = normalizeSpace(config?.id) || "topic";

  if (facts.length < 4) {
    return [];
  }

  const rows = [];
  for (let i = 0; i < count; i += 1) {
    const fact = facts[i % facts.length];
    const stem = stems[i % stems.length];
    const question = `${stem.replace("{topic}", topicTitle)} (שאלה ממוקדת ${i + 1})`;
    const options = buildGeneratedQuestionOptions(fact, facts, distractorPool, i);
    const answer = options.indexOf(fact);
    if (answer < 0) {
      continue;
    }

    rows.push({
      id: `${idPrefix}_${String(i + 1).padStart(2, "0")}`,
      category: baseCategory,
      kind: baseKind,
      date: baseDate,
      learn: learnText,
      question,
      options,
      answer,
      explanation: `${fact} זהו הדגש המרכזי שנדרש לזכור בנושא ${topicTitle}.`,
      sources: [],
    });
  }

  return rows;
}

function buildGeneratedQuestionOptions(correctFact, facts, distractorPool, indexSeed) {
  const uniqueSource = new Set();
  const combined = [...distractorPool, ...facts];
  combined.forEach((item) => {
    const safe = normalizeSpace(item);
    if (!safe || safe === correctFact) {
      return;
    }
    uniqueSource.add(safe);
  });

  const fallback = Array.from(uniqueSource);
  const distractors = [];
  for (let i = 0; i < fallback.length && distractors.length < 3; i += 1) {
    const target = fallback[(indexSeed + i * 3) % fallback.length];
    if (!target || distractors.includes(target)) {
      continue;
    }
    distractors.push(target);
  }

  while (distractors.length < 3) {
    distractors.push(`הניסוח הזה לא מייצג את העמדה המרכזית (${distractors.length + 1}).`);
  }

  const withCorrect = [correctFact, ...distractors.slice(0, 3)];
  const rotation = indexSeed % withCorrect.length;
  return withCorrect.map((_, idx) => withCorrect[(idx + rotation) % withCorrect.length]);
}

function normalizeEntryDepartment(value) {
  const safe = normalizeSpace(value).toLowerCase();
  if (safe === ENTRY_DEPARTMENTS.EDUCATION || safe.includes("education")) {
    return ENTRY_DEPARTMENTS.EDUCATION;
  }
  if (safe === ENTRY_DEPARTMENTS.TELEMARKETING || safe.includes("telemarketing")) {
    return ENTRY_DEPARTMENTS.TELEMARKETING;
  }
  return "";
}

function normalizeQuickMode(value) {
  const safe = normalizeSpace(value).toLowerCase();
  if (safe === QUICK_MODES.SEASONAL) {
    return QUICK_MODES.SEASONAL;
  }
  if (safe === QUICK_MODES.ACTIVITY) {
    return QUICK_MODES.ACTIVITY;
  }
  return QUICK_MODES.REGULAR;
}

function normalizeActivityTopicId(value) {
  const safe = normalizeSpace(value).toLowerCase();
  if (TELEMARKETING_ACTIVITY_TOPIC_BY_ID[safe]) {
    return safe;
  }
  return TELEMARKETING_ACTIVITY_TOPICS[0]?.id || "oct7";
}

function getPlayableQuestions() {
  const { activeQuestions } = getQuestionInventory();
  return activeQuestions.filter((question) => {
    if (!question.date) {
      return false;
    }

    if (question.date >= MIN_CONTENT_DATE) {
      return true;
    }

    return question.kind === "success" || question.allowLegacySuccess === true;
  });
}

function getSeasonalPlayableQuestions() {
  return getPlayableQuestions().filter((question) => question.date >= SEASONAL_MIN_DATE);
}

function getEducationDepartmentQuestions() {
  return EDUCATION_DEPARTMENT_QUESTIONS.slice();
}

function getTelemarketingActivityQuestions(topicId) {
  const safeTopic = normalizeActivityTopicId(topicId);
  const rows = TELEMARKETING_ACTIVITY_QUESTIONS_BY_TOPIC[safeTopic];
  return Array.isArray(rows) ? rows.slice() : [];
}

function getCurrentActivityTopicId() {
  return normalizeActivityTopicId(dom.activityTopicSelect?.value || gameState.activityTopic);
}

function getGameQuestionPoolByContext() {
  const department = normalizeEntryDepartment(gameState.entryDepartment);
  const quickMode = normalizeQuickMode(gameState.quickMode);

  if (department === ENTRY_DEPARTMENTS.EDUCATION) {
    return getEducationDepartmentQuestions();
  }

  if (quickMode === QUICK_MODES.ACTIVITY) {
    return getTelemarketingActivityQuestions(getCurrentActivityTopicId());
  }

  if (quickMode === QUICK_MODES.SEASONAL) {
    return getSeasonalPlayableQuestions();
  }

  return getPlayableQuestions();
}

function buildCycleScopeKey() {
  const department = normalizeEntryDepartment(gameState.entryDepartment) || ENTRY_DEPARTMENTS.TELEMARKETING;
  const quickMode = normalizeQuickMode(gameState.quickMode);
  if (department === ENTRY_DEPARTMENTS.EDUCATION) {
    return "education_regular";
  }
  if (quickMode === QUICK_MODES.ACTIVITY) {
    return `telemarketing_activity_${getCurrentActivityTopicId()}`;
  }
  if (quickMode === QUICK_MODES.SEASONAL) {
    return "telemarketing_seasonal";
  }
  return "telemarketing_regular";
}

function normalizePlayerKey(value) {
  return normalizeSpace(value).toLowerCase();
}

function aggregateCategoryStats(targetMap, categoryStats) {
  if (!categoryStats || typeof categoryStats !== "object") {
    return;
  }
  Object.entries(categoryStats).forEach(([category, stat]) => {
    const safeCategory = normalizeSpace(category) || "ללא קטגוריה";
    const total = Math.max(0, Number(stat?.total || 0));
    if (!total) {
      return;
    }
    const correct = clampNumber(Number(stat?.correct || 0), 0, total);
    const timeouts = clampNumber(Number(stat?.timeouts || 0), 0, total);
    const wrong = Math.max(0, total - correct);
    if (!targetMap.has(safeCategory)) {
      targetMap.set(safeCategory, { total: 0, correct: 0, wrong: 0, timeouts: 0 });
    }
    const current = targetMap.get(safeCategory);
    current.total += total;
    current.correct += correct;
    current.wrong += wrong;
    current.timeouts += timeouts;
  });
}

function aggregateFamilyStatsFromAttempt(targetMap, questionStats) {
  if (!questionStats || typeof questionStats !== "object") {
    return;
  }
  const entries = Array.isArray(questionStats) ? questionStats : Object.values(questionStats);
  entries.forEach((entry) => {
    const questionId = normalizeSpace(entry?.questionId || entry?.id);
    if (!questionId) {
      return;
    }
    const familyKey = getQuestionFamilyKey({ id: questionId, question: entry?.questionText });
    const total = Math.max(0, Number(entry?.total || 0));
    if (!total) {
      return;
    }
    const correct = clampNumber(Number(entry?.correct || 0), 0, total);
    const wrong = clampNumber(Number(entry?.wrong || Math.max(0, total - correct)), 0, total);
    const timeouts = clampNumber(Number(entry?.timeouts || 0), 0, total);
    if (!targetMap.has(familyKey)) {
      targetMap.set(familyKey, { total: 0, correct: 0, wrong: 0, timeouts: 0 });
    }
    const current = targetMap.get(familyKey);
    current.total += total;
    current.correct += correct;
    current.wrong += wrong;
    current.timeouts += timeouts;
  });
}

function buildPlayerAdaptiveProfile(playerAttempts) {
  const safeAttempts = Array.isArray(playerAttempts) ? playerAttempts : [];
  const categoryStats = new Map();
  const familyStats = new Map();

  safeAttempts.forEach((attempt) => {
    aggregateCategoryStats(categoryStats, attempt?.categoryStats);
    aggregateFamilyStatsFromAttempt(familyStats, attempt?.questionStats);
  });

  return {
    categoryStats,
    familyStats,
  };
}

function buildAdaptiveScoresForPool(questionPool, profile) {
  const output = new Map();
  if (!profile || !Array.isArray(questionPool)) {
    return output;
  }

  questionPool.forEach((question) => {
    const questionId = normalizeSpace(question?.id);
    if (!questionId) {
      return;
    }

    const familyKey = getQuestionFamilyKey(question);
    const categoryKey = normalizeSpace(question?.category) || "ללא קטגוריה";
    const family = profile.familyStats.get(familyKey);
    const category = profile.categoryStats.get(categoryKey);
    let adaptiveScore = 1;

    if (family?.total >= 1) {
      const familyFailRate = Math.max(0, family.wrong + family.timeouts) / family.total;
      const familyTimeoutRate = Math.max(0, family.timeouts) / family.total;
      const familyGap = Math.max(0, 1 - family.correct / family.total);
      adaptiveScore += familyFailRate * 2.8 + familyTimeoutRate * 1.7 + familyGap * 1.2;
      adaptiveScore += Math.min(0.45, family.total * 0.05);
    }

    if (category?.total >= 2) {
      const categoryFailRate = Math.max(0, category.wrong) / category.total;
      const categoryTimeoutRate = Math.max(0, category.timeouts) / category.total;
      adaptiveScore += categoryFailRate * 1.35 + categoryTimeoutRate * 0.9;
    }

    output.set(questionId, Number(adaptiveScore.toFixed(4)));
  });

  return output;
}

function readPlayerSpacedMemoryRecords(playerName) {
  const playerKey = normalizePlayerKey(playerName);
  if (!playerKey) {
    return {};
  }
  const store = readObjectStorage(STORAGE_KEYS.playerSpacedMemory, {});
  const records = store[playerKey];
  return records && typeof records === "object" ? records : {};
}

function writePlayerSpacedMemoryRecords(playerName, records) {
  const playerKey = normalizePlayerKey(playerName);
  if (!playerKey) {
    return false;
  }
  const store = readObjectStorage(STORAGE_KEYS.playerSpacedMemory, {});
  store[playerKey] = records && typeof records === "object" ? records : {};
  return writeStorage(STORAGE_KEYS.playerSpacedMemory, store);
}

function scoreSpacedReviewQuality(payload) {
  const isCorrect = Boolean(payload?.isCorrect);
  const timedOut = Boolean(payload?.timedOut);
  const elapsedSeconds = Number(payload?.elapsedSeconds || 0);
  if (timedOut) {
    return 0;
  }
  if (!isCorrect) {
    return 2;
  }
  if (elapsedSeconds <= 6) {
    return 5;
  }
  if (elapsedSeconds <= 14) {
    return 4;
  }
  return 3;
}

function updatePlayerSpacedMemory(playerName, question, payload = {}) {
  const playerKey = normalizePlayerKey(playerName);
  const familyKey = getQuestionFamilyKey(question);
  if (!playerKey || !familyKey) {
    return;
  }

  const nowTs = Date.now();
  const nowIso = new Date(nowTs).toISOString();
  const records = readPlayerSpacedMemoryRecords(playerKey);
  const current = records[familyKey] && typeof records[familyKey] === "object"
    ? records[familyKey]
    : {
      repetition: 0,
      intervalDays: 0,
      easiness: 2.5,
      dueAt: nowIso,
      successStreak: 0,
      lapses: 0,
      totalReviews: 0,
      avgElapsedSec: 0,
      lastQuality: 0,
      lastReviewedAt: nowIso,
    };

  const quality = scoreSpacedReviewQuality(payload);
  const prevIntervalDays = Math.max(0, Number(current.intervalDays || 0));
  const prevEasiness = Math.max(1.3, Number(current.easiness || 2.5));
  const prevRepetition = Math.max(0, Number(current.repetition || 0));
  const totalReviews = Number(current.totalReviews || 0) + 1;
  const elapsedSeconds = Math.max(0, Number(payload?.elapsedSeconds || 0));
  const nextAvgElapsedSec = Number(
    ((Number(current.avgElapsedSec || 0) * (totalReviews - 1) + elapsedSeconds) / totalReviews).toFixed(2),
  );

  let nextRepetition = 0;
  let nextIntervalDays = 1;
  let nextSuccessStreak = 0;
  let nextLapses = Number(current.lapses || 0);

  if (quality >= 3) {
    nextRepetition = prevRepetition + 1;
    nextSuccessStreak = Number(current.successStreak || 0) + 1;
    if (nextRepetition === 1) {
      nextIntervalDays = 1;
    } else if (nextRepetition === 2) {
      nextIntervalDays = 3;
    } else {
      nextIntervalDays = Math.min(90, Math.max(4, Math.round(prevIntervalDays * prevEasiness)));
    }
  } else {
    nextRepetition = 0;
    nextSuccessStreak = 0;
    nextIntervalDays = 1;
    nextLapses += 1;
  }

  const easinessDelta = 0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02);
  const nextEasiness = Math.max(1.3, Number((prevEasiness + easinessDelta).toFixed(4)));
  const dueAtTs = nowTs + nextIntervalDays * 24 * 60 * 60 * 1000;

  records[familyKey] = {
    repetition: nextRepetition,
    intervalDays: nextIntervalDays,
    easiness: nextEasiness,
    dueAt: new Date(dueAtTs).toISOString(),
    successStreak: nextSuccessStreak,
    lapses: nextLapses,
    totalReviews,
    avgElapsedSec: nextAvgElapsedSec,
    lastQuality: quality,
    lastReviewedAt: nowIso,
  };

  writePlayerSpacedMemoryRecords(playerKey, records);
}

function buildSpacedRepetitionScoresForPool(playerName, questionPool) {
  const output = new Map();
  const playerRecords = readPlayerSpacedMemoryRecords(playerName);
  const nowTs = Date.now();

  (questionPool || []).forEach((question) => {
    const questionId = normalizeSpace(question?.id);
    if (!questionId) {
      return;
    }
    const familyKey = getQuestionFamilyKey(question);
    const memory = playerRecords[familyKey];
    if (!memory || typeof memory !== "object") {
      output.set(questionId, 1);
      return;
    }

    const dueAtTs = Date.parse(memory.dueAt || "");
    if (!Number.isFinite(dueAtTs)) {
      output.set(questionId, 1);
      return;
    }

    const diffMs = dueAtTs - nowTs;
    let score = 1;
    if (diffMs <= 0) {
      const overdueDays = Math.max(0, Math.abs(diffMs) / (24 * 60 * 60 * 1000));
      score += SPACED_REPETITION_SETTINGS.minDueBoost + overdueDays * SPACED_REPETITION_SETTINGS.overdueBoostPerDay;
    } else {
      const diffDays = diffMs / (24 * 60 * 60 * 1000);
      if (diffDays <= SPACED_REPETITION_SETTINGS.dueSoonWindowDays) {
        score += SPACED_REPETITION_SETTINGS.dueSoonBoost
          * (1 - diffDays / SPACED_REPETITION_SETTINGS.dueSoonWindowDays);
      } else {
        score -= 0.08;
      }
    }

    const lapsesBoost = Math.min(0.45, Number(memory.lapses || 0) * 0.06);
    score += lapsesBoost;
    output.set(questionId, Number(Math.max(0.85, score).toFixed(4)));
  });

  return output;
}

function buildPlayerAdaptiveSelectionOptions(playerName, questionPool) {
  const playerKey = normalizePlayerKey(playerName);
  if (!playerKey || !Array.isArray(questionPool) || !questionPool.length) {
    return { strategy: "random" };
  }

  const attempts = readStorage(STORAGE_KEYS.attempts, []);
  const playerAttempts = attempts.filter(
    (attempt) => normalizePlayerKey(attempt?.playerName) === playerKey,
  );
  if (playerAttempts.length < ADAPTIVE_PLAYER_MIN_ATTEMPTS) {
    return { strategy: "random" };
  }

  const profile = buildPlayerAdaptiveProfile(playerAttempts);
  const adaptiveScores = buildAdaptiveScoresForPool(questionPool, profile);
  const spacedScores = buildSpacedRepetitionScoresForPool(playerName, questionPool);
  const combinedScores = new Map();
  questionPool.forEach((question) => {
    const questionId = normalizeSpace(question?.id);
    if (!questionId) {
      return;
    }
    const adaptive = Number(adaptiveScores.get(questionId) || 1);
    const spaced = Number(spacedScores.get(questionId) || 1);
    const combined = adaptive + Math.max(0, spaced - 1) * 1.25;
    combinedScores.set(questionId, Number(combined.toFixed(4)));
  });

  const adaptiveSignalCount = Array.from(adaptiveScores.values()).filter(
    (score) => Number(score) >= ADAPTIVE_SCORE_MIN_SIGNAL,
  ).length;
  const spacedSignalCount = Array.from(spacedScores.values()).filter(
    (score) => Number(score) > 1.1,
  ).length;
  const signalCount = Array.from(combinedScores.values()).filter(
    (score) => Number(score) >= ADAPTIVE_SCORE_MIN_SIGNAL,
  ).length;
  if (!signalCount && !spacedSignalCount) {
    return { strategy: "random" };
  }

  const confidence = Math.min(
    100,
    Math.round(
      (signalCount / Math.max(1, questionPool.length)) * 60
      + Math.min(20, playerAttempts.length * 4)
      + Math.min(20, spacedSignalCount * 2),
    ),
  );

  return {
    strategy: "adaptive",
    adaptiveScores: combinedScores,
    confidence,
    matchedSignals: signalCount + spacedSignalCount + adaptiveSignalCount,
  };
}

function updateLandingModeCards() {
  const department = normalizeEntryDepartment(gameState.entryDepartment);
  if (dom.entryModesWrap) {
    dom.entryModesWrap.classList.toggle("hidden", !department);
  }
  if (dom.entryDepartmentState) {
    if (!department) {
      dom.entryDepartmentState.textContent = "בחר אגף כדי להמשיך לבחירת סוג משחק.";
    } else if (department === ENTRY_DEPARTMENTS.EDUCATION) {
      dom.entryDepartmentState.textContent = "נבחר אגף חינוך. זמין כעת: משחק מהיר ייעודי.";
    } else {
      dom.entryDepartmentState.textContent = "נבחר טלמרקטינג. זמינים: מהיר, עונתי, ומשחק על פי פעילות.";
    }
  }
  if (dom.entrySeasonalCard) {
    dom.entrySeasonalCard.classList.toggle("hidden", department === ENTRY_DEPARTMENTS.EDUCATION);
  }
  if (dom.entryActivityCard) {
    dom.entryActivityCard.classList.toggle("hidden", department === ENTRY_DEPARTMENTS.EDUCATION);
  }
  if (dom.entryTelemarketingCard) {
    dom.entryTelemarketingCard.classList.toggle("selected", department === ENTRY_DEPARTMENTS.TELEMARKETING);
  }
  if (dom.entryEducationCard) {
    dom.entryEducationCard.classList.toggle("selected", department === ENTRY_DEPARTMENTS.EDUCATION);
  }
  if (dom.goQuickBtn) {
    dom.goQuickBtn.textContent = department === ENTRY_DEPARTMENTS.EDUCATION
      ? "למשחק מהיר - אגף חינוך"
      : "למשחק מהיר";
  }
}

function setEntryDepartment(department) {
  const nextDepartment = normalizeEntryDepartment(department);
  gameState.entryDepartment = nextDepartment;
  if (dom.entryDepartmentMsg) {
    hideMessage(dom.entryDepartmentMsg);
  }
  if (nextDepartment === ENTRY_DEPARTMENTS.EDUCATION && normalizeQuickMode(gameState.quickMode) !== QUICK_MODES.REGULAR) {
    gameState.quickMode = QUICK_MODES.REGULAR;
  }
  updateLandingModeCards();
  setQuickMode(gameState.quickMode);
}

function openQuickSetupByMode(mode) {
  const department = normalizeEntryDepartment(gameState.entryDepartment);
  if (!department) {
    showMessage(dom.entryDepartmentMsg, "יש לבחור קודם אגף (טלמרקטינג או אגף חינוך).", false);
    return;
  }

  const quickMode = normalizeQuickMode(mode);
  if (department === ENTRY_DEPARTMENTS.EDUCATION && quickMode !== QUICK_MODES.REGULAR) {
    showMessage(dom.entryDepartmentMsg, "באגף חינוך זמין כרגע משחק מהיר ייעודי.", false);
    return;
  }

  hideMessage(dom.entryDepartmentMsg);
  hideMessage(dom.quickSetupError);
  hideMessage(dom.questionCycleResetMsg);
  setQuickMode(quickMode);
  showScreen("screenQuickSetup");
}

function setQuickMode(mode) {
  gameState.quickMode = normalizeQuickMode(mode);
  const department = normalizeEntryDepartment(gameState.entryDepartment);

  if (dom.quickSetupTitle) {
    if (department === ENTRY_DEPARTMENTS.EDUCATION) {
      dom.quickSetupTitle.textContent = "משחק מהיר - אגף חינוך";
    } else if (gameState.quickMode === QUICK_MODES.SEASONAL) {
      dom.quickSetupTitle.textContent = "משחק מהיר עונתי - טלמרקטינג";
    } else if (gameState.quickMode === QUICK_MODES.ACTIVITY) {
      dom.quickSetupTitle.textContent = "משחק על פי פעילות - טלמרקטינג";
    } else {
      dom.quickSetupTitle.textContent = "משחק מהיר - טלמרקטינג";
    }
  }

  if (dom.activityTopicField) {
    dom.activityTopicField.classList.toggle("hidden", gameState.quickMode !== QUICK_MODES.ACTIVITY);
  }

  if (gameState.quickMode === QUICK_MODES.ACTIVITY) {
    const safeTopic = getCurrentActivityTopicId();
    gameState.activityTopic = safeTopic;
    if (dom.activityTopicSelect) {
      dom.activityTopicSelect.value = safeTopic;
    }
    if (dom.questionCountSelect) {
      dom.questionCountSelect.value = "30";
    }
    dom.quickModeNote.textContent = `מצב פעילות ממוקד: ${TELEMARKETING_ACTIVITY_TOPIC_BY_ID[safeTopic]?.title || ""}.`;
    return;
  }

  if (department === ENTRY_DEPARTMENTS.EDUCATION) {
    dom.quickModeNote.textContent = "מצב אגף חינוך: מאגר שאלות ייעודי לאגף החינוך.";
    return;
  }

  if (gameState.quickMode === QUICK_MODES.SEASONAL) {
    dom.quickModeNote.textContent = "מצב עונתי: רק שאלות מאוקטובר 2025 ומעלה.";
  } else {
    dom.quickModeNote.textContent = "מצב רגיל: כלל המאגר הפעיל (2025+ והישגים מאושרים).";
  }
}

function resolveBackendConfig() {
  const incoming =
    typeof window !== "undefined" && window.MQG_BACKEND_CONFIG && typeof window.MQG_BACKEND_CONFIG === "object"
      ? window.MQG_BACKEND_CONFIG
      : {};
  const merged = {
    ...BACKEND_DEFAULT_CONFIG,
    ...incoming,
  };
  merged.enabled = Boolean(merged.enabled && normalizeSpace(merged.baseUrl));
  merged.baseUrl = normalizeSpace(merged.baseUrl).replace(/\/+$/, "");
  merged.syncIntervalMs = Math.max(5000, Number(merged.syncIntervalMs) || BACKEND_DEFAULT_CONFIG.syncIntervalMs);
  merged.publicWriteKey = normalizeSpace(merged.publicWriteKey);
  merged.allowInsecureLocalFallback = Boolean(merged.allowInsecureLocalFallback);
  return merged;
}

function isBackendEnabled() {
  return Boolean(backendConfig.enabled && backendConfig.baseUrl);
}

async function apiRequest(path, options = {}) {
  const baseUrl = backendConfig.baseUrl;
  if (!baseUrl) {
    throw new Error("BACKEND_NOT_CONFIGURED");
  }

  const headers = {
    "Content-Type": "application/json",
    ...(options.headers || {}),
  };

  const response = await fetch(`${baseUrl}${path}`, {
    method: options.method || "GET",
    headers,
    credentials: "include",
    body: options.body ? JSON.stringify(options.body) : undefined,
  });

  const payload = await response.json().catch(() => ({}));
  if (!response.ok || payload?.ok === false) {
    const msg = normalizeSpace(payload?.error || payload?.message) || `HTTP_${response.status}`;
    throw new Error(msg);
  }

  return payload;
}

async function loginWithBackend(username, password) {
  const payload = await apiRequest("/api/auth/login", {
    method: "POST",
    body: { username, password },
  });
  return payload;
}

async function logoutFromBackend() {
  await apiRequest("/api/auth/logout", {
    method: "POST",
  }).catch(() => {});
}

async function changeOwnBackendPassword(currentPassword, newPassword) {
  await apiRequest("/api/auth/password", {
    method: "PATCH",
    body: { currentPassword, newPassword },
  });
}

async function fetchBackendAdmins() {
  const payload = await apiRequest("/api/admins");
  return Array.isArray(payload?.admins) ? payload.admins : [];
}

async function createBackendAdmin(username, password) {
  const payload = await apiRequest("/api/admins", {
    method: "POST",
    body: { username, password },
  });
  return Array.isArray(payload?.admins) ? payload.admins : [];
}

async function deleteBackendAdmin(adminId) {
  const payload = await apiRequest(`/api/admins/${encodeURIComponent(String(adminId || ""))}`, {
    method: "DELETE",
  });
  return Array.isArray(payload?.admins) ? payload.admins : [];
}

async function fetchBackendStateSnapshot() {
  const payload = await apiRequest("/api/state");
  return payload?.state && typeof payload.state === "object" ? payload.state : {};
}

async function upsertBackendStateKey(key, value) {
  await apiRequest(`/api/state/${encodeURIComponent(String(key || ""))}`, {
    method: "PUT",
    body: { value },
  });
}

async function pushPublicAttemptToBackend(attempt) {
  if (!isBackendEnabled() || !backendConfig.publicWriteKey || adminState.currentAdmin?.id) {
    return;
  }

  try {
    await fetch(`${backendConfig.baseUrl}/api/public/attempt`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-public-key": backendConfig.publicWriteKey,
      },
      body: JSON.stringify({ attempt }),
    });
  } catch (_err) {
    // ignore temporary network issues for public attempt logging
  }
}

async function hydrateFromBackendState() {
  if (!isBackendEnabled() || !adminState.currentAdmin?.id) {
    return;
  }

  adminState.isHydratingRemote = true;
  try {
    const snapshot = await fetchBackendStateSnapshot();
    REMOTE_SYNCABLE_KEYS.forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(snapshot, key)) {
        return;
      }
      writeStorage(key, snapshot[key]);
    });

    const backendAdmins = await fetchBackendAdmins().catch(() => []);
    if (backendAdmins.length) {
      writeStorage(STORAGE_KEYS.adminUsers, backendAdmins.map((item) => ({
        id: item.id,
        username: item.username,
        role: normalizeAdminRole(item.role),
        createdAt: item.createdAt || new Date().toISOString(),
        createdBy: item.createdBy || "remote",
      })));
    }
  } finally {
    adminState.isHydratingRemote = false;
  }
}

async function runRemoteSyncPull() {
  if (!isBackendEnabled() || !adminState.currentAdmin?.id || adminState.syncInFlight) {
    return;
  }

  adminState.syncInFlight = true;
  try {
    await hydrateFromBackendState();
    renderAdminStats();
    renderAttemptsTable();
    renderLearningMetrics();
    renderActivities();
    renderDrafts();
    renderCustomQuestions();
    renderAllQuestionsManager();
    renderAdminUsers();
    renderLongTextDraftsPreview();
  } catch (_err) {
    // ignore temporary sync errors
  } finally {
    adminState.syncInFlight = false;
  }
}

function startRemoteSyncLoop() {
  if (!isBackendEnabled() || !adminState.currentAdmin?.id) {
    return;
  }
  stopRemoteSyncLoop();
  adminState.syncTimerId = window.setInterval(() => {
    runRemoteSyncPull();
  }, backendConfig.syncIntervalMs);
}

function stopRemoteSyncLoop() {
  if (adminState.syncTimerId) {
    window.clearInterval(adminState.syncTimerId);
    adminState.syncTimerId = null;
  }
}

function queueRemoteStateSync(key, value) {
  if (!isBackendEnabled() || !adminState.currentAdmin?.id) {
    return;
  }
  if (adminState.isHydratingRemote) {
    return;
  }
  if (!REMOTE_SYNCABLE_KEYS.includes(key)) {
    return;
  }
  upsertBackendStateKey(key, value).catch(() => {});
}

async function refreshAdminUsersFromBackend() {
  if (!isBackendEnabled() || !adminState.currentAdmin?.id) {
    return;
  }

  const admins = await fetchBackendAdmins();
  const normalized = admins.map((item) => ({
    id: item.id,
    username: item.username,
    role: normalizeAdminRole(item.role),
    createdAt: item.createdAt || new Date().toISOString(),
    createdBy: item.createdBy || "remote",
  }));
  writeStorage(STORAGE_KEYS.adminUsers, normalized);
}

function normalizeAdminTab(value) {
  const raw = normalizeSpace(value).toLowerCase();
  if (raw === "content") {
    return "content";
  }
  if (raw === "questionbank") {
    return "questionBank";
  }
  if (raw === "learning") {
    return "learning";
  }
  if (raw === "security") {
    return "security";
  }
  return "dashboard";
}

function setAdminTab(tab) {
  const nextTab = normalizeAdminTab(tab);
  adminState.tab = nextTab;
  adminState.mode = nextTab === "questionBank" ? "questionBank" : "main";

  dom.adminTabButtons.forEach((button) => {
    const isActive = normalizeSpace(button.dataset.adminTabTarget) === nextTab;
    button.classList.toggle("active", isActive);
    button.setAttribute("aria-selected", isActive ? "true" : "false");
    button.tabIndex = isActive ? 0 : -1;
  });

  dom.adminTabPanels.forEach((panel) => {
    const isActive = normalizeSpace(panel.dataset.adminTabPanel) === nextTab;
    panel.classList.toggle("hidden", !isActive);
    panel.setAttribute("aria-hidden", isActive ? "false" : "true");
  });

  if (nextTab === "questionBank") {
    renderAllQuestionsManager();
    renderQuestionAuditReport();
  }
}

function setAdminMode(mode) {
  const nextTab = mode === "questionBank" ? "questionBank" : "dashboard";
  setAdminTab(nextTab);
}

function explainSystemCheckError(err) {
  const message = normalizeSpace(err?.message).toLowerCase();
  if (!message) {
    return "שגיאת חיבור לא מזוהה.";
  }
  if (
    message.includes("failed to fetch")
    || message.includes("networkerror")
    || message.includes("load failed")
  ) {
    return "הבקשה לא הושלמה. ייתכן CORS/DNS/זמינות backend.";
  }
  if (message.includes("cors")) {
    return "ה-Origin הנוכחי לא מאושר ב-CORS_ORIGIN.";
  }
  return normalizeSpace(err?.message);
}

function createSystemCheckItem(label, state, detail) {
  return {
    label: normalizeSpace(label),
    state: normalizeSpace(state).toLowerCase(),
    detail: normalizeSpace(detail),
  };
}

function renderAdminSystemCheck() {
  if (!dom.adminSystemCheckRows || !dom.adminSystemCheckStatus) {
    return;
  }

  const snapshot = adminState.lastSystemCheck;
  dom.adminSystemCheckRows.innerHTML = "";

  if (!snapshot || !Array.isArray(snapshot.items) || snapshot.items.length === 0) {
    dom.adminSystemCheckStatus.textContent = "בדיקה מהירה של backend, session ותצורת חיבור.";
    dom.adminSystemCheckRows.appendChild(makeInfoMessage("טרם בוצעה בדיקה. לחץ על \"בדוק עכשיו\"."));
    return;
  }

  snapshot.items.forEach((item) => {
    const safeState = ["ok", "warn", "bad", "info"].includes(item.state) ? item.state : "info";
    const card = document.createElement("article");
    card.className = "info-card system-check-card";

    const topRow = document.createElement("div");
    topRow.className = "section-head";

    const title = document.createElement("h4");
    title.textContent = item.label || "בדיקה";

    const badge = document.createElement("span");
    badge.className = `badge system-${safeState}`;
    badge.textContent = safeState === "ok"
      ? "תקין"
      : safeState === "warn"
        ? "שים לב"
        : safeState === "bad"
          ? "תקלה"
          : "מידע";

    topRow.appendChild(title);
    topRow.appendChild(badge);

    const detail = document.createElement("p");
    detail.textContent = item.detail || "אין מידע נוסף.";

    card.appendChild(topRow);
    card.appendChild(detail);
    dom.adminSystemCheckRows.appendChild(card);
  });

  const badCount = snapshot.items.filter((item) => item.state === "bad").length;
  const warnCount = snapshot.items.filter((item) => item.state === "warn").length;
  const checkedAt = snapshot.checkedAt ? formatDateTime(snapshot.checkedAt) : "לא ידוע";

  if (badCount > 0) {
    dom.adminSystemCheckStatus.textContent = `זוהו ${badCount} תקלות מערכת. עודכן: ${checkedAt}`;
    return;
  }
  if (warnCount > 0) {
    dom.adminSystemCheckStatus.textContent = `המערכת תקינה חלקית (${warnCount} התראות). עודכן: ${checkedAt}`;
    return;
  }
  dom.adminSystemCheckStatus.textContent = `המערכת תקינה. עודכן: ${checkedAt}`;
}

async function runAdminSystemCheck({ isManual = false } = {}) {
  if (!dom.adminSystemCheckRows || adminState.systemCheckInFlight) {
    return;
  }

  adminState.systemCheckInFlight = true;
  if (dom.adminSystemCheckBtn) {
    dom.adminSystemCheckBtn.disabled = true;
  }
  if (isManual) {
    dom.adminSystemCheckStatus.textContent = "מריץ בדיקה...";
  }

  try {
    const items = [];
    const origin = typeof window !== "undefined" ? normalizeSpace(window.location.origin) : "";
    const baseUrl = normalizeSpace(backendConfig.baseUrl);
    const backendConfigured = Boolean(backendConfig.enabled && baseUrl);

    items.push(createSystemCheckItem(
      "Backend מופעל",
      backendConfigured ? "ok" : "bad",
      backendConfigured
        ? `פעיל מול ${baseUrl}`
        : "config.js לא מוגדר נכון (enabled/baseUrl).",
    ));

    items.push(createSystemCheckItem(
      "Origin נוכחי",
      origin ? "info" : "warn",
      origin || "לא זוהה origin בדפדפן.",
    ));

    if (backendConfigured) {
      const healthStart = Date.now();
      try {
        const healthResponse = await fetch(`${baseUrl}/api/health`, {
          method: "GET",
          headers: { Accept: "application/json" },
          credentials: "omit",
        });
        const latencyMs = Date.now() - healthStart;
        const healthPayload = await healthResponse.json().catch(() => ({}));
        const healthOk = Boolean(healthResponse.ok && healthPayload?.ok);
        if (healthOk) {
          items.push(createSystemCheckItem(
            "Health endpoint",
            "ok",
            `זמין (HTTP ${healthResponse.status}, ${latencyMs}ms).`,
          ));
        } else {
          const errCode = normalizeSpace(healthPayload?.error) || `HTTP_${healthResponse.status}`;
          const state = errCode === "CORS_BLOCKED" ? "bad" : "warn";
          items.push(createSystemCheckItem(
            "Health endpoint",
            state,
            `הוחזר ${errCode} (HTTP ${healthResponse.status}, ${latencyMs}ms).`,
          ));
        }
      } catch (err) {
        items.push(createSystemCheckItem(
          "Health endpoint",
          "bad",
          explainSystemCheckError(err),
        ));
      }

      try {
        const sessionResponse = await fetch(`${baseUrl}/api/auth/session`, {
          method: "GET",
          headers: { Accept: "application/json" },
          credentials: "include",
        });
        const sessionPayload = await sessionResponse.json().catch(() => ({}));
        if (sessionResponse.ok && sessionPayload?.ok) {
          const username = normalizeSpace(sessionPayload?.admin?.username) || "מנהל";
          items.push(createSystemCheckItem(
            "Session מנהל",
            "ok",
            `סשן פעיל כ-${username}.`,
          ));
        } else if (sessionResponse.status === 401) {
          items.push(createSystemCheckItem(
            "Session מנהל",
            "warn",
            "אין סשן פעיל. אם יש ניתוקים, התחבר מחדש.",
          ));
        } else {
          const errCode = normalizeSpace(sessionPayload?.error) || `HTTP_${sessionResponse.status}`;
          const state = errCode === "CORS_BLOCKED" ? "bad" : "warn";
          items.push(createSystemCheckItem(
            "Session מנהל",
            state,
            `הוחזר ${errCode} (HTTP ${sessionResponse.status}).`,
          ));
        }
      } catch (err) {
        items.push(createSystemCheckItem(
          "Session מנהל",
          "warn",
          explainSystemCheckError(err),
        ));
      }
    } else {
      items.push(createSystemCheckItem(
        "Health endpoint",
        "warn",
        "לא נבדק כי backend לא מוגדר.",
      ));
      items.push(createSystemCheckItem(
        "Session מנהל",
        "warn",
        "לא נבדק כי backend לא מוגדר.",
      ));
    }

    items.push(createSystemCheckItem(
      "Public write key",
      backendConfig.publicWriteKey ? "ok" : "warn",
      backendConfig.publicWriteKey
        ? "מוגדר. שמירת ניסיונות ציבוריים זמינה."
        : "לא מוגדר. שמירת ניסיונות ציבוריים לענן תהיה כבויה.",
    ));

    adminState.lastSystemCheck = {
      checkedAt: new Date().toISOString(),
      items,
    };
    renderAdminSystemCheck();
  } finally {
    adminState.systemCheckInFlight = false;
    if (dom.adminSystemCheckBtn) {
      dom.adminSystemCheckBtn.disabled = false;
    }
  }
}

function normalizeAdminUsername(value) {
  return normalizeSpace(value).toLowerCase();
}

function normalizeAdminRole(value) {
  return normalizeSpace(value).toLowerCase() === "owner" ? "owner" : "admin";
}

function sanitizeAdminUser(user) {
  const username = normalizeSpace(user?.username);
  if (!username) {
    return null;
  }

  const role = normalizeAdminRole(user?.role);
  return {
    id: normalizeSpace(user?.id) || uid("admin"),
    username,
    password: String(user?.password || "").trim(),
    role,
    isOwner: role === "owner",
    createdAt: normalizeSpace(user?.createdAt) || new Date().toISOString(),
    createdBy: normalizeSpace(user?.createdBy) || "system",
  };
}

function readAdminUsers() {
  if (isBackendEnabled() && adminState.currentAdmin?.id) {
    const cached = readStorage(STORAGE_KEYS.adminUsers, []);
    if (Array.isArray(cached) && cached.length) {
      return cached.map(sanitizeAdminUser).filter(Boolean);
    }
  }

  const saved = readStorage(STORAGE_KEYS.adminUsers, []);
  const normalized = Array.isArray(saved)
    ? saved.map(sanitizeAdminUser).filter(Boolean)
    : [];

  if (!normalized.length) {
    const seeded = DEFAULT_ADMIN_USERS.map((user) => ({ ...user }));
    writeStorage(STORAGE_KEYS.adminUsers, seeded);
    return seeded;
  }

  if (normalized.length !== saved.length) {
    writeStorage(STORAGE_KEYS.adminUsers, normalized);
  }

  return normalized;
}

function ensureAdminUsersSeeded() {
  readAdminUsers();
}

function authenticateAdminUser(username, password) {
  const safeUsername = normalizeAdminUsername(username);
  const safePassword = String(password || "").trim();
  if (!safeUsername || !safePassword) {
    return null;
  }

  const adminUsers = readAdminUsers();
  return adminUsers.find((user) =>
    normalizeAdminUsername(user.username) === safeUsername
    && user.password
    && String(user.password) === safePassword,
  ) || null;
}

function renderAdminSessionInfo() {
  if (!dom.adminSessionInfo) {
    return;
  }
  if (adminState.currentAdmin?.username) {
    dom.adminSessionInfo.textContent = adminState.currentAdmin?.isOwner
      ? `מחובר כעת: ${adminState.currentAdmin.username} (מנהל ראשי)`
      : `מחובר כעת: ${adminState.currentAdmin.username}`;
    return;
  }
  dom.adminSessionInfo.textContent = "לא זוהה מנהל מחובר.";
}

function renderAdminUsers() {
  if (!dom.adminUsersList) {
    return;
  }

  const adminUsers = readAdminUsers();
  dom.adminUsersList.innerHTML = "";

  adminUsers.forEach((user) => {
    const card = document.createElement("article");
    card.className = "info-card";

    const title = document.createElement("h4");
    title.textContent = `שם משתמש: ${user.username}`;

    const createdLine = document.createElement("p");
    createdLine.className = "muted tight";
    createdLine.textContent =
      `הרשאה: ${user.isOwner ? "מנהל ראשי" : "מנהל"} | ` +
      `נוצר על ידי: ${user.createdBy} | ${formatDateTime(user.createdAt)}`;

    card.appendChild(title);
    card.appendChild(createdLine);

    if (adminUsers.length > 1 && !user.isOwner) {
      const actions = document.createElement("div");
      actions.className = "inline-actions";
      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.className = "ghost-btn";
      removeBtn.textContent = "מחק מנהל";
      removeBtn.addEventListener("click", () => removeAdminUser(user.id));
      actions.appendChild(removeBtn);
      card.appendChild(actions);
    }

    dom.adminUsersList.appendChild(card);
  });
}

async function handleAdminUserCreate(event) {
  event.preventDefault();
  hideMessage(dom.adminUserFormMsg);

  const username = normalizeSpace(dom.adminUserNewUsername.value);
  const password = String(dom.adminUserNewPassword.value || "").trim();

  if (username.length < 2 || password.length < 8) {
    showMessage(dom.adminUserFormMsg, "יש להזין שם משתמש וסיסמה חזקה (לפחות 8 תווים).", false);
    return;
  }

  const adminUsers = readAdminUsers();
  const exists = adminUsers.some((user) => normalizeAdminUsername(user.username) === normalizeAdminUsername(username));
  if (exists) {
    showMessage(dom.adminUserFormMsg, "שם המשתמש כבר קיים. בחר שם אחר.", false);
    return;
  }

  const nextUser = {
    id: uid("admin"),
    username,
    password,
    role: "admin",
    createdAt: new Date().toISOString(),
    createdBy: adminState.currentAdmin?.username || "system",
  };
  if (isBackendEnabled() && adminState.currentAdmin?.id) {
    try {
      const remoteAdmins = await createBackendAdmin(username, password);
      const normalizedRemote = remoteAdmins.map((item) => ({
        id: item.id,
        username: item.username,
        role: normalizeAdminRole(item.role),
        createdAt: item.createdAt || new Date().toISOString(),
        createdBy: item.createdBy || "remote",
      }));
      writeStorage(STORAGE_KEYS.adminUsers, normalizedRemote);
    } catch (_err) {
      showMessage(dom.adminUserFormMsg, "יצירת המנהל בענן נכשלה.", false);
      return;
    }
  } else {
    const saved = writeStorage(STORAGE_KEYS.adminUsers, [nextUser, ...adminUsers]);
    if (!saved) {
      showMessage(dom.adminUserFormMsg, "יצירת המנהל נכשלה בגלל מגבלת אחסון בדפדפן.", false);
      return;
    }
  }

  dom.adminUserForm.reset();
  showMessage(dom.adminUserFormMsg, `המנהל "${username}" נוצר בהצלחה.`, true);
  renderAdminUsers();
}

async function handleOwnPasswordChange(event) {
  event.preventDefault();
  hideMessage(dom.adminPasswordFormMsg);

  const currentPassword = String(dom.adminCurrentPassword.value || "").trim();
  const newPassword = String(dom.adminNewPassword.value || "").trim();
  const confirmPassword = String(dom.adminConfirmPassword.value || "").trim();

  if (newPassword.length < 8) {
    showMessage(dom.adminPasswordFormMsg, "הסיסמה החדשה חייבת להכיל לפחות 8 תווים.", false);
    return;
  }

  if (newPassword !== confirmPassword) {
    showMessage(dom.adminPasswordFormMsg, "אימות הסיסמה החדשה לא תואם.", false);
    return;
  }

  if (!isBackendEnabled() || !adminState.currentAdmin?.id) {
    showMessage(dom.adminPasswordFormMsg, "שינוי סיסמה מאובטח זמין רק דרך Backend פעיל.", false);
    return;
  }

  try {
    await changeOwnBackendPassword(currentPassword, newPassword);
    dom.adminPasswordForm.reset();
    showMessage(dom.adminPasswordFormMsg, "הסיסמה עודכנה בהצלחה.", true);
  } catch (err) {
    const code = normalizeSpace(err?.message);
    if (code === "INVALID_CURRENT_PASSWORD") {
      showMessage(dom.adminPasswordFormMsg, "הסיסמה הנוכחית שגויה.", false);
      return;
    }
    if (code === "INVALID_NEW_PASSWORD") {
      showMessage(dom.adminPasswordFormMsg, "הסיסמה החדשה לא עומדת בדרישות המינימום.", false);
      return;
    }
    if (code === "PASSWORD_UNCHANGED") {
      showMessage(dom.adminPasswordFormMsg, "הסיסמה החדשה חייבת להיות שונה מהנוכחית.", false);
      return;
    }
    showMessage(dom.adminPasswordFormMsg, "עדכון הסיסמה נכשל. נסה שוב בעוד רגע.", false);
  }
}

async function removeAdminUser(userId) {
  const adminUsers = readAdminUsers();
  if (adminUsers.length <= 1) {
    showMessage(dom.adminUserFormMsg, "אי אפשר למחוק את המנהל האחרון במערכת.", false);
    return;
  }

  const target = adminUsers.find((user) => user.id === userId);
  if (!target) {
    return;
  }

  const shouldRemove = window.confirm(`למחוק את המנהל "${target.username}"?`);
  if (!shouldRemove) {
    return;
  }

  if (target.isOwner) {
    showMessage(dom.adminUserFormMsg, "לא ניתן למחוק את המנהל הראשי.", false);
    return;
  }

  if (isBackendEnabled() && adminState.currentAdmin?.id) {
    try {
      const remoteAdmins = await deleteBackendAdmin(userId);
      const normalizedRemote = remoteAdmins.map((item) => ({
        id: item.id,
        username: item.username,
        role: normalizeAdminRole(item.role),
        createdAt: item.createdAt || new Date().toISOString(),
        createdBy: item.createdBy || "remote",
      }));
      writeStorage(STORAGE_KEYS.adminUsers, normalizedRemote);
    } catch (err) {
      const code = normalizeSpace(err?.message);
      if (code === "OWNER_PROTECTED") {
        showMessage(dom.adminUserFormMsg, "לא ניתן למחוק את המנהל הראשי.", false);
        return;
      }
      showMessage(dom.adminUserFormMsg, "מחיקת מנהל בענן נכשלה.", false);
      return;
    }
  } else {
    const nextUsers = adminUsers.filter((user) => user.id !== userId);
    const saved = writeStorage(STORAGE_KEYS.adminUsers, nextUsers);
    if (!saved) {
      showMessage(dom.adminUserFormMsg, "מחיקת מנהל נכשלה.", false);
      return;
    }
  }

  if (adminState.currentAdmin?.id === userId) {
    adminState.currentAdmin = null;
    showScreen("screenAdminLogin");
    showMessage(dom.adminLoginError, "החשבון שלך נמחק. יש להתחבר מחדש.", false);
    return;
  }

  showMessage(dom.adminUserFormMsg, `המנהל "${target.username}" נמחק.`, true);
  renderAdminUsers();
}

function openAdminPanel() {
  setAdminMode("main");
  setDefaultDateFields();
  adminState.draftSelectionIds = [];
  adminState.lastVisibleDraftIds = [];
  renderAdminSessionInfo();
  renderAdminSystemCheck();
  renderAdminUsers();
  if (isBackendEnabled() && adminState.currentAdmin?.id) {
    refreshAdminUsersFromBackend()
      .then(() => renderAdminUsers())
      .catch(() => {});
  }
  renderAdminStats();
  renderAttemptsTable();
  renderLearningAlertSettingsForm();
  hideMessage(dom.learningAlertSettingsMsg);
  renderLearningMetrics();
  renderActivities();
  renderDrafts();
  renderCustomQuestions();
  renderLongTextDraftsPreview();
  if (adminState.longTextAnalysis) {
    setLongTextTopicTitle(adminState.longTextAnalysis);
  } else {
    clearLongTextTopicTitle();
  }
  renderQuestionAuditReport();
  dom.adminPasswordForm.reset();
  hideMessage(dom.activityFormMsg);
  hideMessage(dom.adminUserFormMsg);
  hideMessage(dom.adminPasswordFormMsg);
  hideMessage(dom.longTextMsg);
  hideDraftQueueMessage();
  showScreen("screenAdminPanel");
  runAdminSystemCheck().catch(() => {});
}

function renderAdminStats() {
  const attempts = readStorage(STORAGE_KEYS.attempts, []);
  const activities = readStorage(STORAGE_KEYS.activities, []);
  const drafts = readDraftQueue();
  const inventory = getQuestionInventory();
  const totalQuestions = inventory.activeQuestions.length;
  const disabledQuestions = inventory.disabledIds.size;

  const uniquePlayers = new Set(attempts.map((item) => item.playerName)).size;
  const avgPercent =
    attempts.length === 0
      ? 0
      : Math.round(attempts.reduce((sum, item) => sum + (item.percent || 0), 0) / attempts.length);
  const avgAnswerSec =
    attempts.length === 0
      ? 0
      : Number(
          (
            attempts.reduce((sum, item) => sum + Number(item.avgAnswerSec || 0), 0) / attempts.length
          ).toFixed(1),
        );
  const totalTimeouts = attempts.reduce((sum, item) => sum + Number(item.timeoutCount || 0), 0);

  const stats = [
    { label: "ניסיונות", value: attempts.length },
    { label: "שחקנים ייחודיים", value: uniquePlayers },
    { label: "ממוצע אחוז", value: `${avgPercent}%` },
    { label: "שאלות פעילות", value: totalQuestions },
    { label: "שאלות מוסתרות", value: disabledQuestions },
    { label: "זמן מענה ממוצע", value: `${avgAnswerSec} ש׳` },
    { label: "פקיעות זמן", value: totalTimeouts },
    { label: "טיוטות ממתינות", value: drafts.length },
    { label: "פעילויות שהוזנו", value: activities.length },
  ];

  dom.adminStats.innerHTML = "";
  stats.forEach((stat) => {
    const card = document.createElement("article");
    card.className = "stat-card";

    const label = document.createElement("p");
    label.className = "label";
    label.textContent = stat.label;

    const value = document.createElement("p");
    value.className = "value";
    value.textContent = String(stat.value);

    card.appendChild(label);
    card.appendChild(value);
    dom.adminStats.appendChild(card);
  });

  dom.questionCountExact.textContent = `שאלות פעילות במאגר: ${totalQuestions} | מוסתרות: ${disabledQuestions} | סך הכול: ${inventory.allQuestions.length}`;
}

function renderAttemptsTable() {
  const attempts = readStorage(STORAGE_KEYS.attempts, []);
  dom.attemptsTableBody.innerHTML = "";

  if (!attempts.length) {
    const row = document.createElement("tr");
    const cell = document.createElement("td");
    cell.colSpan = 5;
    cell.textContent = "אין נתוני משחק עדיין.";
    row.appendChild(cell);
    dom.attemptsTableBody.appendChild(row);
    return;
  }

  attempts.forEach((attempt) => {
    const row = document.createElement("tr");
    const points = Number.isFinite(attempt.score) ? attempt.score : 0;
    const correct = Number.isFinite(attempt.correct) ? attempt.correct : attempt.score;
    const total = Number.isFinite(attempt.total) ? attempt.total : 0;
    const avgAnswerSec = Number(attempt.avgAnswerSec || 0);
    const timeoutCount = Number(attempt.timeoutCount || 0);
    const adaptiveTag = attempt?.adaptiveMode
      ? ` | מותאם ${Number(attempt?.adaptiveConfidence || 0)}%`
      : "";

    row.appendChild(makeCell(attempt.playerName));
    row.appendChild(makeCell(`${points} נק' (${correct}/${total})`));
    row.appendChild(makeCell(`${attempt.percent}%`));
    row.appendChild(
      makeCell(
        `${formatDuration(attempt.durationSec || 0)} | ממוצע ${avgAnswerSec.toFixed(1)} ש׳ | פקיעות ${timeoutCount}${adaptiveTag}`,
      ),
    );
    row.appendChild(makeCell(formatDateTime(attempt.playedAt)));
    dom.attemptsTableBody.appendChild(row);
  });
}

function normalizeLearningAlertSettings(input) {
  const raw = input && typeof input === "object" ? input : {};
  const minAttemptsForAlerts = clampNumber(
    Number(raw.minAttemptsForAlerts),
    1,
    50,
  ) || LEARNING_ALERT_SETTINGS_DEFAULT.minAttemptsForAlerts;
  const categoryAccuracyWarn = clampNumber(
    Number(raw.categoryAccuracyWarn),
    1,
    100,
  ) || LEARNING_ALERT_SETTINGS_DEFAULT.categoryAccuracyWarn;
  const categoryAccuracyHigh = clampNumber(
    Number(raw.categoryAccuracyHigh),
    1,
    categoryAccuracyWarn,
  ) || Math.min(LEARNING_ALERT_SETTINGS_DEFAULT.categoryAccuracyHigh, categoryAccuracyWarn);
  const categoryTimeoutWarn = clampNumber(
    Number(raw.categoryTimeoutWarn),
    0,
    100,
  );
  const questionFailWarn = clampNumber(
    Number(raw.questionFailWarn),
    1,
    100,
  ) || LEARNING_ALERT_SETTINGS_DEFAULT.questionFailWarn;
  const questionFailHigh = clampNumber(
    Number(raw.questionFailHigh),
    1,
    questionFailWarn,
  ) || Math.min(LEARNING_ALERT_SETTINGS_DEFAULT.questionFailHigh, questionFailWarn);
  const questionTimeoutWarn = clampNumber(
    Number(raw.questionTimeoutWarn),
    0,
    100,
  );

  return {
    minAttemptsForAlerts,
    categoryAccuracyWarn,
    categoryAccuracyHigh,
    categoryTimeoutWarn,
    questionFailWarn,
    questionFailHigh,
    questionTimeoutWarn,
  };
}

function readLearningAlertSettings() {
  const saved = readObjectStorage(STORAGE_KEYS.learningAlertSettings, {});
  const merged = {
    ...LEARNING_ALERT_SETTINGS_DEFAULT,
    ...(saved || {}),
  };
  return normalizeLearningAlertSettings(merged);
}

function renderLearningAlertSettingsForm() {
  const settings = readLearningAlertSettings();
  if (dom.learningAlertMinAttempts) {
    dom.learningAlertMinAttempts.value = String(settings.minAttemptsForAlerts);
  }
  if (dom.learningAlertCategoryWarn) {
    dom.learningAlertCategoryWarn.value = String(settings.categoryAccuracyWarn);
  }
  if (dom.learningAlertCategoryHigh) {
    dom.learningAlertCategoryHigh.value = String(settings.categoryAccuracyHigh);
  }
  if (dom.learningAlertCategoryTimeoutWarn) {
    dom.learningAlertCategoryTimeoutWarn.value = String(settings.categoryTimeoutWarn);
  }
  if (dom.learningAlertQuestionFailWarn) {
    dom.learningAlertQuestionFailWarn.value = String(settings.questionFailWarn);
  }
  if (dom.learningAlertQuestionFailHigh) {
    dom.learningAlertQuestionFailHigh.value = String(settings.questionFailHigh);
  }
  if (dom.learningAlertQuestionTimeoutWarn) {
    dom.learningAlertQuestionTimeoutWarn.value = String(settings.questionTimeoutWarn);
  }
}

function buildLearningAlertSettingsFromForm() {
  return normalizeLearningAlertSettings({
    minAttemptsForAlerts: dom.learningAlertMinAttempts?.value,
    categoryAccuracyWarn: dom.learningAlertCategoryWarn?.value,
    categoryAccuracyHigh: dom.learningAlertCategoryHigh?.value,
    categoryTimeoutWarn: dom.learningAlertCategoryTimeoutWarn?.value,
    questionFailWarn: dom.learningAlertQuestionFailWarn?.value,
    questionFailHigh: dom.learningAlertQuestionFailHigh?.value,
    questionTimeoutWarn: dom.learningAlertQuestionTimeoutWarn?.value,
  });
}

function saveLearningAlertSettingsFromForm() {
  const settings = buildLearningAlertSettingsFromForm();
  const saved = writeStorage(STORAGE_KEYS.learningAlertSettings, settings);
  if (!saved) {
    showMessage(dom.learningAlertSettingsMsg, "שמירת הגדרות ההתראות נכשלה.", false);
    return;
  }
  showMessage(dom.learningAlertSettingsMsg, "הגדרות ההתראות נשמרו בהצלחה.", true);
  renderLearningAlertSettingsForm();
  renderLearningMetrics();
}

function resetLearningAlertSettingsToDefault() {
  const saved = writeStorage(STORAGE_KEYS.learningAlertSettings, { ...LEARNING_ALERT_SETTINGS_DEFAULT });
  if (!saved) {
    showMessage(dom.learningAlertSettingsMsg, "איפוס הגדרות ההתראות נכשל.", false);
    return;
  }
  showMessage(dom.learningAlertSettingsMsg, "הגדרות ההתראות אופסו לברירת המחדל.", true);
  renderLearningAlertSettingsForm();
  renderLearningMetrics();
}

function renderLearningMetrics() {
  const attempts = readStorage(STORAGE_KEYS.attempts, []);
  const alertSettings = readLearningAlertSettings();
  dom.learningMetricsList.innerHTML = "";
  if (dom.learningAlertsList) {
    dom.learningAlertsList.innerHTML = "";
  }
  if (dom.questionDifficultyList) {
    dom.questionDifficultyList.innerHTML = "";
  }
  if (dom.learningRecommendationsList) {
    dom.learningRecommendationsList.innerHTML = "";
  }

  const categorySummary = new Map();
  attempts.forEach((attempt) => {
    const byCategory =
      attempt?.categoryStats && typeof attempt.categoryStats === "object"
        ? attempt.categoryStats
        : null;
    if (!byCategory) {
      return;
    }

    Object.entries(byCategory).forEach(([category, stat]) => {
      const safeCategory = normalizeSpace(category) || "ללא קטגוריה";
      const total = Number(stat?.total || 0);
      if (total <= 0) {
        return;
      }

      const correct = clampNumber(Number(stat?.correct || 0), 0, total);
      const timeouts = clampNumber(Number(stat?.timeouts || 0), 0, total);
      const totalAnswerSec = Math.max(0, Number(stat?.totalAnswerSec || 0));

      if (!categorySummary.has(safeCategory)) {
        categorySummary.set(safeCategory, {
          total: 0,
          correct: 0,
          timeouts: 0,
          totalAnswerSec: 0,
        });
      }

      const current = categorySummary.get(safeCategory);
      current.total += total;
      current.correct += correct;
      current.timeouts += timeouts;
      current.totalAnswerSec += totalAnswerSec;
    });
  });

  let categoryRows = [];
  if (!categorySummary.size) {
    dom.learningMetricsList.appendChild(
      makeInfoMessage("עדיין אין מספיק נתונים למדד למידה. אחרי כמה משחקים יופיעו נקודות נפילה לפי נושא."),
    );
  } else {
    categoryRows = Array.from(categorySummary.entries())
      .map(([category, item]) => {
        const misses = Math.max(0, item.total - item.correct);
        const accuracy = item.total ? Math.round((item.correct / item.total) * 100) : 0;
        const timeoutRate = item.total ? Math.round((item.timeouts / item.total) * 100) : 0;
        const avgSec = item.total ? Number((item.totalAnswerSec / item.total).toFixed(1)) : 0;
        const learningIndex = Math.max(
          0,
          Math.min(100, Math.round(accuracy * 0.72 + (100 - timeoutRate) * 0.28)),
        );

        return {
          category,
          total: item.total,
          misses,
          accuracy,
          timeoutRate,
          avgSec,
          learningIndex,
        };
      })
      .sort((a, b) => {
        if (a.accuracy !== b.accuracy) {
          return a.accuracy - b.accuracy;
        }
        return b.total - a.total;
      });

    categoryRows.forEach((row) => {
      const card = document.createElement("article");
      card.className = "info-card learning-card";

      const title = document.createElement("h4");
      title.textContent = row.category;

      const statLine = document.createElement("p");
      statLine.textContent = `דיוק: ${row.accuracy}% | נפילות: ${row.misses}/${row.total} | פקיעות זמן: ${row.timeoutRate}%`;

      const speedLine = document.createElement("p");
      speedLine.textContent = `זמן מענה ממוצע: ${row.avgSec} שניות | מדד למידה: ${row.learningIndex}/100`;

      const barWrap = document.createElement("div");
      barWrap.className = "learning-bar";

      const barFill = document.createElement("div");
      barFill.className = "learning-fill";
      barFill.style.width = `${row.learningIndex}%`;

      barWrap.appendChild(barFill);

      const priority = document.createElement("p");
      priority.className = "muted tight";
      if (row.accuracy < 55) {
        priority.textContent = "עדיפות חיזוק: גבוהה מאוד - זה נושא ששחקנים מתקשים בו כרגע.";
      } else if (row.accuracy < 72) {
        priority.textContent = "עדיפות חיזוק: בינונית - כדאי להוסיף דוגמאות והסברים בנושא.";
      } else {
        priority.textContent = "עדיפות חיזוק: נמוכה - הנושא מובן יחסית.";
      }

      card.appendChild(title);
      card.appendChild(statLine);
      card.appendChild(speedLine);
      card.appendChild(barWrap);
      card.appendChild(priority);
      dom.learningMetricsList.appendChild(card);
    });
  }

  const questionRows = buildQuestionLearningRows(attempts);
  const smartAlerts = buildSmartLearningAlerts(categoryRows, questionRows, attempts.length, alertSettings);
  const alertCount = renderLearningAlertsPanel(smartAlerts);
  renderQuestionDifficultyList(questionRows, alertSettings);
  renderLearningRecommendationsPanel(categoryRows, questionRows, attempts.length, smartAlerts);

  if (dom.learningInsightsSummary) {
    const trackedQuestions = questionRows.filter((item) => item.total >= 2).length;
    dom.learningInsightsSummary.textContent =
      `משחקים נותחו: ${attempts.length} | שאלות עם מדגם מספיק: ${trackedQuestions} | קטגוריות פעילות: ${categoryRows.length} | התראות פעילות: ${alertCount} | סף התראה: ${alertSettings.questionFailWarn}%`;
  }
}

function calculateEntropyScore(counts) {
  const safeCounts = (counts || []).map((value) => Math.max(0, Number(value) || 0)).filter((value) => value > 0);
  const total = safeCounts.reduce((sum, value) => sum + value, 0);
  if (!total || safeCounts.length <= 1) {
    return 0;
  }
  const entropy = safeCounts.reduce((sum, value) => {
    const probability = value / total;
    return sum - probability * Math.log2(probability);
  }, 0);
  const maxEntropy = Math.log2(safeCounts.length);
  if (!maxEntropy) {
    return 0;
  }
  return Math.max(0, Math.min(1, entropy / maxEntropy));
}

function detectQuestionIssueCause(row) {
  if (!row || row.total < AMBIGUOUS_QUESTION_MIN_SAMPLE) {
    return "insufficient";
  }
  if (row.timeoutRate >= 36 || row.avgSec >= 21) {
    return "phrasing";
  }
  if (row.ambiguousSignal) {
    return "ambiguous";
  }
  if (row.failRate >= 52 && row.timeoutRate < 22) {
    return "knowledge";
  }
  if (row.failRate >= 40) {
    return "mixed";
  }
  return "stable";
}

function getQuestionIssueCauseLabel(cause) {
  if (cause === "phrasing") {
    return "ניסוח/עומס קריאה";
  }
  if (cause === "knowledge") {
    return "פער ידע";
  }
  if (cause === "ambiguous") {
    return "שאלה עמומה";
  }
  if (cause === "mixed") {
    return "מעורב (ניסוח + ידע)";
  }
  if (cause === "insufficient") {
    return "מדגם לא מספיק";
  }
  return "יציב";
}

function buildQuestionLearningRows(attemptsInput) {
  const attempts = Array.isArray(attemptsInput) ? attemptsInput : readStorage(STORAGE_KEYS.attempts, []);
  const summary = new Map();
  const inventory = getQuestionInventory();
  const inventoryById = new Map(inventory.allQuestions.map((question) => [normalizeSpace(question.id), question]));

  attempts.forEach((attempt) => {
    const rawQuestionStats = attempt?.questionStats;
    if (!rawQuestionStats || typeof rawQuestionStats !== "object") {
      return;
    }

    const entries = Array.isArray(rawQuestionStats)
      ? rawQuestionStats
      : Object.values(rawQuestionStats);

    entries.forEach((item) => {
      const safeId = normalizeSpace(item?.questionId || item?.id);
      if (!safeId) {
        return;
      }

      if (!summary.has(safeId)) {
        const fallbackQuestion = inventoryById.get(safeId);
        summary.set(safeId, {
          id: safeId,
          question: normalizeSpace(item?.questionText || fallbackQuestion?.question) || "שאלה ללא טקסט",
          category: normalizeSpace(item?.category || fallbackQuestion?.category) || "ללא קטגוריה",
          correctAnswerIndex: Number.isInteger(Number(item?.correctAnswerIndex))
            ? Number(item?.correctAnswerIndex)
            : Number.isInteger(Number(fallbackQuestion?.answer))
              ? Number(fallbackQuestion.answer)
              : -1,
          optionCount: Math.max(
            0,
            Number(item?.optionCount || 0),
            Array.isArray(fallbackQuestion?.options) ? fallbackQuestion.options.length : 0,
          ),
          selectedOptionCounts: {},
          total: 0,
          correct: 0,
          wrong: 0,
          timeouts: 0,
          totalAnswerSec: 0,
        });
      }

      const current = summary.get(safeId);
      const total = Math.max(0, Number(item?.total || 0));
      const correct = clampNumber(Number(item?.correct || 0), 0, total);
      const wrong = clampNumber(Number(item?.wrong || Math.max(0, total - correct)), 0, total);
      const timeouts = clampNumber(Number(item?.timeouts || 0), 0, total);
      const totalAnswerSec = Math.max(0, Number(item?.totalAnswerSec || 0));

      current.total += total;
      current.correct += correct;
      current.wrong += wrong;
      current.timeouts += timeouts;
      current.totalAnswerSec += totalAnswerSec;
      if (
        current.correctAnswerIndex < 0
        && Number.isInteger(Number(item?.correctAnswerIndex))
      ) {
        current.correctAnswerIndex = Number(item.correctAnswerIndex);
      }
      current.optionCount = Math.max(current.optionCount, Number(item?.optionCount || 0));
      if (!current.selectedOptionCounts || typeof current.selectedOptionCounts !== "object") {
        current.selectedOptionCounts = {};
      }
      if (item?.selectedOptionCounts && typeof item.selectedOptionCounts === "object") {
        Object.entries(item.selectedOptionCounts).forEach(([key, value]) => {
          const safeKey = normalizeSpace(key);
          if (!safeKey) {
            return;
          }
          current.selectedOptionCounts[safeKey] = Number(current.selectedOptionCounts[safeKey] || 0)
            + Math.max(0, Number(value || 0));
        });
      }
    });
  });

  return Array.from(summary.values())
    .map((row) => {
      const failRate = row.total ? Math.round((row.wrong / row.total) * 100) : 0;
      const timeoutRate = row.total ? Math.round((row.timeouts / row.total) * 100) : 0;
      const accuracy = row.total ? Math.round((row.correct / row.total) * 100) : 0;
      const avgSec = row.total ? Number((row.totalAnswerSec / row.total).toFixed(1)) : 0;
      const riskScore = Math.round(failRate * 0.7 + timeoutRate * 0.3);
      const optionEntries = Object.entries(row.selectedOptionCounts || {})
        .filter(([key]) => key.startsWith("opt_"));
      const wrongOptionCounts = optionEntries
        .filter(([key]) => Number(key.replace("opt_", "")) !== row.correctAnswerIndex)
        .map(([, value]) => Math.max(0, Number(value || 0)));
      const totalWrongSelections = wrongOptionCounts.reduce((sum, value) => sum + value, 0);
      const dominantWrongRate = totalWrongSelections
        ? Math.round((Math.max(...wrongOptionCounts, 0) / totalWrongSelections) * 100)
        : 0;
      const wrongSelectionEntropy = calculateEntropyScore(wrongOptionCounts);
      const ambiguityScore = row.total >= AMBIGUOUS_QUESTION_MIN_SAMPLE
        ? Math.round(
          wrongSelectionEntropy * 50
          + (100 - Math.abs(50 - failRate) * 2) * 0.24
          + timeoutRate * 0.18
          + (dominantWrongRate < 45 ? 14 : 0),
        )
        : 0;
      const ambiguousSignal = row.total >= AMBIGUOUS_QUESTION_MIN_SAMPLE
        && failRate >= 35
        && ambiguityScore >= 58;
      const issueCause = detectQuestionIssueCause({
        ...row,
        failRate,
        timeoutRate,
        avgSec,
        ambiguousSignal,
      });

      return {
        ...row,
        failRate,
        timeoutRate,
        accuracy,
        avgSec,
        riskScore,
        dominantWrongRate,
        wrongSelectionEntropy,
        ambiguityScore,
        ambiguousSignal,
        issueCause,
      };
    })
    .filter((row) => row.total > 0)
    .sort((a, b) => {
      if (a.riskScore !== b.riskScore) {
        return b.riskScore - a.riskScore;
      }
      return b.total - a.total;
    });
}

function renderQuestionDifficultyList(questionRows, alertSettingsInput = null) {
  if (!dom.questionDifficultyList) {
    return;
  }

  const alertSettings = alertSettingsInput || readLearningAlertSettings();
  dom.questionDifficultyList.innerHTML = "";
  const actionable = (questionRows || []).filter((row) => row.total >= 2).slice(0, 10);
  if (!actionable.length) {
    dom.questionDifficultyList.appendChild(
      makeInfoMessage("עדיין אין מספיק מדגם ברמת שאלה. אחרי כמה משחקים נוספים יופיעו שאלות מכשילות."),
    );
    return;
  }

  actionable.forEach((row) => {
    const card = document.createElement("article");
    card.className = "info-card";

    const title = document.createElement("h4");
    title.textContent = row.question;

    const badgeRow = document.createElement("div");
    badgeRow.className = "badge-row";

    const riskBadge = document.createElement("span");
    riskBadge.className = `badge ${row.failRate >= alertSettings.questionFailHigh ? "audit-level bad" : "audit-level warn"}`;
    riskBadge.textContent = `סיכון: ${row.riskScore}/100`;

    const categoryBadge = document.createElement("span");
    categoryBadge.className = "badge";
    categoryBadge.textContent = row.category;

    const sampleBadge = document.createElement("span");
    sampleBadge.className = "badge";
    sampleBadge.textContent = `מדגם: ${row.total}`;

    const causeBadge = document.createElement("span");
    causeBadge.className = "badge";
    causeBadge.textContent = `סיבת נפילות: ${getQuestionIssueCauseLabel(row.issueCause)}`;

    badgeRow.appendChild(riskBadge);
    badgeRow.appendChild(categoryBadge);
    badgeRow.appendChild(sampleBadge);
    badgeRow.appendChild(causeBadge);

    const statLine = document.createElement("p");
    statLine.textContent =
      `נפילות: ${row.failRate}% | פקיעות זמן: ${row.timeoutRate}% | דיוק: ${row.accuracy}% | זמן מענה ממוצע: ${row.avgSec} ש׳`;

    const insightLine = document.createElement("p");
    insightLine.className = "muted tight";
    insightLine.textContent = row.ambiguousSignal
      ? `עמימות מזוהה: גבוהה (${row.ambiguityScore}/100) | פיזור בחירות שגויות: ${Math.round(row.wrongSelectionEntropy * 100)}%`
      : `אינדיקציית עמימות: ${row.ambiguityScore}/100 | בחירה שגויה דומיננטית: ${row.dominantWrongRate}%`;

    const actions = document.createElement("div");
    actions.className = "inline-actions";

    const editBtn = document.createElement("button");
    editBtn.type = "button";
    editBtn.className = "ghost-btn";
    editBtn.textContent = "ערוך במאגר";
    editBtn.addEventListener("click", () => {
      setAdminTab("questionBank");
      editQuestion(row.id);
    });

    actions.appendChild(editBtn);

    card.appendChild(title);
    card.appendChild(badgeRow);
    card.appendChild(statLine);
    card.appendChild(insightLine);
    card.appendChild(actions);
    dom.questionDifficultyList.appendChild(card);
  });
}

function buildCategoryAlertRecommendation(row, settings) {
  if (row.accuracy <= settings.categoryAccuracyHigh) {
    return `הוסף לפחות 4 שאלות חיזוק בקטגוריית "${row.category}" ועדכן ניסוח להסבר ברור יותר.`;
  }
  if (row.timeoutRate >= settings.categoryTimeoutWarn) {
    return `קצר נוסח שאלה ואפשרויות בקטגוריית "${row.category}" ובחן האם נדרש כרטיס למידה מקדים.`;
  }
  return `בצע רענון מסיחים והוסף 2-3 שאלות תרגול ממוקדות בקטגוריית "${row.category}".`;
}

function buildQuestionAlertRecommendation(row, settings) {
  if (row.issueCause === "ambiguous") {
    return "סמן את השאלה כעמומה, ערוך ניסוח ושפר מסיחים כדי לייצר הבדל חד יותר בין תשובות.";
  }
  if (row.issueCause === "phrasing") {
    return "פשט את הניסוח, קצר אפשרויות ושקול להוסיף מונחי מפתח בכרטיס הלמידה לפני השאלה.";
  }
  if (row.failRate >= settings.questionFailHigh) {
    return `ערוך את השאלה במאגר, החלף לפחות שני מסיחים חלשים והדגש את ההסבר הנכון.`;
  }
  if (row.timeoutRate >= settings.questionTimeoutWarn) {
    return `קצר את נוסח השאלה או את אורכי התשובות כדי לצמצם פקיעות זמן.`;
  }
  return `בדוק בהירות ניסוח ועדכן את כרטיס הלמידה כך שהמסר המרכזי יופיע לפני השאלה.`;
}

function buildSmartLearningAlerts(categoryRows, questionRows, attemptCount, settingsInput = null) {
  const settings = settingsInput || readLearningAlertSettings();
  const alerts = [];
  if (attemptCount < settings.minAttemptsForAlerts) {
    alerts.push({
      key: "sample_small",
      level: "warn",
      title: "מדגם קטן",
      text: `מומלץ לצבור לפחות ${settings.minAttemptsForAlerts} משחקים כדי לקבל התרעות יציבות יותר.`,
      recommendation: "המשך איסוף נתונים לפני קבלת החלטות תוכן רחבות.",
    });
  }

  (categoryRows || [])
    .filter((row) =>
      row.total >= settings.minAttemptsForAlerts
      && (row.accuracy <= settings.categoryAccuracyWarn || row.timeoutRate >= settings.categoryTimeoutWarn))
    .slice(0, 4)
    .forEach((row) => {
      alerts.push({
        key: `cat_${row.category}`,
        level: row.accuracy <= settings.categoryAccuracyHigh ? "high" : "warn",
        title: `התראת נושא: ${row.category}`,
        text: `דיוק ${row.accuracy}% | פקיעות זמן ${row.timeoutRate}% | מדגם ${row.total}.`,
        recommendation: buildCategoryAlertRecommendation(row, settings),
      });
    });

  (questionRows || [])
    .filter((row) =>
      row.total >= Math.max(3, settings.minAttemptsForAlerts - 1)
      && (
        row.failRate >= settings.questionFailWarn
        || row.timeoutRate >= settings.questionTimeoutWarn
        || row.ambiguousSignal
      ))
    .slice(0, 5)
    .forEach((row) => {
      alerts.push({
        key: `q_${row.id}`,
        level: row.ambiguousSignal || row.failRate >= settings.questionFailHigh ? "high" : "warn",
        title: "התראת שאלה",
        text: `"${clampText(row.question, 78)}" | נפילות ${row.failRate}% | פקיעות ${row.timeoutRate}% | סיבה משוערת: ${getQuestionIssueCauseLabel(row.issueCause)} | מדגם ${row.total}.`,
        recommendation: buildQuestionAlertRecommendation(row, settings),
      });
    });

  return alerts.slice(0, 8);
}

function renderLearningRecommendationsPanel(categoryRows, questionRows, attemptCount, smartAlertsInput = []) {
  if (!dom.learningRecommendationsList) {
    return;
  }
  dom.learningRecommendationsList.innerHTML = "";

  const recommendations = [];
  const smartAlerts = Array.isArray(smartAlertsInput) ? smartAlertsInput : [];
  const alertSettings = readLearningAlertSettings();

  smartAlerts.forEach((alert) => {
    if (!normalizeSpace(alert?.recommendation)) {
      return;
    }
    recommendations.push(alert.recommendation);
  });

  if (attemptCount < 5) {
    recommendations.push("הגדל מדגם: לפחות 5-8 משחקים נדרשים כדי לזהות דפוסי קושי יציבים.");
  }

  const weakCategories = (categoryRows || [])
    .filter((row) =>
      row.total >= alertSettings.minAttemptsForAlerts
      && row.accuracy <= Math.min(100, alertSettings.categoryAccuracyWarn + 7))
    .slice(0, 3);
  weakCategories.forEach((row) => {
    recommendations.push(
      `בקטגוריית "${row.category}" הדיוק ${row.accuracy}% בלבד. מומלץ להוסיף 3-5 שאלות הסבר קצרות ולחדד מסיחים.`,
    );
  });

  const hardQuestions = (questionRows || [])
    .filter((row) =>
      row.total >= Math.max(3, alertSettings.minAttemptsForAlerts - 1)
      && row.failRate >= alertSettings.questionFailWarn)
    .slice(0, 4);
  hardQuestions.forEach((row) => {
    recommendations.push(
      `השאלה "${clampText(row.question, 90)}" מכשילה (${row.failRate}% נפילות, ${getQuestionIssueCauseLabel(row.issueCause)}). מומלץ לשפר ניסוח והסבר ולבדוק את המסיחים.`,
    );
  });

  const ambiguousQuestions = (questionRows || [])
    .filter((row) => row.total >= AMBIGUOUS_QUESTION_MIN_SAMPLE && row.ambiguousSignal)
    .slice(0, 3);
  ambiguousQuestions.forEach((row) => {
    recommendations.push(
      `השאלה "${clampText(row.question, 88)}" מזוהה כעמומה (${row.ambiguityScore}/100). מומלץ לחדד ניסוח ולהבדיל חד-משמעית בין המסיחים.`,
    );
  });

  const timeoutQuestions = (questionRows || [])
    .filter((row) =>
      row.total >= Math.max(3, alertSettings.minAttemptsForAlerts - 1)
      && row.timeoutRate >= alertSettings.questionTimeoutWarn)
    .slice(0, 2);
  timeoutQuestions.forEach((row) => {
    recommendations.push(
      `שיעור פקיעת הזמן גבוה בשאלה "${clampText(row.question, 80)}" (${row.timeoutRate}%). מומלץ לקצר נוסח שאלה/אפשרויות.`,
    );
  });

  if (!recommendations.length) {
    dom.learningRecommendationsList.appendChild(
      makeInfoMessage("כרגע אין התראות חריגות. מומלץ להמשיך לנטר ולהריץ Audit תוכן לפני פרסום."),
    );
    return;
  }

  const deduped = Array.from(new Set(recommendations.map((item) => normalizeSpace(item)).filter(Boolean)));
  deduped.slice(0, 8).forEach((text) => {
    const card = document.createElement("article");
    card.className = "info-card";
    const line = document.createElement("p");
    line.textContent = text;
    card.appendChild(line);
    dom.learningRecommendationsList.appendChild(card);
  });
}

function renderLearningAlertsPanel(alertsInput) {
  if (!dom.learningAlertsList) {
    return 0;
  }

  dom.learningAlertsList.innerHTML = "";
  const alerts = Array.isArray(alertsInput) ? alertsInput : [];

  if (!alerts.length) {
    dom.learningAlertsList.appendChild(
      makeInfoMessage("אין כרגע התראות חריגות. הביצועים יציבים ביחס לנתונים שנאספו."),
    );
    return 0;
  }

  alerts.slice(0, 8).forEach((alert) => {
    const card = document.createElement("article");
    card.className = `info-card learning-alert-card ${alert.level}`;

    const header = document.createElement("div");
    header.className = "section-head";

    const title = document.createElement("h4");
    title.textContent = normalizeSpace(alert.title) || (alert.level === "high" ? "התראה גבוהה" : "התראת מעקב");

    const badge = document.createElement("span");
    badge.className = `badge ${alert.level === "high" ? "audit-level bad" : "audit-level warn"}`;
    badge.textContent = alert.level === "high" ? "חשוב" : "שים לב";

    header.appendChild(title);
    header.appendChild(badge);

    const line = document.createElement("p");
    line.textContent = alert.text;

    const recommendationLine = document.createElement("p");
    recommendationLine.className = "muted tight";
    recommendationLine.textContent = `תיקון מומלץ: ${normalizeSpace(alert.recommendation) || "בדוק ניסוח, מסיחים וכרטיס למידה לפני מחזור המשחק הבא."}`;

    card.appendChild(header);
    card.appendChild(line);
    card.appendChild(recommendationLine);
    dom.learningAlertsList.appendChild(card);
  });

  return alerts.length;
}

function makeCell(text) {
  const cell = document.createElement("td");
  cell.textContent = text;
  return cell;
}

async function handleActivitySubmit(event) {
  event.preventDefault();

  hideMessage(dom.activityFormMsg);

  const formData = new FormData(dom.activityForm);
  const title = String(formData.get("title") || "").trim();
  const date = String(formData.get("date") || "").trim();
  const category = String(formData.get("category") || "").trim();
  const kind = String(formData.get("kind") || "activity").trim();
  const context = String(formData.get("context") || "").trim();
  const outcome = String(formData.get("outcome") || "").trim();
  const sourceLabel = String(formData.get("sourceLabel") || "").trim();
  const sourceUrl = String(formData.get("sourceUrl") || "").trim();
  const antiSpamPayloadHash = String(
    hashText(
      [title, date, category, kind, context, outcome, sourceLabel, sourceUrl]
        .map((item) => normalizeSpace(item))
        .join("|"),
    ),
  );
  const antiSpam = recordAntiSpamEvent("activitySubmit", antiSpamPayloadHash);
  if (antiSpam.blocked) {
    showMessage(
      dom.activityFormMsg,
      `יותר מדי שליחות בזמן קצר. נסה שוב בעוד ${formatCooldownMs(antiSpam.remainingMs)}.`,
      false,
    );
    return;
  }
  if (antiSpam.duplicate) {
    showMessage(
      dom.activityFormMsg,
      "זוהתה שליחה כפולה של אותו תוכן בזמן קצר. עדכן נתונים או המתן כמה שניות.",
      false,
    );
    return;
  }

  if (!title || !date || !category || !context || !outcome) {
    showMessage(dom.activityFormMsg, "יש למלא את כל השדות החיוניים לפני שמירה.", false);
    return;
  }

  if (kind === "activity" && date < MIN_CONTENT_DATE) {
    showMessage(
      dom.activityFormMsg,
      "פעילות שוטפת חייבת להיות מתאריך 2025 ומעלה. הישג יכול להיות גם מוקדם יותר.",
      false,
    );
    return;
  }

  if (sourceUrl && !isValidUrl(sourceUrl)) {
    showMessage(dom.activityFormMsg, "קישור המקור לא תקין. יש להזין URL מלא.", false);
    return;
  }

  const attachments = await extractFileMeta(dom.adminFilesInput.files);

  const activity = {
    id: uid("act"),
    title,
    date,
    category,
    kind,
    context,
    outcome,
    sourceLabel,
    sourceUrl,
    attachments,
    createdAt: new Date().toISOString(),
  };

  const activities = readStorage(STORAGE_KEYS.activities, []);
  activities.unshift(activity);

  const drafts = readDraftQueue();
  const generatedDrafts = generateDraftsFromActivity(activity);

  const savedActivities = writeStorage(STORAGE_KEYS.activities, activities.slice(0, 300));
  const generatedDraftsWithWorkflow = generatedDrafts.map((draft) => ({
    ...draft,
    workflowStatus: "draft",
  }));
  const savedDrafts = writeDraftQueue([...generatedDraftsWithWorkflow, ...drafts].slice(0, 500));
  if (!savedActivities || !savedDrafts) {
    showMessage(
      dom.activityFormMsg,
      "שמירה נכשלה (ייתכן שמגבלת האחסון בדפדפן התמלאה). נסה לצמצם קבצים/תמונות.",
      false,
    );
    return;
  }

  dom.activityForm.reset();
  setDefaultDateFields();

  showMessage(
    dom.activityFormMsg,
    `הפעילות נשמרה. נוצרו ${generatedDrafts.length} טיוטות שאלות לאישור מנהל.`,
    true,
  );

  renderAdminStats();
  renderActivities();
  renderDrafts();
}

function renderActivities() {
  const activities = readStorage(STORAGE_KEYS.activities, []);
  dom.activitiesList.innerHTML = "";

  if (!activities.length) {
    dom.activitiesList.appendChild(makeInfoMessage("עדיין לא הוזנו פעילויות."));
    return;
  }

  activities.forEach((activity) => {
    const card = document.createElement("article");
    card.className = "info-card";

    const title = document.createElement("h4");
    title.textContent = activity.title;

    const badgeRow = document.createElement("div");
    badgeRow.className = "badge-row";

    const dateBadge = document.createElement("span");
    dateBadge.className = "badge";
    dateBadge.textContent = formatDateDisplay(activity.date);

    const kindBadge = document.createElement("span");
    kindBadge.className = `badge ${activity.kind === "success" ? "success" : "activity"}`;
    kindBadge.textContent = activity.kind === "success" ? "הישג" : "פעילות";

    const categoryBadge = document.createElement("span");
    categoryBadge.className = "badge";
    categoryBadge.textContent = activity.category;

    badgeRow.appendChild(dateBadge);
    badgeRow.appendChild(kindBadge);
    badgeRow.appendChild(categoryBadge);

    const context = document.createElement("p");
    context.textContent = `רקע: ${activity.context}`;

    const outcome = document.createElement("p");
    outcome.textContent = `תוצאה: ${activity.outcome}`;

    card.appendChild(title);
    card.appendChild(badgeRow);
    card.appendChild(context);
    card.appendChild(outcome);

    if (activity.sourceUrl) {
      const source = document.createElement("a");
      source.href = buildPreferredSourceHref(
        {
          label: activity.sourceLabel || "קישור חיצוני",
          url: activity.sourceUrl,
          anchorText: normalizeSpace(activity.outcome) || normalizeSpace(activity.context),
        },
        null,
      );
      source.target = "_blank";
      source.rel = "noopener noreferrer";
      source.textContent = `מקור: ${activity.sourceLabel || "קישור חיצוני"}`;
      card.appendChild(source);
    }

    if (Array.isArray(activity.attachments) && activity.attachments.length) {
      const attachWrap = document.createElement("div");
      attachWrap.className = "attachments";

      activity.attachments.forEach((file) => {
        const line = document.createElement("p");
        line.className = "attach-line";
        line.textContent = `קובץ: ${file.name} (${formatBytes(file.size)})`;
        attachWrap.appendChild(line);

        if (file.previewDataUrl) {
          const preview = document.createElement("img");
          preview.className = "attach-preview";
          preview.src = file.previewDataUrl;
          preview.alt = file.name;
          attachWrap.appendChild(preview);
        }
      });

      card.appendChild(attachWrap);
    }

    dom.activitiesList.appendChild(card);
  });
}

function normalizeDraftWorkflowStatus(value) {
  const safe = normalizeSpace(value).toLowerCase();
  return safe === "review" ? "review" : "draft";
}

function sanitizeDraftRecord(draft) {
  if (!draft || typeof draft !== "object") {
    return null;
  }
  return {
    ...draft,
    workflowStatus: normalizeDraftWorkflowStatus(draft.workflowStatus || draft.status),
    rejectedReason: normalizeSpace(draft.rejectedReason),
    rejectedAt: normalizeSpace(draft.rejectedAt),
  };
}

function readDraftQueue() {
  return readStorage(STORAGE_KEYS.drafts, [])
    .map(sanitizeDraftRecord)
    .filter(Boolean);
}

function writeDraftQueue(drafts) {
  const sanitized = (drafts || [])
    .map(sanitizeDraftRecord)
    .filter(Boolean);
  return writeStorage(STORAGE_KEYS.drafts, sanitized.slice(0, 500));
}

function readDraftActionLog() {
  return readStorage(STORAGE_KEYS.draftActionLog, []);
}

function writeDraftActionLog(entries) {
  const safe = Array.isArray(entries) ? entries.slice(0, DRAFT_ACTION_LOG_LIMIT) : [];
  return writeStorage(STORAGE_KEYS.draftActionLog, safe);
}

function pushDraftActionLogEntry(entry) {
  const current = readDraftActionLog();
  const next = [entry, ...current].slice(0, DRAFT_ACTION_LOG_LIMIT);
  return writeDraftActionLog(next);
}

function popDraftActionLogEntry() {
  const current = readDraftActionLog();
  if (!current.length) {
    return null;
  }
  const [top, ...rest] = current;
  const saved = writeDraftActionLog(rest);
  return saved ? top : null;
}

function syncDraftSelection(allowedIds) {
  const allowed = new Set((allowedIds || []).map((id) => normalizeSpace(id)).filter(Boolean));
  adminState.draftSelectionIds = adminState.draftSelectionIds
    .map((id) => normalizeSpace(id))
    .filter((id) => allowed.has(id));
}

function clearDraftSelection() {
  adminState.draftSelectionIds = [];
  renderDrafts();
}

function selectVisibleDrafts() {
  adminState.draftSelectionIds = adminState.lastVisibleDraftIds.slice();
  renderDrafts();
}

function toggleDraftSelection(draftId, shouldSelect) {
  const safeId = normalizeSpace(draftId);
  if (!safeId) {
    return;
  }
  const set = new Set(adminState.draftSelectionIds);
  if (shouldSelect) {
    set.add(safeId);
  } else {
    set.delete(safeId);
  }
  adminState.draftSelectionIds = Array.from(set);
}

function setDraftQueueMessage(text, isOk) {
  if (!dom.draftQueueMsg) {
    return;
  }
  showMessage(dom.draftQueueMsg, text, isOk);
}

function hideDraftQueueMessage() {
  if (!dom.draftQueueMsg) {
    return;
  }
  hideMessage(dom.draftQueueMsg);
}

function promptDraftRejectReason(selectedCount) {
  const countText = selectedCount > 1 ? `${selectedCount} טיוטות` : "טיוטה אחת";
  const raw = window.prompt(
    `סיבת דחייה עבור ${countText}:`,
    "נדרש חידוד ניסוח/מקור לפני פרסום",
  );
  if (raw === null) {
    return null;
  }
  const reason = normalizeSpace(raw);
  if (!reason) {
    window.alert("נדרש להזין סיבת דחייה.");
    return null;
  }
  return clampText(reason, DRAFT_REJECT_REASON_MAX_LEN);
}

function getDraftQueueView() {
  const allDrafts = readDraftQueue();
  const statusFilter = normalizeSpace(dom.draftQueueStatusFilter?.value).toLowerCase() || "all";
  const searchText = normalizeSpace(dom.draftQueueSearchInput?.value).toLowerCase();
  const filtered = allDrafts.filter((draft) => {
    const status = normalizeDraftWorkflowStatus(draft.workflowStatus);
    if (statusFilter !== "all" && status !== statusFilter) {
      return false;
    }

    if (!searchText) {
      return true;
    }
    const sourceText = Array.isArray(draft.sources)
      ? draft.sources.map((source) => `${source.label} ${source.url}`).join(" ")
      : "";
    const haystack = `${draft.question} ${draft.learn} ${draft.explanation} ${draft.category} ${sourceText}`.toLowerCase();
    return haystack.includes(searchText);
  });

  const draftCount = allDrafts.filter((item) => normalizeDraftWorkflowStatus(item.workflowStatus) === "draft").length;
  const reviewCount = allDrafts.filter((item) => normalizeDraftWorkflowStatus(item.workflowStatus) === "review").length;

  adminState.lastVisibleDraftIds = filtered.map((item) => normalizeSpace(item.id)).filter(Boolean);
  syncDraftSelection(allDrafts.map((item) => normalizeSpace(item.id)).filter(Boolean));

  return {
    allDrafts,
    filtered,
    draftCount,
    reviewCount,
    selectedCount: adminState.draftSelectionIds.length,
  };
}

function renderDrafts() {
  const queue = getDraftQueueView();
  const { allDrafts, filtered, draftCount, reviewCount, selectedCount } = queue;
  dom.draftsList.innerHTML = "";

  if (dom.draftQueueSummary) {
    dom.draftQueueSummary.textContent =
      `סה"כ: ${allDrafts.length} | Draft: ${draftCount} | Review: ${reviewCount} | נבחרו: ${selectedCount}`;
  }

  const selectedSet = new Set(adminState.draftSelectionIds);
  const selectedDraftCount = allDrafts.filter(
    (item) => selectedSet.has(normalizeSpace(item.id))
      && normalizeDraftWorkflowStatus(item.workflowStatus) === "draft",
  ).length;
  const selectedReviewCount = allDrafts.filter(
    (item) => selectedSet.has(normalizeSpace(item.id))
      && normalizeDraftWorkflowStatus(item.workflowStatus) === "review",
  ).length;

  if (dom.moveDraftsToReviewBtn) {
    dom.moveDraftsToReviewBtn.disabled = selectedDraftCount === 0;
  }
  if (dom.moveDraftsToDraftBtn) {
    dom.moveDraftsToDraftBtn.disabled = selectedReviewCount === 0;
  }
  if (dom.approveSelectedDraftsBtn) {
    dom.approveSelectedDraftsBtn.disabled = selectedReviewCount === 0;
  }
  if (dom.rejectSelectedDraftsBtn) {
    dom.rejectSelectedDraftsBtn.disabled = selectedCount === 0;
  }
  if (dom.undoDraftActionBtn) {
    dom.undoDraftActionBtn.disabled = readDraftActionLog().length === 0;
  }
  if (dom.selectVisibleDraftsBtn) {
    dom.selectVisibleDraftsBtn.disabled = queue.filtered.length === 0;
  }
  if (dom.clearDraftSelectionBtn) {
    dom.clearDraftSelectionBtn.disabled = selectedCount === 0;
  }

  if (!allDrafts.length) {
    dom.draftsList.appendChild(makeInfoMessage("אין כרגע טיוטות בתור הפרסום."));
    return;
  }

  if (!filtered.length) {
    dom.draftsList.appendChild(makeInfoMessage("אין טיוטות שתואמות לפילטר הנוכחי."));
    return;
  }

  filtered.forEach((draft) => {
    const quality = evaluateDraftQuality(draft);
    const draftId = normalizeSpace(draft.id);
    const status = normalizeDraftWorkflowStatus(draft.workflowStatus);
    const isSelected = selectedSet.has(draftId);

    const card = document.createElement("article");
    card.className = "info-card";

    const title = document.createElement("h4");
    title.textContent = draft.question;

    const badgeRow = document.createElement("div");
    badgeRow.className = "badge-row";

    const statusBadge = document.createElement("span");
    statusBadge.className = `badge draft-status ${status}`;
    statusBadge.textContent = status === "review" ? "Review" : "Draft";

    const dateBadge = document.createElement("span");
    dateBadge.className = "badge";
    dateBadge.textContent = formatDateDisplay(draft.date);

    const categoryBadge = document.createElement("span");
    categoryBadge.className = "badge";
    categoryBadge.textContent = draft.category;

    badgeRow.appendChild(statusBadge);
    badgeRow.appendChild(dateBadge);
    badgeRow.appendChild(categoryBadge);

    const learn = document.createElement("p");
    learn.textContent = `רקע לשאלה: ${draft.learn}`;

    const optionsList = document.createElement("ul");
    optionsList.className = "sources-list";

    draft.options.forEach((option, index) => {
      const li = document.createElement("li");
      const prefix = index === draft.answer ? "תשובה נכונה" : "תשובה";
      li.textContent = `${prefix}: ${option}`;
      optionsList.appendChild(li);
    });

    const explain = document.createElement("p");
    explain.textContent = draft.explanation;

    const qualitySummary = document.createElement("p");
    qualitySummary.className = quality.isReadyToApprove ? "quality-summary ok" : "quality-summary bad";
    qualitySummary.textContent = quality.isReadyToApprove
      ? "צ'קליסט איכות: תקין - אפשר לפרסם אחרי Review."
      : "צ'קליסט איכות: חסרים סעיפים מחייבים, לא ניתן לפרסם עדיין.";

    const qualityList = renderDraftQualityChecklist(quality);

    const selectionRow = document.createElement("div");
    selectionRow.className = "inline-actions";

    const selectLabel = document.createElement("label");
    selectLabel.className = "draft-select-label";
    const selectInput = document.createElement("input");
    selectInput.type = "checkbox";
    selectInput.checked = isSelected;
    selectInput.addEventListener("change", () => {
      toggleDraftSelection(draftId, selectInput.checked);
      renderDrafts();
    });
    const selectText = document.createElement("span");
    selectText.textContent = "בחר לטיפול מרוכז";
    selectLabel.appendChild(selectInput);
    selectLabel.appendChild(selectText);
    selectionRow.appendChild(selectLabel);

    const actions = document.createElement("div");
    actions.className = "inline-actions";

    const toggleReviewBtn = document.createElement("button");
    toggleReviewBtn.type = "button";
    toggleReviewBtn.className = status === "review" ? "ghost-btn" : "secondary-btn";
    toggleReviewBtn.textContent = status === "review" ? "החזר ל-Draft" : "העבר ל-Review";
    toggleReviewBtn.addEventListener("click", () => {
      const nextStatus = status === "review" ? "draft" : "review";
      const drafts = readDraftQueue().map((item) =>
        normalizeSpace(item.id) === draftId
          ? { ...item, workflowStatus: nextStatus }
          : item);
      const saved = writeDraftQueue(drafts);
      if (!saved) {
        setDraftQueueMessage("עדכון הסטטוס נכשל בגלל מגבלת אחסון בדפדפן.", false);
        return;
      }
      setDraftQueueMessage(
        nextStatus === "review"
          ? "הטיוטה הועברה ל-Review."
          : "הטיוטה הוחזרה ל-Draft.",
        true,
      );
      renderDrafts();
      renderAdminStats();
    });

    const approveBtn = document.createElement("button");
    approveBtn.type = "button";
    approveBtn.className = "primary-btn";
    approveBtn.textContent = "פרסם למאגר";
    approveBtn.disabled = status !== "review" || !quality.isReadyToApprove;
    if (status !== "review") {
      approveBtn.title = "יש להעביר ל-Review לפני פרסום.";
    } else if (!quality.isReadyToApprove) {
      approveBtn.title = "יש לתקן את כל סעיפי החובה בצ'קליסט לפני פרסום.";
    }
    approveBtn.addEventListener("click", () => approveDraft(draftId));

    const rejectBtn = document.createElement("button");
    rejectBtn.type = "button";
    rejectBtn.className = "ghost-btn";
    rejectBtn.textContent = "דחה טיוטה";
    rejectBtn.addEventListener("click", () => rejectDraft(draftId));

    actions.appendChild(toggleReviewBtn);
    actions.appendChild(approveBtn);
    actions.appendChild(rejectBtn);

    card.appendChild(title);
    card.appendChild(badgeRow);
    card.appendChild(learn);
    card.appendChild(optionsList);
    card.appendChild(explain);
    card.appendChild(qualitySummary);
    card.appendChild(qualityList);

    if (Array.isArray(draft.sources) && draft.sources.length) {
      const sourceLine = document.createElement("a");
      sourceLine.href = buildPreferredSourceHref(draft.sources[0], draft);
      sourceLine.target = "_blank";
      sourceLine.rel = "noopener noreferrer";
      sourceLine.textContent = `מקור מוצע: ${draft.sources[0].label}`;
      card.appendChild(sourceLine);
    }

    card.appendChild(selectionRow);
    card.appendChild(actions);
    dom.draftsList.appendChild(card);
  });
}

function moveSelectedDraftsToStatus(nextStatus) {
  const targetStatus = normalizeDraftWorkflowStatus(nextStatus);
  const selectedSet = new Set(adminState.draftSelectionIds.map((id) => normalizeSpace(id)));
  if (!selectedSet.size) {
    setDraftQueueMessage("לא נבחרו טיוטות לעדכון.", false);
    return;
  }

  const drafts = readDraftQueue();
  let changedCount = 0;
  const updated = drafts.map((draft) => {
    const safeId = normalizeSpace(draft.id);
    if (!selectedSet.has(safeId)) {
      return draft;
    }
    const currentStatus = normalizeDraftWorkflowStatus(draft.workflowStatus);
    if (currentStatus === targetStatus) {
      return draft;
    }
    changedCount += 1;
    return { ...draft, workflowStatus: targetStatus };
  });

  if (!changedCount) {
    setDraftQueueMessage("הטיוטות שנבחרו כבר נמצאות בסטטוס הזה.", false);
    return;
  }

  const saved = writeDraftQueue(updated);
  if (!saved) {
    setDraftQueueMessage("עדכון הסטטוס נכשל בגלל מגבלת אחסון בדפדפן.", false);
    return;
  }

  setDraftQueueMessage(
    targetStatus === "review"
      ? `הועברו ${changedCount} טיוטות ל-Review.`
      : `הוחזרו ${changedCount} טיוטות ל-Draft.`,
    true,
  );
  renderDrafts();
  renderAdminStats();
}

function approveSelectedDrafts() {
  const selectedSet = new Set(adminState.draftSelectionIds.map((id) => normalizeSpace(id)));
  if (!selectedSet.size) {
    setDraftQueueMessage("לא נבחרו טיוטות לפרסום.", false);
    return;
  }

  const drafts = readDraftQueue();
  const selectedReviewIds = drafts
    .filter((draft) =>
      selectedSet.has(normalizeSpace(draft.id))
      && normalizeDraftWorkflowStatus(draft.workflowStatus) === "review")
    .map((draft) => draft.id);

  if (!selectedReviewIds.length) {
    setDraftQueueMessage("רק טיוטות ב-Review ניתנות לפרסום.", false);
    return;
  }

  const result = approveDraftsBulk(selectedReviewIds, { requireReview: true });
  if (!result) {
    setDraftQueueMessage("פרסום מרוכז נכשל בגלל מגבלת אחסון בדפדפן.", false);
    return;
  }

  const notReadyCount = Math.max(0, result.skippedCount);
  setDraftQueueMessage(
    `פורסמו ${result.approvedCount} טיוטות למאגר.${notReadyCount ? ` דולגו ${notReadyCount} טיוטות שלא עברו צ'קליסט.` : ""}`,
    true,
  );
  renderAdminStats();
  renderDrafts();
  renderCustomQuestions();
  renderAllQuestionsManager();
  renderLongTextDraftsPreview();
}

function rejectSelectedDrafts() {
  const selectedSet = new Set(adminState.draftSelectionIds.map((id) => normalizeSpace(id)));
  if (!selectedSet.size) {
    setDraftQueueMessage("לא נבחרו טיוטות לדחייה.", false);
    return;
  }

  const drafts = readDraftQueue();
  const selectedDrafts = drafts.filter((draft) => selectedSet.has(normalizeSpace(draft.id)));
  if (!selectedDrafts.length) {
    setDraftQueueMessage("לא נמצאו טיוטות תואמות לבחירה.", false);
    return;
  }

  const rejectReason = promptDraftRejectReason(selectedDrafts.length);
  if (rejectReason === null) {
    return;
  }

  const selectedIds = new Set(selectedDrafts.map((draft) => normalizeSpace(draft.id)));
  const remaining = drafts.filter((draft) => !selectedIds.has(normalizeSpace(draft.id)));
  const saved = writeDraftQueue(remaining);
  if (!saved) {
    setDraftQueueMessage("דחיית הטיוטות נכשלה בגלל מגבלת אחסון בדפדפן.", false);
    return;
  }

  const rejectedAt = new Date().toISOString();
  pushDraftActionLogEntry({
    id: uid("draft_action"),
    type: "reject",
    createdAt: rejectedAt,
    reason: rejectReason,
    drafts: selectedDrafts.map((draft) => ({
      ...draft,
      workflowStatus: "draft",
      rejectedAt,
      rejectedReason: rejectReason,
    })),
  });

  adminState.lastLongTextBatchDraftIds = adminState.lastLongTextBatchDraftIds
    .filter((item) => !selectedIds.has(normalizeSpace(item)));
  dom.approveAllTextDraftsBtn.disabled = adminState.lastLongTextBatchDraftIds.length === 0;
  adminState.draftSelectionIds = [];

  setDraftQueueMessage(`נדחו ${selectedDrafts.length} טיוטות. ניתן לבצע Undo.`, true);
  renderAdminStats();
  renderDrafts();
  renderAllQuestionsManager();
  renderLongTextDraftsPreview();
}

function undoLastDraftAction() {
  const action = popDraftActionLogEntry();
  if (!action) {
    setDraftQueueMessage("אין פעולה אחרונה לביטול.", false);
    return;
  }

  if (action.type !== "reject" || !Array.isArray(action.drafts) || !action.drafts.length) {
    setDraftQueueMessage("לא ניתן לבטל את הפעולה האחרונה.", false);
    return;
  }

  const currentDrafts = readDraftQueue();
  const restored = action.drafts
    .map((draft) => sanitizeDraftRecord({
      ...draft,
      workflowStatus: normalizeDraftWorkflowStatus(draft.workflowStatus || "draft"),
    }))
    .filter(Boolean);
  const restoredIds = new Set(restored.map((item) => normalizeSpace(item.id)));
  const merged = [...restored, ...currentDrafts.filter((item) => !restoredIds.has(normalizeSpace(item.id)))];

  const saved = writeDraftQueue(merged);
  if (!saved) {
    setDraftQueueMessage("ביטול הפעולה נכשל בגלל מגבלת אחסון בדפדפן.", false);
    return;
  }

  const restoredBatchIds = restored
    .map((draft) => normalizeSpace(draft.id))
    .filter(Boolean);
  adminState.lastLongTextBatchDraftIds = Array.from(new Set([
    ...restoredBatchIds,
    ...adminState.lastLongTextBatchDraftIds,
  ]));
  dom.approveAllTextDraftsBtn.disabled = adminState.lastLongTextBatchDraftIds.length === 0;

  setDraftQueueMessage(`בוצע Undo. הוחזרו ${restored.length} טיוטות לתור.`, true);
  renderAdminStats();
  renderDrafts();
  renderAllQuestionsManager();
  renderLongTextDraftsPreview();
}

function approveDraft(draftId) {
  const safeId = normalizeSpace(draftId);
  if (!safeId) {
    return;
  }

  const result = approveDraftsBulk([safeId], { requireReview: true });
  if (!result) {
    setDraftQueueMessage("פרסום הטיוטה נכשל בגלל מגבלת אחסון בדפדפן.", false);
    return;
  }
  if (!result.approvedCount) {
    setDraftQueueMessage("לא ניתן לפרסם: הטיוטה לא ב-Review או לא עברה צ'קליסט איכות.", false);
    renderDrafts();
    return;
  }

  setDraftQueueMessage("הטיוטה פורסמה למאגר בהצלחה.", true);
  renderAdminStats();
  renderDrafts();
  renderCustomQuestions();
  renderAllQuestionsManager();
  renderLongTextDraftsPreview();
}

function rejectDraft(draftId) {
  const safeId = normalizeSpace(draftId);
  if (!safeId) {
    return;
  }

  const drafts = readDraftQueue();
  const target = drafts.find((item) => normalizeSpace(item.id) === safeId);
  if (!target) {
    return;
  }

  const rejectReason = promptDraftRejectReason(1);
  if (rejectReason === null) {
    return;
  }

  const remaining = drafts.filter((item) => normalizeSpace(item.id) !== safeId);
  const saved = writeDraftQueue(remaining);
  if (!saved) {
    setDraftQueueMessage("דחיית הטיוטה נכשלה בגלל מגבלת אחסון בדפדפן.", false);
    return;
  }

  const rejectedAt = new Date().toISOString();
  pushDraftActionLogEntry({
    id: uid("draft_action"),
    type: "reject",
    createdAt: rejectedAt,
    reason: rejectReason,
    drafts: [{
      ...target,
      workflowStatus: "draft",
      rejectedAt,
      rejectedReason: rejectReason,
    }],
  });

  adminState.lastLongTextBatchDraftIds = adminState.lastLongTextBatchDraftIds
    .filter((item) => normalizeSpace(item) !== safeId);
  dom.approveAllTextDraftsBtn.disabled = adminState.lastLongTextBatchDraftIds.length === 0;

  setDraftQueueMessage("הטיוטה נדחתה ונשמרה סיבת הדחייה (זמין Undo).", true);
  renderAdminStats();
  renderDrafts();
  renderAllQuestionsManager();
  renderLongTextDraftsPreview();
}

function renderDraftQualityChecklist(quality) {
  const list = document.createElement("ul");
  list.className = "quality-checklist";

  quality.checks.forEach((check) => {
    const item = document.createElement("li");
    item.className = `quality-item ${check.pass ? "pass" : "fail"}`;

    const requiredTag = check.required ? " (חובה)" : " (מומלץ)";
    item.textContent = `${check.pass ? "✓" : "✕"} ${check.label}${requiredTag}`;
    list.appendChild(item);
  });

  return list;
}

function evaluateDraftQuality(draft) {
  const questionText = normalizeSpace(draft?.question);
  const explanationText = normalizeSpace(draft?.explanation);
  const options = Array.isArray(draft?.options)
    ? draft.options.map((option) => normalizeSpace(option)).filter(Boolean)
    : [];
  const uniqueOptions = new Set(options.map((option) => option.toLowerCase()));
  const answerIndex = Number(draft?.answer);
  const validAnswer = Number.isInteger(answerIndex) && answerIndex >= 0 && answerIndex < options.length;
  const hasSource = Array.isArray(draft?.sources) && draft.sources.some((source) => normalizeSpace(source?.url));
  const notDateOnly = !isDateOnlyQuestion(questionText);

  const checks = [
    {
      key: "question_len",
      label: "ניסוח ברור ומלמד (לא קצר מדי)",
      pass: questionText.length >= QUALITY_MIN_QUESTION_LEN,
      required: true,
    },
    {
      key: "not_date_only",
      label: "השאלה אינה מבוססת רק על תאריך",
      pass: notDateOnly,
      required: true,
    },
    {
      key: "options_count",
      label: "יש לפחות 4 אפשרויות תשובה",
      pass: options.length >= 4,
      required: true,
    },
    {
      key: "options_unique",
      label: "אפשרויות התשובה שונות זו מזו",
      pass: uniqueOptions.size >= 4,
      required: true,
    },
    {
      key: "answer_valid",
      label: "תשובה נכונה מוגדרת באופן תקין",
      pass: validAnswer,
      required: true,
    },
    {
      key: "explanation_len",
      label: "הסבר תשובה מפורט ללמידה",
      pass: explanationText.length >= QUALITY_MIN_EXPLANATION_LEN,
      required: true,
    },
    {
      key: "has_source",
      label: "מצורף מקור לבדיקה",
      pass: hasSource,
      required: false,
    },
  ];

  const isReadyToApprove = checks.filter((item) => item.required).every((item) => item.pass);
  return { checks, isReadyToApprove };
}

function isDateOnlyQuestion(questionText) {
  const text = normalizeSpace(questionText).toLowerCase();
  if (!text) {
    return true;
  }

  const asksDateDirectly = /(?:^|\s)(מתי|באיזה תאריך|מה התאריך|באיזה יום|באיזה חודש|באיזו שנה|באיזה שנה)(?:\s|$)/.test(
    text,
  );
  const dateLikeTokens =
    (text.match(/\b20\d{2}\b/g) || []).length +
    (text.match(/\d{1,2}[./-]\d{1,2}(?:[./-]\d{2,4})?/g) || []).length;
  const educationalHits = EDUCATIONAL_KEYWORDS.filter((keyword) =>
    text.includes(keyword.toLowerCase()),
  ).length;
  const conceptualPrompt = /(?:מה התוצאה|מה המשמעות|למה|איזו פעולה|איזה שינוי|מה הייתה הדרישה|מה הייתה הביקורת|מה המסקנה)/.test(
    text,
  );

  if (!asksDateDirectly) {
    return false;
  }

  if (conceptualPrompt || educationalHits > 0) {
    return false;
  }

  return dateLikeTokens > 0 || text.length <= 80;
}

function normalizeSpace(value) {
  return String(value || "").replace(/\s+/g, " ").trim();
}

function looksLikeDateOption(text) {
  const value = normalizeSpace(text);
  return /^\d{1,2}[./-]\d{1,2}[./-]\d{2,4}$/.test(value);
}

function looksLikeNumericOption(text) {
  const value = normalizeSpace(text);
  if (!value) {
    return false;
  }

  if (/^\d{1,3}(?:,\d{3})*$/.test(value)) {
    return true;
  }

  return /^\d+$/.test(value);
}

function inferExpectedOptionShape(questionText, answerText) {
  const safeQuestionText = normalizeSpace(questionText).toLowerCase();
  const safeAnswerText = normalizeSpace(answerText);

  if (looksLikeDateOption(safeAnswerText)) {
    return "date";
  }

  const asksNumeric = /(?:^|\s)(כמה|יעד|מספר|לכמה|כמה\s+זמן)(?:\s|$)/.test(safeQuestionText);
  if (asksNumeric && looksLikeNumericOption(safeAnswerText)) {
    return "number";
  }

  return "text";
}

function countWords(text) {
  return normalizeSpace(text).split(" ").filter(Boolean).length;
}

function isDistractorQualityAcceptable(optionText, shape) {
  const value = normalizeSpace(optionText);
  if (!value) {
    return false;
  }

  if (shape === "date") {
    return looksLikeDateOption(value);
  }

  if (shape === "number") {
    return looksLikeNumericOption(value);
  }

  if (value.length < 8 || countWords(value) < 2) {
    return false;
  }

  return !LOW_QUALITY_DISTRACTOR_PATTERNS.some((pattern) => pattern.test(value));
}

function getAuditIssueWeight(level) {
  if (level === "high") {
    return 2;
  }
  return 1;
}

function getAuditLevelLabel(level) {
  return level === "high" ? "חמור" : "בינוני";
}

function summarizeAuditIssueLevel(issues) {
  if (!Array.isArray(issues) || !issues.length) {
    return "none";
  }
  return issues.some((issue) => issue.level === "high") ? "high" : "medium";
}

function normalizeQuestionForSemanticComparison(text) {
  return splitMeaningfulWords(text).map((word) => word.toLowerCase());
}

function calculateSemanticQuestionSimilarity(questionA, questionB) {
  const tokensA = new Set(normalizeQuestionForSemanticComparison(questionA));
  const tokensB = new Set(normalizeQuestionForSemanticComparison(questionB));
  if (!tokensA.size || !tokensB.size) {
    return 0;
  }
  let intersection = 0;
  tokensA.forEach((token) => {
    if (tokensB.has(token)) {
      intersection += 1;
    }
  });
  const union = new Set([...tokensA, ...tokensB]).size;
  if (!union) {
    return 0;
  }
  return intersection / union;
}

function buildSemanticDuplicateMap(questions) {
  const rows = Array.isArray(questions) ? questions : [];
  const duplicateMap = new Map();
  for (let i = 0; i < rows.length; i += 1) {
    for (let j = i + 1; j < rows.length; j += 1) {
      const left = rows[i];
      const right = rows[j];
      const leftId = normalizeSpace(left?.id);
      const rightId = normalizeSpace(right?.id);
      if (!leftId || !rightId) {
        continue;
      }
      const similarity = calculateSemanticQuestionSimilarity(left?.question, right?.question);
      if (similarity < SEMANTIC_DUPLICATE_MIN_SIMILARITY) {
        continue;
      }

      if (!duplicateMap.has(leftId)) {
        duplicateMap.set(leftId, []);
      }
      if (!duplicateMap.has(rightId)) {
        duplicateMap.set(rightId, []);
      }

      duplicateMap.get(leftId).push({
        id: rightId,
        question: normalizeSpace(right?.question),
        similarity,
      });
      duplicateMap.get(rightId).push({
        id: leftId,
        question: normalizeSpace(left?.question),
        similarity,
      });
    }
  }

  duplicateMap.forEach((matches, key) => {
    const sorted = matches
      .slice()
      .sort((a, b) => b.similarity - a.similarity)
      .slice(0, 3);
    duplicateMap.set(key, sorted);
  });

  return duplicateMap;
}

function auditSingleQuestionDetailed(question, auditContext = {}) {
  const safeQuestion = question || {};
  const questionText = normalizeSpace(safeQuestion.question);
  const explanationText = normalizeSpace(safeQuestion.explanation);
  const options = sanitizeOptionsList(safeQuestion.options);
  const questionId = normalizeSpace(safeQuestion.id) || "unknown";
  const answerIndex = resolveAnswerIndex(
    safeQuestion.answer,
    options,
    safeQuestion.options,
  );
  const correctAnswer = options[answerIndex] || "";
  const issues = [];

  if (questionText.length < QUALITY_MIN_QUESTION_LEN) {
    issues.push({ level: "medium", message: "נוסח השאלה קצר מדי" });
  }

  if (isDateOnlyQuestion(questionText)) {
    issues.push({ level: "medium", message: "השאלה מבוססת בעיקר על תאריך ללא ערך מושגי" });
  }

  if (options.length < 4) {
    issues.push({ level: "high", message: "פחות מ-4 אפשרויות תשובה" });
  }

  if (new Set(options.map((option) => option.toLowerCase())).size < 4) {
    issues.push({ level: "high", message: "יש כפילות בין אפשרויות התשובה" });
  }

  if (!correctAnswer) {
    issues.push({ level: "high", message: "תשובה נכונה לא מוגדרת באופן תקין" });
  }

  if (explanationText.length < QUALITY_MIN_EXPLANATION_LEN) {
    issues.push({ level: "medium", message: "הסבר התשובה קצר מדי" });
  }

  const normalizedSources = normalizeQuestionSources(safeQuestion.sources, safeQuestion);
  const hasAnySource = normalizedSources.length > 0;
  if (!hasAnySource) {
    issues.push({ level: "high", message: "אין מקור תקין לשאלה" });
  } else {
    const brokenSources = normalizedSources.filter((source) =>
      isLikelyBrokenMqgSourceUrl(source?.url));
    if (brokenSources.length) {
      const firstBroken = brokenSources[0];
      const suggestionUrl = buildInternalSourceSearchHref(firstBroken, safeQuestion);
      issues.push({
        level: "high",
        message: `זוהה מקור פגום או שבור. מומלץ להחליף לקישור ישיר או להשתמש במקור חלופי: ${suggestionUrl}`,
      });
    }

    const hasPreciseSource = normalizedSources.some((source) => {
      const registry = getSourceRegistryEntry(source, safeQuestion);
      if (normalizeSpace(registry?.canonicalUrl)) {
        return true;
      }
      const directHref = buildDirectSourceHref(source, safeQuestion);
      return Boolean(directHref && !isLikelyBrokenMqgSourceUrl(directHref));
    });
    if (!hasPreciseSource) {
      issues.push({ level: "medium", message: "המקור אינו ממוקד דיו ודורש אימות ידני" });
    }
  }

  const shape = inferExpectedOptionShape(questionText, correctAnswer);
  const weakDistractors = [];
  options.forEach((optionText, index) => {
    if (index === answerIndex) {
      return;
    }
    if (!isDistractorQualityAcceptable(optionText, shape)) {
      weakDistractors.push(optionText);
    }
  });
  weakDistractors.slice(0, 2).forEach((optionText) => {
    issues.push({
      level: "medium",
      message: `מסיח חלש או לא עקבי: "${clampText(optionText, 40)}"`,
    });
  });
  if (weakDistractors.length > 2) {
    issues.push({
      level: "medium",
      message: `נמצאו עוד ${weakDistractors.length - 2} מסיחים חלשים נוספים`,
    });
  }

  if (shape === "number" && options.length >= 4 && options.every((optionText) => looksLikeNumericOption(optionText))) {
    issues.push({ level: "medium", message: "אפשרויות מספריות בלבד - מומלץ להוסיף הקשר טקסטואלי" });
  }

  if (auditContext?.semanticDuplicateMap instanceof Map) {
    const duplicates = auditContext.semanticDuplicateMap.get(questionId) || [];
    if (duplicates.length) {
      const top = duplicates[0];
      const severity = top.similarity >= 0.88 ? "high" : "medium";
      issues.push({
        level: severity,
        message: `כפילויות סמנטיות: דומה לשאלה ${top.id} (${Math.round(top.similarity * 100)}%). מומלץ לאחד או לחדד ניסוח.`,
      });
    }
  }

  return {
    id: questionId,
    issues,
  };
}

function auditSingleQuestionContent(question) {
  const detailed = auditSingleQuestionDetailed(question);
  return {
    id: detailed.id,
    issues: detailed.issues.map((issue) => issue.message),
  };
}

function auditQuestionBankContent(questions) {
  const sourceList = Array.isArray(questions) ? questions : [];
  const issuesById = {};
  let totalIssues = 0;

  sourceList.forEach((question) => {
    const audit = auditSingleQuestionContent(question);
    if (!audit.issues.length) {
      return;
    }
    issuesById[audit.id] = audit.issues;
    totalIssues += audit.issues.length;
  });

  return {
    reviewedCount: sourceList.length,
    totalIssues,
    issuesById,
  };
}

function getQuestionQualityIssues(question) {
  const baseId = getBaseQuestionId(question);
  if (baseId && BASE_QUESTION_CONTENT_AUDIT.issuesById[baseId]) {
    return BASE_QUESTION_CONTENT_AUDIT.issuesById[baseId];
  }

  return auditSingleQuestionContent(question).issues;
}

function buildQuestionAuditFingerprint(inventory) {
  const safeInventory = inventory || getQuestionInventory();
  const questionSignature = safeInventory.allQuestions
    .map((question) => {
      const optionsText = sanitizeOptionsList(question.options).join("|");
      const sourcesText = normalizeQuestionSources(question.sources, question)
        .map((source) => `${normalizeSpace(source.label)}|${normalizeSpace(source.url)}`)
        .join("|");
      return [
        normalizeSpace(question.id),
        normalizeSpace(question.question),
        normalizeSpace(question.learn),
        normalizeSpace(question.explanation),
        optionsText,
        String(question.answer),
        sourcesText,
      ].join("~~");
    })
    .sort()
    .join("###");

  const disabledIdsText = Array.from(safeInventory.disabledIds || [])
    .sort()
    .join("|");
  return `${questionSignature}@@${disabledIdsText}`;
}

function buildQuestionBankAuditReport(inventory) {
  const safeInventory = inventory || getQuestionInventory();
  const semanticDuplicateMap = buildSemanticDuplicateMap(safeInventory.allQuestions);
  const findings = [];
  let highIssueCount = 0;
  let mediumIssueCount = 0;

  safeInventory.allQuestions.forEach((question) => {
    const detailed = auditSingleQuestionDetailed(question, { semanticDuplicateMap });
    if (!detailed.issues.length) {
      return;
    }

    detailed.issues.forEach((issue) => {
      if (issue.level === "high") {
        highIssueCount += 1;
      } else {
        mediumIssueCount += 1;
      }
    });

    findings.push({
      id: detailed.id,
      question: normalizeSpace(question.question),
      category: normalizeSpace(question.category) || "ללא קטגוריה",
      disabled: safeInventory.disabledIds.has(detailed.id),
      issues: detailed.issues,
      level: summarizeAuditIssueLevel(detailed.issues),
    });
  });

  findings.sort((a, b) => {
    const levelDiff = getAuditIssueWeight(b.level) - getAuditIssueWeight(a.level);
    if (levelDiff !== 0) {
      return levelDiff;
    }
    return a.id.localeCompare(b.id, "he");
  });

  const highQuestionCount = findings.filter((item) => item.level === "high").length;
  const reportLevel = findings.length === 0
    ? "ready"
    : highQuestionCount > 0
      ? "blocked"
      : "warning";

  return {
    generatedAt: new Date().toISOString(),
    reviewedCount: safeInventory.allQuestions.length,
    activeCount: safeInventory.activeQuestions.length,
    hiddenCount: safeInventory.disabledIds.size,
    findings,
    highIssueCount,
    mediumIssueCount,
    highQuestionCount,
    warningQuestionCount: Math.max(0, findings.length - highQuestionCount),
    reportLevel,
    fingerprint: buildQuestionAuditFingerprint(safeInventory),
  };
}

function setQuestionAuditStatus(text, tone) {
  dom.questionAuditStatus.textContent = text;
  dom.questionAuditStatus.classList.remove("hidden", "ok", "warn");
  if (tone === "ok") {
    dom.questionAuditStatus.classList.add("ok");
  } else if (tone === "warn") {
    dom.questionAuditStatus.classList.add("warn");
  }
}

function clearQuestionAuditStatus() {
  dom.questionAuditStatus.textContent = "";
  dom.questionAuditStatus.classList.add("hidden");
  dom.questionAuditStatus.classList.remove("ok", "warn");
}

function runQuestionBankAudit() {
  const inventory = getQuestionInventory();
  adminState.questionAuditReport = buildQuestionBankAuditReport(inventory);
  renderQuestionAuditReport(inventory);
}

function clearQuestionBankAuditReport() {
  adminState.questionAuditReport = null;
  renderQuestionAuditReport(getQuestionInventory());
}

function renderQuestionAuditReport(inventoryInput) {
  const inventory = inventoryInput || getQuestionInventory();
  const report = adminState.questionAuditReport;
  dom.questionAuditResults.innerHTML = "";

  if (!report) {
    dom.questionAuditResults.classList.add("hidden");
    clearQuestionAuditStatus();
    return;
  }

  const isStale = report.fingerprint !== buildQuestionAuditFingerprint(inventory);
  if (isStale) {
    setQuestionAuditStatus("דוח ה-Audit לא מעודכן: המאגר השתנה מאז הריצה האחרונה. מומלץ להריץ שוב.", "warn");
  } else if (report.reportLevel === "ready") {
    setQuestionAuditStatus("Audit הושלם: המאגר מוכן לפרסום.", "ok");
  } else if (report.reportLevel === "warning") {
    setQuestionAuditStatus(
      `Audit הושלם: נמצאו ${report.findings.length} שאלות לשיפור (ללא חריגות קריטיות).`,
      "warn",
    );
  } else {
    setQuestionAuditStatus(
      `Audit הושלם: נמצאו ${report.highQuestionCount} שאלות עם חריגות קריטיות. לא מומלץ לפרסם עדיין.`,
      "bad",
    );
  }

  dom.questionAuditResults.classList.remove("hidden");

  const summaryCard = document.createElement("article");
  summaryCard.className = "info-card audit-summary";

  const summaryTitle = document.createElement("h4");
  summaryTitle.textContent = "סיכום Audit";

  const generatedAt = new Date(report.generatedAt);
  const generatedAtText = Number.isNaN(generatedAt.getTime())
    ? report.generatedAt
    : generatedAt.toLocaleString("he-IL");

  const summaryMeta = document.createElement("p");
  summaryMeta.className = "muted";
  summaryMeta.textContent =
    `נבדקו ${report.reviewedCount} שאלות ` +
    `(פעילות: ${report.activeCount}, מוסתרות: ${report.hiddenCount}) | ` +
    `חריגות חמורות: ${report.highIssueCount}, חריגות בינוניות: ${report.mediumIssueCount} | ` +
    `עודכן: ${generatedAtText}`;

  summaryCard.appendChild(summaryTitle);
  summaryCard.appendChild(summaryMeta);
  dom.questionAuditResults.appendChild(summaryCard);

  if (!report.findings.length) {
    return;
  }

  report.findings.forEach((finding) => {
    const card = document.createElement("article");
    card.className = "info-card audit-item";

    const badgeRow = document.createElement("div");
    badgeRow.className = "badge-row";

    const levelBadge = document.createElement("span");
    levelBadge.className = `badge audit-level ${finding.level === "high" ? "bad" : "warn"}`;
    levelBadge.textContent = `רמת חומרה: ${getAuditLevelLabel(finding.level)}`;

    const statusBadge = document.createElement("span");
    statusBadge.className = "badge";
    statusBadge.textContent = finding.disabled ? "מוסתרת מהמשחק" : "פעילה במשחק";

    const categoryBadge = document.createElement("span");
    categoryBadge.className = "badge";
    categoryBadge.textContent = finding.category;

    badgeRow.appendChild(levelBadge);
    badgeRow.appendChild(statusBadge);
    badgeRow.appendChild(categoryBadge);

    const title = document.createElement("h4");
    title.textContent = finding.question || `שאלה ${finding.id}`;

    const idLine = document.createElement("p");
    idLine.className = "muted";
    idLine.textContent = `מזהה: ${finding.id}`;

    const issuesList = document.createElement("ul");
    issuesList.className = "quality-checklist";
    finding.issues.forEach((issue) => {
      const item = document.createElement("li");
      item.className = "quality-item fail";
      item.textContent = `✕ [${getAuditLevelLabel(issue.level)}] ${issue.message}`;
      issuesList.appendChild(item);
    });

    const actions = document.createElement("div");
    actions.className = "inline-actions";

    const editBtn = document.createElement("button");
    editBtn.type = "button";
    editBtn.className = "ghost-btn";
    editBtn.textContent = "ערוך שאלה";
    editBtn.addEventListener("click", () => editQuestion(finding.id));

    actions.appendChild(editBtn);

    card.appendChild(badgeRow);
    card.appendChild(title);
    card.appendChild(idLine);
    card.appendChild(issuesList);
    card.appendChild(actions);
    dom.questionAuditResults.appendChild(card);
  });
}

function renderCustomQuestions() {
  const customQuestions = readStorage(STORAGE_KEYS.customQuestions, []);
  dom.customQuestionsList.innerHTML = "";

  if (!customQuestions.length) {
    dom.customQuestionsList.appendChild(makeInfoMessage("אין עדיין שאלות מותאמות שאושרו."));
    return;
  }

  customQuestions.forEach((question) => {
    const card = document.createElement("article");
    card.className = "info-card";

    const title = document.createElement("h4");
    title.textContent = question.question;

    const badgeRow = document.createElement("div");
    badgeRow.className = "badge-row";

    const dateBadge = document.createElement("span");
    dateBadge.className = "badge";
    dateBadge.textContent = formatDateDisplay(question.date);

    const categoryBadge = document.createElement("span");
    categoryBadge.className = "badge";
    categoryBadge.textContent = question.category;

    badgeRow.appendChild(dateBadge);
    badgeRow.appendChild(categoryBadge);

    const answerLine = document.createElement("p");
    answerLine.textContent = `תשובה נכונה: ${question.options[question.answer]}`;

    card.appendChild(title);
    card.appendChild(badgeRow);
    card.appendChild(answerLine);

    if (Array.isArray(question.sources) && question.sources.length) {
      const source = document.createElement("a");
      source.href = buildPreferredSourceHref(question.sources[0], question);
      source.target = "_blank";
      source.rel = "noopener noreferrer";
      source.textContent = `מקור: ${question.sources[0].label}`;
      card.appendChild(source);
    }

    dom.customQuestionsList.appendChild(card);
  });
}

function resetQuestionFilters() {
  if (dom.questionSearchInput) {
    dom.questionSearchInput.value = "";
  }
  if (dom.questionCategoryFilter) {
    dom.questionCategoryFilter.value = "all";
  }
  if (dom.questionKindFilter) {
    dom.questionKindFilter.value = "all";
  }
  if (dom.questionVisibilityFilter) {
    dom.questionVisibilityFilter.value = "all";
  }
  if (dom.questionSourceFilter) {
    dom.questionSourceFilter.value = "all";
  }
  if (dom.questionDateFrom) {
    dom.questionDateFrom.value = "";
  }
  if (dom.questionDateTo) {
    dom.questionDateTo.value = "";
  }
  if (dom.questionSortMode) {
    dom.questionSortMode.value = "default";
  }
  renderAllQuestionsManager();
}

function normalizeQuestionKindFilterValue(value) {
  const safe = normalizeSpace(value).toLowerCase();
  if (safe === "success") {
    return "success";
  }
  if (safe === "activity") {
    return "activity";
  }
  return "";
}

function normalizeFilterDateValue(value) {
  const safe = normalizeSpace(value);
  return /^\d{4}-\d{2}-\d{2}$/.test(safe) ? safe : "";
}

function buildQuestionPerformanceMap() {
  const rows = buildQuestionLearningRows(readStorage(STORAGE_KEYS.attempts, []));
  const map = new Map();
  rows.forEach((row) => {
    map.set(normalizeSpace(row.id), row);
  });
  return map;
}

function buildQuestionQualitySnapshot(question) {
  const audit = auditSingleQuestionDetailed(question);
  const highCount = audit.issues.filter((item) => item.level === "high").length;
  const mediumCount = Math.max(0, audit.issues.length - highCount);
  return {
    issues: audit.issues,
    highCount,
    mediumCount,
    riskScore: highCount * 6 + mediumCount * 2,
    topIssue: audit.issues[0]?.message || "",
  };
}

function sortQuestionManagerRows(rows, sortMode) {
  if (!Array.isArray(rows) || rows.length <= 1) {
    return rows || [];
  }

  const safeMode = normalizeSpace(sortMode).toLowerCase() || "default";
  if (safeMode === "newest") {
    rows.sort((a, b) => {
      if (a.date !== b.date) {
        return a.date < b.date ? 1 : -1;
      }
      return a.questionText.localeCompare(b.questionText, "he");
    });
    return rows;
  }

  if (safeMode === "hardest") {
    rows.sort((a, b) => {
      const aRisk = Number(a.performance?.riskScore || -1);
      const bRisk = Number(b.performance?.riskScore || -1);
      if (aRisk !== bRisk) {
        return bRisk - aRisk;
      }
      const aSample = Number(a.performance?.total || 0);
      const bSample = Number(b.performance?.total || 0);
      if (aSample !== bSample) {
        return bSample - aSample;
      }
      return a.questionText.localeCompare(b.questionText, "he");
    });
    return rows;
  }

  if (safeMode === "quality-risk") {
    rows.sort((a, b) => {
      if (a.quality.riskScore !== b.quality.riskScore) {
        return b.quality.riskScore - a.quality.riskScore;
      }
      return a.questionText.localeCompare(b.questionText, "he");
    });
    return rows;
  }

  return rows;
}

function renderAllQuestionsManager() {
  const inventory = getQuestionInventory();
  const searchText = normalizeSpace(dom.questionSearchInput?.value).toLowerCase();
  const selectedCategory = normalizeSpace(dom.questionCategoryFilter?.value);
  const selectedKind = normalizeQuestionKindFilterValue(dom.questionKindFilter?.value);
  const visibilityFilter = normalizeSpace(dom.questionVisibilityFilter?.value).toLowerCase() || "all";
  const sourceFilter = normalizeSpace(dom.questionSourceFilter?.value).toLowerCase() || "all";
  const dateFrom = normalizeFilterDateValue(dom.questionDateFrom?.value);
  const dateTo = normalizeFilterDateValue(dom.questionDateTo?.value);
  const sortMode = normalizeSpace(dom.questionSortMode?.value).toLowerCase() || "default";

  const customIds = new Set(
    readStorage(STORAGE_KEYS.customQuestions, [])
      .map((item) => normalizeSpace(item?.id))
      .filter(Boolean),
  );
  const performanceMap = buildQuestionPerformanceMap();

  const rows = inventory.allQuestions.map((question) => {
    const id = normalizeSpace(question.id);
    const questionText = normalizeSpace(question.question) || `שאלה ${id || "ללא מזהה"}`;
    const kind = normalizeQuestionKindFilterValue(question.kind) || "activity";
    const date = normalizeFilterDateValue(question.date);
    const disabled = inventory.disabledIds.has(id);
    const isCustom = customIds.has(id);
    const hasSource = normalizeQuestionSources(question.sources, question).length > 0;
    const quality = buildQuestionQualitySnapshot(question);
    const performance = performanceMap.get(id) || null;

    const sourceText = Array.isArray(question.sources)
      ? question.sources.map((source) => `${source?.label || ""} ${source?.url || ""}`).join(" ")
      : "";
    const haystack = [
      id,
      questionText,
      normalizeSpace(question.learn),
      normalizeSpace(question.explanation),
      normalizeSpace(question.category),
      sourceText,
      sanitizeOptionsList(question.options).join(" "),
    ].join(" ").toLowerCase();

    return {
      id,
      question,
      questionText,
      kind,
      date,
      disabled,
      isCustom,
      hasSource,
      quality,
      performance,
      haystack,
    };
  });

  const filteredRows = rows.filter((row) => {
    if (searchText && !row.haystack.includes(searchText)) {
      return false;
    }

    if (selectedCategory && selectedCategory !== "all") {
      const category = normalizeSpace(row.question.category);
      if (category !== selectedCategory) {
        return false;
      }
    }

    if (selectedKind && row.kind !== selectedKind) {
      return false;
    }

    if (visibilityFilter === "active" && row.disabled) {
      return false;
    }
    if (visibilityFilter === "hidden" && !row.disabled) {
      return false;
    }
    if (visibilityFilter === "custom" && !row.isCustom) {
      return false;
    }
    if (visibilityFilter === "base" && row.isCustom) {
      return false;
    }

    if (sourceFilter === "with-source" && !row.hasSource) {
      return false;
    }
    if (sourceFilter === "no-source" && row.hasSource) {
      return false;
    }

    if (dateFrom && (!row.date || row.date < dateFrom)) {
      return false;
    }
    if (dateTo && (!row.date || row.date > dateTo)) {
      return false;
    }

    return true;
  });

  const sortedRows = sortQuestionManagerRows(filteredRows.slice(), sortMode);

  if (dom.questionCountExact) {
    dom.questionCountExact.textContent =
      `שאלות פעילות במאגר: ${inventory.activeQuestions.length} | ` +
      `מוסתרות: ${inventory.disabledIds.size} | ` +
      `סך הכול: ${inventory.allQuestions.length} | ` +
      `בתצוגה: ${sortedRows.length}`;
  }

  dom.allQuestionsList.innerHTML = "";

  if (!sortedRows.length) {
    dom.allQuestionsList.appendChild(makeInfoMessage("לא נמצאו שאלות לפי החיפוש."));
    renderQuestionAuditReport(inventory);
    return;
  }

  const renderCap = 160;
  const visibleList = sortedRows.slice(0, renderCap);
  visibleList.forEach((row) => {
    const {
      question,
      id,
      kind,
      date,
      disabled,
      isCustom,
      hasSource,
      quality,
      performance,
    } = row;
    const card = document.createElement("article");
    card.className = "info-card";

    const title = document.createElement("h4");
    title.textContent = question.question || row.questionText;

    const badgeRow = document.createElement("div");
    badgeRow.className = "badge-row";

    const visibilityBadge = document.createElement("span");
    visibilityBadge.className = `badge question-visibility ${disabled ? "hidden" : "active"}`;
    visibilityBadge.textContent = disabled ? "מוסתרת" : "פעילה";

    const kindBadge = document.createElement("span");
    kindBadge.className = `badge ${kind === "success" ? "success" : "activity"}`;
    kindBadge.textContent = kind === "success" ? "הישג" : "פעילות";

    const sourceBadge = document.createElement("span");
    sourceBadge.className = "badge";
    sourceBadge.textContent = hasSource ? "עם מקור" : "ללא מקור";

    const originBadge = document.createElement("span");
    originBadge.className = "badge";
    originBadge.textContent = isCustom ? "Published" : "Base";

    badgeRow.appendChild(visibilityBadge);
    badgeRow.appendChild(kindBadge);
    badgeRow.appendChild(sourceBadge);
    badgeRow.appendChild(originBadge);

    if (date) {
      const dateBadge = document.createElement("span");
      dateBadge.className = "badge";
      dateBadge.textContent = formatDateDisplay(date);
      badgeRow.appendChild(dateBadge);
    }

    if (question.category) {
      const categoryBadge = document.createElement("span");
      categoryBadge.className = "badge";
      categoryBadge.textContent = question.category;
      badgeRow.appendChild(categoryBadge);
    }

    const answerLine = document.createElement("p");
    answerLine.textContent = `תשובה נכונה: ${question.options[question.answer]}`;

    const metaLine = document.createElement("p");
    metaLine.className = "muted tight";
    metaLine.textContent = `מזהה: ${id} | סטטוס: ${disabled ? "מוסתרת מהמשחק" : "פעילה במשחק"}`;

    const qualityLine = document.createElement("p");
    qualityLine.className = "muted";
    qualityLine.textContent = quality.issues.length
      ? `איכות תוכן: דורש שיפור (${quality.topIssue})`
      : "איכות תוכן: תקין (ניסוח, תשובה, מסיחים ומקור)";

    const actionRow = document.createElement("div");
    actionRow.className = "inline-actions";

    const editBtn = document.createElement("button");
    editBtn.type = "button";
    editBtn.className = "ghost-btn";
    editBtn.textContent = "ערוך";
    editBtn.addEventListener("click", () => editQuestion(id));

    const deleteBtn = document.createElement("button");
    deleteBtn.type = "button";
    deleteBtn.className = disabled ? "secondary-btn" : "ghost-btn";
    deleteBtn.textContent = disabled ? "החזר למשחק" : "הסר מהמאגר";
    deleteBtn.addEventListener("click", () => {
      if (disabled) {
        restoreQuestion(id);
      } else {
        removeQuestion(id);
      }
    });

    actionRow.appendChild(editBtn);
    actionRow.appendChild(deleteBtn);

    card.appendChild(title);
    card.appendChild(badgeRow);
    card.appendChild(answerLine);
    card.appendChild(metaLine);
    card.appendChild(qualityLine);

    if (performance && performance.total >= 2) {
      const performanceLine = document.createElement("p");
      performanceLine.className = "muted tight";
      performanceLine.textContent =
        `ביצוע למידה: סיכון ${performance.riskScore}/100 | דיוק ${performance.accuracy}% | זמן ממוצע ${performance.avgSec} ש׳`;
      card.appendChild(performanceLine);
    }

    card.appendChild(actionRow);
    dom.allQuestionsList.appendChild(card);
  });

  if (sortedRows.length > renderCap) {
    const note = document.createElement("p");
    note.className = "muted";
    note.textContent = `מוצגות ${renderCap} שאלות ראשונות מתוך ${sortedRows.length}. השתמש בפילטרים לסינון מדויק.`;
    dom.allQuestionsList.appendChild(note);
  }

  renderQuestionAuditReport(inventory);
}

function getQuestionInventory() {
  const custom = readStorage(STORAGE_KEYS.customQuestions, []);
  const disabledIds = new Set(readStorage(STORAGE_KEYS.disabledQuestionIds, []));
  const overrides = readObjectStorage(STORAGE_KEYS.questionOverrides, {});

  const rawPool = [...EXPANDED_BASE_QUESTIONS, ...custom];
  const uniqueById = new Map();
  rawPool.forEach((question) => {
    if (!question?.id) {
      return;
    }
    if (!uniqueById.has(question.id)) {
      uniqueById.set(question.id, question);
      return;
    }

    const existing = uniqueById.get(question.id);
    if (existing?.isGeneratedVariant && !question?.isGeneratedVariant) {
      uniqueById.set(question.id, question);
    }
  });

  const allQuestions = Array.from(uniqueById.values()).map((question) =>
    applyQuestionOverride(question, overrides[question.id]),
  );

  const activeQuestions = allQuestions.filter((question) => !disabledIds.has(question.id));

  return { allQuestions, activeQuestions, disabledIds };
}

function applyQuestionOverride(question, override) {
  if (!override || typeof override !== "object") {
    return question;
  }

  const merged = {
    ...question,
    ...override,
  };

  if (!Array.isArray(merged.options) || merged.options.length < 2) {
    merged.options = question.options;
  }
  if (typeof merged.answer !== "number" || merged.answer < 0 || merged.answer > merged.options.length - 1) {
    merged.answer = question.answer;
  }
  merged.optionExplanations = ensureOptionExplanations(merged);

  return merged;
}

function removeQuestion(questionId) {
  const inventory = getQuestionInventory();
  const target = inventory.allQuestions.find((question) => question.id === questionId);
  if (!target) {
    return;
  }

  const custom = readStorage(STORAGE_KEYS.customQuestions, []);
  const isCustom = custom.some((question) => question.id === questionId);
  if (isCustom) {
    const nextCustom = custom.filter((question) => question.id !== questionId);
    const saved = writeStorage(STORAGE_KEYS.customQuestions, nextCustom);
    if (!saved) {
      showMessage(dom.activityFormMsg, "מחיקת השאלה נכשלה.", false);
      return;
    }
  } else {
    const disabledIds = new Set(readStorage(STORAGE_KEYS.disabledQuestionIds, []));
    disabledIds.add(questionId);
    const saved = writeStorage(STORAGE_KEYS.disabledQuestionIds, Array.from(disabledIds));
    if (!saved) {
      showMessage(dom.activityFormMsg, "הסתרת השאלה נכשלה.", false);
      return;
    }
  }

  renderAdminStats();
  renderCustomQuestions();
  renderAllQuestionsManager();
}

function restoreQuestion(questionId) {
  const disabledIds = new Set(readStorage(STORAGE_KEYS.disabledQuestionIds, []));
  if (!disabledIds.has(questionId)) {
    return;
  }
  disabledIds.delete(questionId);
  const saved = writeStorage(STORAGE_KEYS.disabledQuestionIds, Array.from(disabledIds));
  if (!saved) {
    showMessage(dom.activityFormMsg, "שחזור השאלה נכשל.", false);
    return;
  }

  renderAdminStats();
  renderAllQuestionsManager();
}

function readQuestionEditOptionValues() {
  if (!dom.questionEditOptionsWrap) {
    return [];
  }
  return Array.from(dom.questionEditOptionsWrap.querySelectorAll("input[data-option-index]"))
    .map((input) => normalizeSpace(input.value))
    .map((value, index) => value || `אפשרות ${index + 1}`);
}

function syncQuestionEditAnswerSelect(selectedIndex = 0) {
  if (!dom.questionEditAnswerSelect) {
    return;
  }
  const options = readQuestionEditOptionValues();
  dom.questionEditAnswerSelect.innerHTML = "";
  options.forEach((optionText, index) => {
    const node = document.createElement("option");
    node.value = String(index);
    node.textContent = `${index + 1}. ${clampText(optionText, 70)}`;
    dom.questionEditAnswerSelect.appendChild(node);
  });
  const maxIndex = Math.max(0, options.length - 1);
  const safeIndex = clampNumber(selectedIndex, 0, maxIndex);
  dom.questionEditAnswerSelect.value = String(safeIndex);
}

function renderQuestionEditOptionFields(optionList, answerIndex) {
  if (!dom.questionEditOptionsWrap) {
    return;
  }
  const options = sanitizeOptionsList(optionList);
  while (options.length < 4) {
    options.push(`אפשרות ${options.length + 1}`);
  }

  dom.questionEditOptionsWrap.innerHTML = "";
  options.forEach((optionText, index) => {
    const label = document.createElement("label");
    label.className = "field";
    const title = document.createElement("span");
    title.textContent = `אפשרות ${index + 1}`;
    const input = document.createElement("input");
    input.type = "text";
    input.required = true;
    input.value = optionText;
    input.dataset.optionIndex = String(index);
    input.addEventListener("input", () => {
      const currentAnswer = Number(dom.questionEditAnswerSelect?.value || answerIndex || 0);
      syncQuestionEditAnswerSelect(currentAnswer);
    });
    label.appendChild(title);
    label.appendChild(input);
    dom.questionEditOptionsWrap.appendChild(label);
  });

  syncQuestionEditAnswerSelect(answerIndex);
}

function closeQuestionEditModal() {
  adminState.questionEditTargetId = "";
  if (dom.questionEditModal) {
    dom.questionEditModal.classList.add("hidden");
  }
  dom.questionEditForm?.reset();
  if (dom.questionEditOptionsWrap) {
    dom.questionEditOptionsWrap.innerHTML = "";
  }
  if (dom.questionEditAnswerSelect) {
    dom.questionEditAnswerSelect.innerHTML = "";
  }
  hideMessage(dom.questionEditMsg);
}

function openQuestionEditModal(question) {
  if (!question || !dom.questionEditModal) {
    return;
  }
  adminState.questionEditTargetId = normalizeSpace(question.id);
  dom.questionEditQuestionInput.value = normalizeSpace(question.question);
  dom.questionEditLearnInput.value = normalizeSpace(question.learn);
  dom.questionEditExplanationInput.value = normalizeSpace(question.explanation);
  renderQuestionEditOptionFields(question.options || [], Number(question.answer || 0));
  hideMessage(dom.questionEditMsg);
  dom.questionEditModal.classList.remove("hidden");
  window.setTimeout(() => {
    dom.questionEditQuestionInput?.focus();
  }, 20);
}

function submitQuestionEditModal(event) {
  event?.preventDefault();
  hideMessage(dom.questionEditMsg);

  const questionId = normalizeSpace(adminState.questionEditTargetId);
  if (!questionId) {
    showMessage(dom.questionEditMsg, "לא זוהתה שאלה לעריכה.", false);
    return;
  }

  const inventory = getQuestionInventory();
  const originalQuestion = inventory.allQuestions.find((item) => normalizeSpace(item.id) === questionId);
  if (!originalQuestion) {
    showMessage(dom.questionEditMsg, "השאלה לא נמצאה במאגר. רענן ונסה שוב.", false);
    return;
  }

  const questionText = normalizeSpace(dom.questionEditQuestionInput.value);
  const learnText = normalizeSpace(dom.questionEditLearnInput.value);
  const explanationText = normalizeSpace(dom.questionEditExplanationInput.value);
  const options = readQuestionEditOptionValues();
  const answerIndex = Number(dom.questionEditAnswerSelect?.value || 0);

  if (questionText.length < 12) {
    showMessage(dom.questionEditMsg, "נוסח השאלה קצר מדי. נדרש ניסוח מפורט יותר.", false);
    return;
  }
  if (options.length < 4) {
    showMessage(dom.questionEditMsg, "יש להזין לפחות 4 אפשרויות תשובה.", false);
    return;
  }
  const uniqueCount = new Set(options.map((option) => option.toLowerCase())).size;
  if (uniqueCount < 4) {
    showMessage(dom.questionEditMsg, "אפשרויות התשובה חייבות להיות שונות זו מזו.", false);
    return;
  }
  if (!Number.isInteger(answerIndex) || answerIndex < 0 || answerIndex >= options.length) {
    showMessage(dom.questionEditMsg, "בחירת התשובה הנכונה אינה תקינה.", false);
    return;
  }

  const overrideMap = readObjectStorage(STORAGE_KEYS.questionOverrides, {});
  overrideMap[questionId] = {
    question: questionText || originalQuestion.question,
    learn: learnText || originalQuestion.learn,
    explanation: explanationText || originalQuestion.explanation,
    options,
    answer: answerIndex,
  };

  const saved = writeStorage(STORAGE_KEYS.questionOverrides, overrideMap);
  if (!saved) {
    showMessage(dom.questionEditMsg, "שמירת השינויים נכשלה בגלל מגבלת אחסון בדפדפן.", false);
    return;
  }

  renderAllQuestionsManager();
  showMessage(dom.questionEditMsg, "השאלה נשמרה בהצלחה.", true);
  window.setTimeout(() => {
    closeQuestionEditModal();
  }, 260);
}

function editQuestion(questionId) {
  const inventory = getQuestionInventory();
  const question = inventory.allQuestions.find((item) => normalizeSpace(item.id) === normalizeSpace(questionId));
  if (!question) {
    return;
  }
  openQuestionEditModal(question);
}

function markLongTextAsChangedAfterAnalysis() {
  if (!adminState.longTextAnalysis) {
    return;
  }

  const currentText = normalizeLongTextInput(dom.longTextInput.value);
  if (currentText === adminState.longTextAnalysis.normalizedText) {
    return;
  }

  adminState.longTextAnalysis = null;
  adminState.lastLongTextBatchDraftIds = [];
  dom.generateLongTextDraftsBtn.disabled = true;
  dom.approveAllTextDraftsBtn.disabled = true;
  hideMessage(dom.longTextMsg);
  clearLongTextTopicTitle();
  renderLongTextDraftsPreview();
}

function normalizeLongTextInput(rawText) {
  return String(rawText || "")
    .replace(/\r/g, "\n")
    .replace(/[ \t]+\n/g, "\n")
    .replace(/\n{3,}/g, "\n\n")
    .replace(/[ \t]{2,}/g, " ")
    .trim();
}

function splitLongTextToSentences(text) {
  const compact = normalizeLongTextInput(text).replace(/\n+/g, " ");
  if (!compact) {
    return [];
  }

  const rough = compact.match(/[^.!?]+[.!?]?/g) || [compact];
  return rough
    .map((line) => normalizeSpace(line))
    .map((line) => line.replace(/[.!?]+$/, "").trim())
    .filter((line) => line.length >= 36 && countWords(line) >= 6);
}

function splitLongTextToParagraphs(text) {
  return normalizeLongTextInput(text)
    .split(/\n{2,}/)
    .map((line) => normalizeSpace(line))
    .filter(Boolean);
}

function extractFactsFromLongText(text, minCount) {
  const target = Math.max(3, Number(minCount) || 3);
  const sentences = splitLongTextToSentences(text);
  const unique = [];
  const seen = new Set();

  sentences.forEach((sentence) => {
    const safe = clampText(sentence, 180);
    const key = safe.toLowerCase();
    if (!safe || seen.has(key)) {
      return;
    }
    seen.add(key);
    unique.push(safe);
  });

  if (unique.length >= target) {
    return unique;
  }

  const words = normalizeLongTextInput(text).replace(/\n+/g, " ").split(" ").filter(Boolean);
  for (let i = 0; i < words.length && unique.length < target; i += 18) {
    const chunk = normalizeSpace(words.slice(i, i + 24).join(" "));
    if (chunk.length < 48 || countWords(chunk) < 8) {
      continue;
    }
    const safe = clampText(chunk, 180);
    const key = safe.toLowerCase();
    if (seen.has(key)) {
      continue;
    }
    seen.add(key);
    unique.push(safe);
  }

  return unique;
}

function analyzeLongTextContent(text) {
  const normalizedText = normalizeLongTextInput(text);
  const words = normalizedText.split(/\s+/).filter(Boolean);
  const paragraphs = splitLongTextToParagraphs(normalizedText);
  const facts = extractFactsFromLongText(normalizedText, 18);
  const sentenceCount = splitLongTextToSentences(normalizedText).length;

  return {
    normalizedText,
    wordsCount: words.length,
    charsCount: normalizedText.length,
    paragraphs,
    sentenceCount,
    facts,
    analyzedAt: new Date().toISOString(),
    textHash: hashText(normalizedText),
  };
}

function buildLongTextGeneralTitle(analysis) {
  const raw = normalizeSpace(
    analysis?.paragraphs?.[0]
    || analysis?.facts?.[0]
    || analysis?.normalizedText,
  );
  if (!raw) {
    return "";
  }

  const sentence = normalizeSpace(raw.split(/[.!?]/)[0]);
  const words = sentence.split(" ").filter(Boolean);
  if (!words.length) {
    return "";
  }
  return clampText(words.slice(0, 12).join(" "), 86);
}

function setLongTextTopicTitle(analysis) {
  if (!dom.longTextTopicTitle) {
    return;
  }

  const title = buildLongTextGeneralTitle(analysis);
  if (!title) {
    clearLongTextTopicTitle();
    return;
  }

  dom.longTextTopicTitle.textContent = `נושא כללי שזוהה: ${title}`;
  dom.longTextTopicTitle.classList.remove("hidden");
}

function clearLongTextTopicTitle() {
  if (!dom.longTextTopicTitle) {
    return;
  }
  dom.longTextTopicTitle.textContent = "";
  dom.longTextTopicTitle.classList.add("hidden");
}

async function handleLongTextFileUpload(event) {
  const file = event?.target?.files?.[0];
  if (!file) {
    return;
  }

  try {
    const text = await file.text();
    dom.longTextInput.value = normalizeLongTextInput(text);
    adminState.longTextAnalysis = null;
    adminState.lastLongTextBatchDraftIds = [];
    dom.generateLongTextDraftsBtn.disabled = true;
    dom.approveAllTextDraftsBtn.disabled = true;
    clearLongTextTopicTitle();
    showMessage(dom.longTextMsg, `הקובץ "${file.name}" נטען. לחץ Enter או "נתח טקסט והצע 10 שאלות".`, true);
    renderLongTextDraftsPreview();
  } catch (_err) {
    showMessage(dom.longTextMsg, "טעינת קובץ הטקסט נכשלה.", false);
  } finally {
    dom.longTextFileInput.value = "";
  }
}

function analyzeLongTextInput(options = {}) {
  const autoSuggest = options.autoSuggest !== false;
  hideMessage(dom.longTextMsg);
  const normalizedText = normalizeLongTextInput(dom.longTextInput.value);
  if (normalizedText.length < LONG_TEXT_MIN_CHARS) {
    showMessage(
      dom.longTextMsg,
      `הטקסט קצר מדי ליצירת שאלות איכותיות. נדרש מינימום ${LONG_TEXT_MIN_CHARS} תווים.`,
      false,
    );
    dom.generateLongTextDraftsBtn.disabled = true;
    clearLongTextTopicTitle();
    return;
  }

  const analysis = analyzeLongTextContent(normalizedText);
  if (analysis.facts.length < 5) {
    showMessage(dom.longTextMsg, "לא זוהו מספיק עובדות בטקסט. הוסף פרטים ונסה שוב.", false);
    dom.generateLongTextDraftsBtn.disabled = true;
    clearLongTextTopicTitle();
    return;
  }

  const previousBatchIds = adminState.lastLongTextBatchDraftIds.slice();
  adminState.longTextAnalysis = analysis;
  setLongTextTopicTitle(analysis);
  dom.generateLongTextDraftsBtn.disabled = false;
  dom.approveAllTextDraftsBtn.disabled = true;

  if (autoSuggest) {
    if (dom.longTextQuestionCount) {
      dom.longTextQuestionCount.value = "10";
    }
    generateDraftsFromLongTextInput({
      autoMode: true,
      replacePreviousBatch: true,
      replaceBatchIds: previousBatchIds,
    });
    return;
  }

  adminState.lastLongTextBatchDraftIds = [];
  showMessage(dom.longTextMsg, "הטקסט נותח בהצלחה. ניתן כעת להציע 10 שאלות בלחיצה אחת.", true);
  renderLongTextDraftsPreview();
}

function buildLongTextTopic(text) {
  const words = normalizeSpace(text).split(" ").filter(Boolean);
  return words.slice(0, 6).join(" ");
}

function mutateFactNumber(text, variant) {
  let mutated = false;
  const output = String(text).replace(/\d{1,4}(?:,\d{3})*/g, (match) => {
    if (mutated) {
      return match;
    }
    const numeric = Number(match.replace(/,/g, ""));
    if (!Number.isFinite(numeric)) {
      return match;
    }
    mutated = true;
    const delta = (variant % 2 === 0 ? 3 : 7) + variant;
    return String(numeric + delta);
  });
  return mutated ? output : text;
}

function mutateFactByRules(text, variant) {
  const rules = [
    ["אושר", "נדחה"],
    ["נדחה", "אושר"],
    ["התקבל", "נפסל"],
    ["נפסל", "התקבל"],
    ["הוגדל", "הוקטן"],
    ["הוקטן", "הוגדל"],
    ["הוקפא", "הואץ"],
    ["נקבע", "בוטל"],
    ["הממשלה", "הכנסת"],
    ["בג\"ץ", "בית משפט מחוזי"],
    ["התנועה", "גורם אחר"],
    ["המדינה", "רשות מקומית"],
    ["חובה", "רשות"],
  ];

  for (let i = 0; i < rules.length; i += 1) {
    const [from, to] = rules[(i + variant) % rules.length];
    if (text.includes(from)) {
      return text.replace(from, to);
    }
  }

  return text;
}

function mutateFactToDistractor(factText, variant) {
  const fact = normalizeSpace(factText);
  if (!fact) {
    return "";
  }

  const withNumberTwist = mutateFactNumber(fact, variant);
  const withRuleTwist = mutateFactByRules(withNumberTwist, variant);
  if (withRuleTwist !== fact) {
    return clampText(withRuleTwist, 120);
  }

  const topic = buildLongTextTopic(fact);
  const fallbackLines = [
    `בהקשר של "${topic}", נטען שהמהלך בוטל לפני יישום.`,
    `לפי הטקסט, בנושא "${topic}" הוחלט לדחות את הביצוע ללא מועד חדש.`,
    `בהמשך ל-"${topic}", צוין כי לא נקבעה מסגרת יישום מחייבת.`,
  ];
  return fallbackLines[variant % fallbackLines.length];
}

function buildLongTextDistractors(correctFact, allFacts) {
  const unique = new Set();
  const output = [];

  const candidates = [];
  for (let i = 0; i < 4; i += 1) {
    candidates.push(mutateFactToDistractor(correctFact, i + 1));
  }

  const alternateFacts = pickRandom(
    allFacts.filter((item) => normalizeSpace(item) !== normalizeSpace(correctFact)),
    6,
  );
  alternateFacts.forEach((fact, idx) => {
    candidates.push(mutateFactToDistractor(fact, idx + 3));
  });

  candidates.forEach((candidate) => {
    const safe = clampText(normalizeSpace(candidate), 120);
    if (!safe || safe === normalizeSpace(correctFact)) {
      return;
    }
    const key = safe.toLowerCase();
    if (unique.has(key)) {
      return;
    }
    unique.add(key);
    output.push(safe);
  });

  while (output.length < 3) {
    output.push(`בטקסט צוין שהמהלך נשאר ללא יישום מחייב בשלב זה (${output.length + 1}).`);
  }

  return output.slice(0, 3);
}

function buildSourcesFromLongTextInput(sourceLabel, sourceUrl, analysis) {
  if (!normalizeSpace(sourceUrl)) {
    return [];
  }

  return [
    {
      label: normalizeSpace(sourceLabel) || "מקור טקסט שהוזן",
      url: normalizeSpace(sourceUrl),
      anchorText: analysis?.facts?.[0] || clampText(analysis?.normalizedText || "", 120),
    },
  ];
}

function generateDraftsFromLongTextAnalysis(payload) {
  const {
    analysis,
    count,
    category,
    kind,
    date,
    sourceLabel,
    sourceUrl,
  } = payload;

  const safeCount = Math.min(15, Math.max(1, Number(count) || 5));
  const factsPool = pickRandom(analysis.facts.slice(), analysis.facts.length);
  const batchId = uid("text_batch");
  const drafts = [];
  const sourceList = buildSourcesFromLongTextInput(sourceLabel, sourceUrl, analysis);
  const learnBase = clampText(analysis.paragraphs[0] || analysis.facts[0] || analysis.normalizedText, 180);

  for (let i = 0; i < safeCount; i += 1) {
    const correctFact = factsPool[i % factsPool.length];
    const correctOption = clampText(correctFact, 120);
    const distractors = buildLongTextDistractors(correctFact, analysis.facts);
    const options = shuffleArray([correctOption, ...distractors]).slice(0, 4);
    const answer = options.indexOf(correctOption);
    const stem = LONG_TEXT_QUESTION_STEMS[i % LONG_TEXT_QUESTION_STEMS.length];
    const topic = buildLongTextTopic(correctFact);

    drafts.push({
      id: uid("draft"),
      originLongTextBatchId: batchId,
      kind,
      date,
      category,
      learn: `קטע רקע: ${learnBase}`,
      question: `${stem} (${topic})`,
      options,
      answer: answer >= 0 ? answer : 0,
      explanation: `בטקסט שהוזן מופיעה במפורש הטענה: ${correctOption}`,
      sources: sourceList,
    });
  }

  return { batchId, drafts };
}

function generateDraftsFromLongTextInput(options = {}) {
  const autoMode = Boolean(options.autoMode);
  const replacePreviousBatch = options.replacePreviousBatch !== false;
  const replaceBatchIds = Array.isArray(options.replaceBatchIds)
    ? options.replaceBatchIds
    : adminState.lastLongTextBatchDraftIds;
  hideMessage(dom.longTextMsg);

  const normalizedText = normalizeLongTextInput(dom.longTextInput.value);
  const antiSpamPayloadHash = String(
    hashText(
      [
        normalizedText,
        normalizeSpace(dom.longTextDate?.value),
        normalizeSpace(dom.longTextCategory?.value),
        normalizeSpace(dom.longTextKind?.value),
        normalizeSpace(dom.longTextQuestionCount?.value),
      ].join("|"),
    ),
  );
  const antiSpam = recordAntiSpamEvent("longTextGenerate", antiSpamPayloadHash);
  if (antiSpam.blocked) {
    showMessage(
      dom.longTextMsg,
      `יותר מדי ניסיונות יצירה בזמן קצר. נסה שוב בעוד ${formatCooldownMs(antiSpam.remainingMs)}.`,
      false,
    );
    return;
  }
  if (antiSpam.duplicate) {
    showMessage(
      dom.longTextMsg,
      "זוהתה בקשת יצירה כפולה לאותו טקסט. המתן כמה שניות או בצע שינוי קטן בטקסט.",
      false,
    );
    return;
  }

  if (!adminState.longTextAnalysis || adminState.longTextAnalysis.normalizedText !== normalizedText) {
    showMessage(dom.longTextMsg, "יש לבצע ניתוח לטקסט (Enter או כפתור הניתוח) לפני יצירת שאלות.", false);
    return;
  }

  const sourceUrl = normalizeSpace(dom.longTextSourceUrl.value);
  if (sourceUrl && !isValidUrl(sourceUrl)) {
    showMessage(dom.longTextMsg, "קישור המקור לא תקין. יש להזין URL מלא.", false);
    return;
  }

  const kind = normalizeSpace(dom.longTextKind.value) || "activity";
  const date = normalizeSpace(dom.longTextDate.value);
  const category = normalizeSpace(dom.longTextCategory.value) || "פעילות ציבורית";
  const count = Number(dom.longTextQuestionCount.value || 10);

  if (!date) {
    showMessage(dom.longTextMsg, "יש לבחור תאריך ייחוס לשאלות.", false);
    return;
  }

  if (kind === "activity" && date < MIN_CONTENT_DATE) {
    showMessage(
      dom.longTextMsg,
      "בשאלות מסוג פעילות, תאריך הייחוס חייב להיות 2025 ומעלה.",
      false,
    );
    return;
  }

  const generated = generateDraftsFromLongTextAnalysis({
    analysis: adminState.longTextAnalysis,
    count,
    category,
    kind,
    date,
    sourceLabel: normalizeSpace(dom.longTextSourceLabel.value),
    sourceUrl,
  });

  const generatedWithWorkflow = generated.drafts.map((draft) => ({
    ...draft,
    workflowStatus: "review",
  }));
  const previousBatchIdSet = new Set(
    replaceBatchIds.map((id) => normalizeSpace(id)).filter(Boolean),
  );
  let existingDrafts = readDraftQueue();
  if (replacePreviousBatch && previousBatchIdSet.size) {
    existingDrafts = existingDrafts.filter((draft) => !previousBatchIdSet.has(normalizeSpace(draft.id)));
  }
  const mergedDrafts = [...generatedWithWorkflow, ...existingDrafts].slice(0, 500);
  const saved = writeDraftQueue(mergedDrafts);
  if (!saved) {
    showMessage(dom.longTextMsg, "יצירת הטיוטות נכשלה בגלל מגבלת אחסון בדפדפן.", false);
    return;
  }

  adminState.lastLongTextBatchDraftIds = generatedWithWorkflow.map((draft) => draft.id);
  dom.approveAllTextDraftsBtn.disabled = adminState.lastLongTextBatchDraftIds.length === 0;
  showMessage(
    dom.longTextMsg,
    autoMode
      ? `הטקסט נותח, זוהה נושא והוצעו ${generatedWithWorkflow.length} שאלות במצב Review. אפשר לאשר/לדחות או להוסיף את כולן.`
      : `נוצרו ${generatedWithWorkflow.length} שאלות במצב Review. אפשר לאשר אחת-אחת או להוסיף את כולן למאגר.`,
    true,
  );

  renderAdminStats();
  renderDrafts();
  renderLongTextDraftsPreview();
}

function approveDraftsBulk(draftIds, options = {}) {
  const requireReview = Boolean(options.requireReview);
  const idSet = new Set((draftIds || []).map((id) => normalizeSpace(id)).filter(Boolean));
  if (!idSet.size) {
    return {
      approvedCount: 0,
      skippedCount: 0,
      remainingDraftIds: [],
      approvedDraftIds: [],
      skippedDraftIds: [],
    };
  }

  const drafts = readDraftQueue();
  const customQuestions = readStorage(STORAGE_KEYS.customQuestions, []);
  const nextCustom = customQuestions.slice();
  const remainingDrafts = [];
  const remainingBatch = [];
  const approvedDraftIds = [];
  const skippedDraftIds = [];
  let approvedCount = 0;
  let skippedCount = 0;

  drafts.forEach((draft) => {
    if (!idSet.has(normalizeSpace(draft.id))) {
      remainingDrafts.push(draft);
      return;
    }

    if (requireReview && normalizeDraftWorkflowStatus(draft.workflowStatus) !== "review") {
      skippedCount += 1;
      skippedDraftIds.push(draft.id);
      remainingDrafts.push(draft);
      remainingBatch.push(draft.id);
      return;
    }

    const quality = evaluateDraftQuality(draft);
    if (!quality.isReadyToApprove) {
      skippedCount += 1;
      skippedDraftIds.push(draft.id);
      remainingDrafts.push(draft);
      remainingBatch.push(draft.id);
      return;
    }

    approvedCount += 1;
    approvedDraftIds.push(draft.id);
    nextCustom.unshift({
      ...draft,
      id: uid("cq"),
      optionExplanations: ensureOptionExplanations(draft),
      approvedAt: new Date().toISOString(),
      publishedFromStatus: normalizeDraftWorkflowStatus(draft.workflowStatus),
      allowLegacySuccess: draft.kind === "success" && draft.date < MIN_CONTENT_DATE,
    });
  });

  const savedDrafts = writeDraftQueue(remainingDrafts.slice(0, 500));
  const savedCustom = writeStorage(STORAGE_KEYS.customQuestions, nextCustom.slice(0, 500));
  if (!savedDrafts || !savedCustom) {
    return null;
  }

  return {
    approvedCount,
    skippedCount,
    remainingDraftIds: remainingBatch,
    approvedDraftIds,
    skippedDraftIds,
  };
}

function approveAllLongTextDrafts() {
  hideMessage(dom.longTextMsg);
  const batchIds = adminState.lastLongTextBatchDraftIds.slice();
  if (!batchIds.length) {
    showMessage(dom.longTextMsg, "אין כרגע טיוטות מטקסט להוספה מרוכזת.", false);
    return;
  }

  const result = approveDraftsBulk(batchIds, { requireReview: true });
  if (!result) {
    showMessage(dom.longTextMsg, "הוספה מרוכזת נכשלה בגלל מגבלת אחסון בדפדפן.", false);
    return;
  }

  adminState.lastLongTextBatchDraftIds = result.remainingDraftIds;
  dom.approveAllTextDraftsBtn.disabled = adminState.lastLongTextBatchDraftIds.length === 0;

  showMessage(
    dom.longTextMsg,
    `הושלמה הוספה מרוכזת: ${result.approvedCount} שאלות נוספו למאגר. ${
      result.skippedCount ? `דולגו ${result.skippedCount} טיוטות שלא עברו צ'קליסט.` : ""
    }`,
    true,
  );

  renderAdminStats();
  renderDrafts();
  renderCustomQuestions();
  renderAllQuestionsManager();
  renderLongTextDraftsPreview();
}

function renderLongTextDraftsPreview() {
  if (!dom.longTextDraftsPreview) {
    return;
  }

  dom.longTextDraftsPreview.innerHTML = "";
  const idSet = new Set(adminState.lastLongTextBatchDraftIds);
  const allDrafts = readDraftQueue();
  const batchDrafts = allDrafts.filter((draft) => idSet.has(draft.id));

  if (batchDrafts.length) {
    batchDrafts.forEach((draft) => {
      const quality = evaluateDraftQuality(draft);
      const status = normalizeDraftWorkflowStatus(draft.workflowStatus);
      const card = document.createElement("article");
      card.className = "info-card";

      const title = document.createElement("h4");
      title.textContent = draft.question;

      const answerLine = document.createElement("p");
      answerLine.textContent = `תשובה נכונה: ${draft.options[draft.answer]}`;

      const statusLine = document.createElement("p");
      statusLine.className = "muted tight";
      statusLine.textContent = `סטטוס תור פרסום: ${status === "review" ? "Review" : "Draft"}`;

      const qualityLine = document.createElement("p");
      qualityLine.className = quality.isReadyToApprove ? "quality-summary ok" : "quality-summary bad";
      qualityLine.textContent = quality.isReadyToApprove
        ? (status === "review" ? "טיוטה מוכנה לפרסום." : "הטיוטה תקינה - העבר ל-Review לפרסום.")
        : "טיוטה דורשת תיקונים לפני אישור.";

      const actions = document.createElement("div");
      actions.className = "inline-actions";

      const approveBtn = document.createElement("button");
      approveBtn.type = "button";
      approveBtn.className = "primary-btn";
      approveBtn.textContent = "פרסם שאלה זו";
      approveBtn.disabled = !quality.isReadyToApprove || status !== "review";
      if (status !== "review") {
        approveBtn.title = "יש להעביר את הטיוטה ל-Review לפני פרסום.";
      }
      approveBtn.addEventListener("click", () => {
        approveDraft(draft.id);
      });

      const moveToReviewBtn = document.createElement("button");
      moveToReviewBtn.type = "button";
      moveToReviewBtn.className = status === "review" ? "ghost-btn" : "secondary-btn";
      moveToReviewBtn.textContent = status === "review" ? "החזר ל-Draft" : "העבר ל-Review";
      moveToReviewBtn.addEventListener("click", () => {
        const updated = readDraftQueue().map((item) =>
          normalizeSpace(item.id) === normalizeSpace(draft.id)
            ? { ...item, workflowStatus: status === "review" ? "draft" : "review" }
            : item);
        const saved = writeDraftQueue(updated);
        if (!saved) {
          showMessage(dom.longTextMsg, "עדכון סטטוס הטיוטה נכשל.", false);
          return;
        }
        renderDrafts();
        renderLongTextDraftsPreview();
      });

      const rejectBtn = document.createElement("button");
      rejectBtn.type = "button";
      rejectBtn.className = "ghost-btn";
      rejectBtn.textContent = "דחה שאלה זו";
      rejectBtn.addEventListener("click", () => {
        rejectDraft(draft.id);
      });

      actions.appendChild(moveToReviewBtn);
      actions.appendChild(approveBtn);
      actions.appendChild(rejectBtn);

      card.appendChild(title);
      card.appendChild(answerLine);
      card.appendChild(statusLine);
      card.appendChild(qualityLine);
      card.appendChild(actions);
      dom.longTextDraftsPreview.appendChild(card);
    });

    dom.approveAllTextDraftsBtn.disabled = false;
    return;
  }

  if (adminState.longTextAnalysis?.facts?.length) {
    const info = makeInfoMessage(
      `הטקסט נותח. זוהו ${adminState.longTextAnalysis.facts.length} עובדות אפשריות ליצירת שאלות. לחץ על "רענן הצעת שאלות".`,
    );
    dom.longTextDraftsPreview.appendChild(info);

    const factsPreview = document.createElement("article");
    factsPreview.className = "info-card";
    const title = document.createElement("h4");
    title.textContent = "דוגמאות לעובדות שזוהו בטקסט";
    factsPreview.appendChild(title);

    const list = document.createElement("ul");
    list.className = "sources-list";
    adminState.longTextAnalysis.facts.slice(0, LONG_TEXT_PREVIEW_FACTS).forEach((fact) => {
      const item = document.createElement("li");
      item.textContent = clampText(fact, 150);
      list.appendChild(item);
    });
    factsPreview.appendChild(list);
    dom.longTextDraftsPreview.appendChild(factsPreview);
    dom.approveAllTextDraftsBtn.disabled = true;
    return;
  }

  dom.longTextDraftsPreview.appendChild(
    makeInfoMessage("אין עדיין שאלות מוצעות מטקסט. הדבק טקסט ולחץ Enter או 'נתח טקסט והצע 10 שאלות'."),
  );
  dom.approveAllTextDraftsBtn.disabled = true;
}

function generateDraftsFromActivity(activity) {
  const sourceList = buildSourcesFromActivity(activity);

  const primaryCorrect = clampText(activity.outcome, 96);
  const questionOne = {
    id: uid("draft"),
    originActivityId: activity.id,
    kind: activity.kind,
    date: activity.date,
    category: activity.category,
    learn: activity.context,
    question: `מה הייתה התוצאה המרכזית של "${activity.title}"?`,
    options: shuffleArray([
      primaryCorrect,
      "הנושא הועבר לבחינה בלבד ללא תוצאה אופרטיבית",
      "הדיון נדחה למועד לא ידוע ללא החלטה",
      "הוחלט לסגור את המהלך ללא המשך טיפול",
    ]),
    explanation: `לפי ההזנה, התוצאה המרכזית הייתה: ${activity.outcome}`,
    sources: sourceList,
  };
  questionOne.answer = questionOne.options.indexOf(primaryCorrect);

  const wrongCategories = pickRandom(
    ALL_CATEGORIES.filter((item) => item !== activity.category),
    3,
  );
  const questionTwo = {
    id: uid("draft"),
    originActivityId: activity.id,
    kind: activity.kind,
    date: activity.date,
    category: activity.category,
    learn: activity.context,
    question: `לאיזה תחום ציבורי שויכה הפעילות "${activity.title}"?`,
    options: shuffleArray([activity.category, ...wrongCategories]),
    explanation: `הפעילות סווגה כ-${activity.category} לפי נתוני המנהל שהוזנו בטופס.`,
    sources: sourceList,
  };
  questionTwo.answer = questionTwo.options.indexOf(activity.category);

  const actionType = detectActionType(activity);
  const questionThree = {
    id: uid("draft"),
    originActivityId: activity.id,
    kind: activity.kind,
    date: activity.date,
    category: activity.category,
    learn: activity.context,
    question: `מה היה כלי הפעולה המרכזי במסגרת "${activity.title}"?`,
    options: shuffleArray([
      actionType,
      "מהלך תקשורתי בלבד ללא פעולה מוסדית",
      "קמפיין גיוס תרומות ללא פנייה לרשויות",
      "הליך מחקר אקדמי בלבד",
    ]),
    explanation: `מתוך הטקסט שהוזן, כלי הפעולה המרכזי סווג כ: ${actionType}.`,
    sources: sourceList,
  };
  questionThree.answer = questionThree.options.indexOf(actionType);

  return [questionOne, questionTwo, questionThree];
}

function detectActionType(activity) {
  const text = `${activity.title} ${activity.context} ${activity.outcome}`;

  if (/עתיר|בג"ץ|בג״ץ|בית המשפט/i.test(text)) {
    return "הליך משפטי / עתירה";
  }

  if (/מכתב|פנייה|פניה|דרישה|פנינו/i.test(text)) {
    return "פנייה רשמית לגורמי ממשל";
  }

  if (/חקיקה|חוק|תקנון|תזכיר/i.test(text)) {
    return "מהלך חקיקה / רגולציה";
  }

  if (/ועדה|דיון|מינויים|שימוע/i.test(text)) {
    return "עבודה מוסדית מול ועדות ומנגנוני מינוי";
  }

  return "שילוב פעולה ציבורית ומשפטית";
}

function buildSourcesFromActivity(activity) {
  if (!activity.sourceUrl) {
    return [];
  }

  return [
    {
      label: activity.sourceLabel || "מקור שהוזן על ידי מנהל",
      url: activity.sourceUrl,
      anchorText: normalizeSpace(activity.outcome) || normalizeSpace(activity.context),
    },
  ];
}

function saveAttempt(attempt) {
  const attempts = readStorage(STORAGE_KEYS.attempts, []);
  const nextAttempts = [attempt, ...attempts].slice(0, 500);
  writeStorage(STORAGE_KEYS.attempts, nextAttempts);
  pushPublicAttemptToBackend(attempt);
}

function readStorage(key, fallback) {
  try {
    const raw = localStorage.getItem(key);
    if (!raw) {
      return fallback;
    }

    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : fallback;
  } catch (_err) {
    return fallback;
  }
}

function readObjectStorage(key, fallback) {
  try {
    const raw = localStorage.getItem(key);
    if (!raw) {
      return fallback;
    }
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
      return fallback;
    }
    return parsed;
  } catch (_err) {
    return fallback;
  }
}

function writeStorage(key, value) {
  try {
    localStorage.setItem(key, JSON.stringify(value));
    queueRemoteStateSync(key, value);
    return true;
  } catch (_err) {
    return false;
  }
}

function normalizeQuestionSources(sources, question) {
  if (!Array.isArray(sources)) {
    return [];
  }

  return sources
    .map((source) => {
      const url = normalizeSpace(source?.url);
      if (!url) {
        return null;
      }

      return {
        ...source,
        label: normalizeSpace(source?.label) || "מקור",
        url,
        anchorText:
          normalizeSpace(source?.anchorText)
          || normalizeSpace(source?.quote)
          || deriveSourceAnchorText(question, source),
      };
    })
    .filter(Boolean);
}

function deriveSourceAnchorText(question, source) {
  const explicit = normalizeSpace(source?.anchorText) || normalizeSpace(source?.quote);
  if (explicit) {
    return trimForTextFragment(explicit);
  }

  const candidates = [
    normalizeSpace(question?.explanation),
    normalizeSpace(question?.learn),
    normalizeSpace(question?.question),
  ];

  for (let i = 0; i < candidates.length; i += 1) {
    const candidate = trimForTextFragment(candidates[i]);
    if (candidate) {
      return candidate;
    }
  }

  return "";
}

function trimForTextFragment(text) {
  const clean = normalizeSpace(text);
  if (!clean) {
    return "";
  }

  if (clean.length <= SOURCE_TEXT_FRAGMENT_MAX_LEN) {
    return clean;
  }

  const hardSlice = clean.slice(0, SOURCE_TEXT_FRAGMENT_MAX_LEN + 24);
  const punctuationCut = Math.max(
    hardSlice.lastIndexOf("."),
    hardSlice.lastIndexOf(","),
    hardSlice.lastIndexOf(";"),
    hardSlice.lastIndexOf(" "),
  );
  const cutIndex = punctuationCut >= 36 ? punctuationCut : SOURCE_TEXT_FRAGMENT_MAX_LEN;
  return hardSlice.slice(0, cutIndex).trim();
}

function buildSourceHref(source, question) {
  const rawUrl = normalizeSpace(source?.url);
  if (!rawUrl) {
    return "";
  }

  let parsed;
  try {
    parsed = new URL(rawUrl);
  } catch (_err) {
    return rawUrl;
  }

  if (parsed.protocol !== "http:" && parsed.protocol !== "https:") {
    return rawUrl;
  }

  const fragmentText =
    trimForTextFragment(normalizeSpace(source?.anchorText))
    || deriveSourceAnchorText(question, source);
  if (!fragmentText) {
    return parsed.toString();
  }

  parsed.hash = `:~:text=${encodeURIComponent(fragmentText)}`;
  return parsed.toString();
}

function stripDateFromLabel(labelText) {
  return normalizeSpace(labelText).replace(/\(\s*\d{1,2}[./-]\d{1,2}[./-]\d{2,4}\s*\)/g, "").trim();
}

function buildMqgSearchUrl(query) {
  const safe = normalizeSpace(query);
  if (!safe) {
    return "https://mqg.org.il/";
  }
  return `https://mqg.org.il/?s=${encodeURIComponent(safe)}`;
}

function getBaseQuestionId(question) {
  const rawId = normalizeSpace(question?.id).toLowerCase();
  const match = rawId.match(/b\d{2}/);
  return match ? match[0] : "";
}

function getSourceRegistryEntry(source, question) {
  const baseQuestionId = getBaseQuestionId(question);
  if (baseQuestionId && SOURCE_REGISTRY_BY_QUESTION_ID[baseQuestionId]) {
    return SOURCE_REGISTRY_BY_QUESTION_ID[baseQuestionId];
  }

  return null;
}

function buildSourceSearchQuery(source, question) {
  const entry = getSourceRegistryEntry(source, question);
  if (normalizeSpace(entry?.searchQuery)) {
    return normalizeSpace(entry.searchQuery);
  }

  const label = stripDateFromLabel(source?.label);
  const anchor =
    trimForTextFragment(normalizeSpace(source?.anchorText))
    || deriveSourceAnchorText(question, source);
  return normalizeSpace(`${label} ${anchor}`);
}

function buildInternalSourceSearchHref(source, question) {
  const query = buildSourceSearchQuery(source, question);
  if (!query) {
    return "https://mqg.org.il/";
  }
  return `https://mqg.org.il/?s=${encodeURIComponent(query)}`;
}

function isLikelyBrokenMqgSourceUrl(rawUrl) {
  const normalized = normalizeSpace(rawUrl);
  if (!normalized) {
    return true;
  }

  let parsed;
  try {
    parsed = new URL(normalized);
  } catch (_err) {
    return true;
  }

  if (!/(\.|^)mqg\.org\.il$/i.test(parsed.hostname)) {
    return false;
  }

  const path = parsed.pathname || "/";
  if (path === "/" || path === "") {
    return true;
  }

  const lastSegment = path.split("/").filter(Boolean).pop() || "";
  if (!lastSegment) {
    return true;
  }

  if (/%d7%[0-9a-f]{2}$/i.test(lastSegment) && /-$/.test(lastSegment.replace(/%d7%[0-9a-f]{2}$/i, ""))) {
    return true;
  }

  const decoded = (() => {
    try {
      return decodeURIComponent(lastSegment);
    } catch (_err) {
      return lastSegment;
    }
  })();

  return decoded.length < 4;
}

function buildDirectSourceHref(source, question) {
  const entry = getSourceRegistryEntry(source, question);
  if (normalizeSpace(entry?.canonicalUrl)) {
    const sourceWithCanonical = {
      ...source,
      url: entry.canonicalUrl,
      anchorText: normalizeSpace(entry.anchorText) || normalizeSpace(source?.anchorText),
    };
    return buildSourceHref(sourceWithCanonical, question);
  }

  return buildSourceHref(source, question);
}

function buildPreferredSourceHref(source, question) {
  const entry = getSourceRegistryEntry(source, question);
  const directHref = buildDirectSourceHref(source, question);
  const searchHref = buildInternalSourceSearchHref(source, question);

  if (normalizeSpace(entry?.canonicalUrl)) {
    return directHref;
  }

  if (isLikelyBrokenMqgSourceUrl(source?.url)) {
    return searchHref;
  }

  if (!directHref) {
    return searchHref;
  }

  // Without canonical URL, search results are usually more stable than raw slug links.
  return searchHref;
}

function renderSources(container, sources, question) {
  container.innerHTML = "";

  if (!Array.isArray(sources) || !sources.length) {
    const li = document.createElement("li");
    li.textContent = "לא נוסף מקור חיצוני לשאלה זו.";
    container.appendChild(li);
    return;
  }

  sources.forEach((source) => {
    const li = document.createElement("li");
    const link = document.createElement("a");
    const preferredHref = buildPreferredSourceHref(source, question);
    const directHref = buildDirectSourceHref(source, question);
    const brokenSource = isLikelyBrokenMqgSourceUrl(source?.url);

    link.href = preferredHref;
    link.target = "_blank";
    link.rel = "noopener noreferrer";
    link.textContent = `מקור: ${source.label}`;
    li.appendChild(link);

    const searchLink = document.createElement("a");
    searchLink.href = buildInternalSourceSearchHref(source, question);
    searchLink.target = "_blank";
    searchLink.rel = "noopener noreferrer";
    searchLink.textContent = "איתור באתר";
    li.appendChild(document.createTextNode(" · "));
    li.appendChild(searchLink);

    if (
      directHref
      && directHref !== preferredHref
      && !isLikelyBrokenMqgSourceUrl(directHref)
    ) {
      const directLink = document.createElement("a");
      directLink.href = directHref;
      directLink.target = "_blank";
      directLink.rel = "noopener noreferrer";
      directLink.textContent = "קישור ישיר";
      li.appendChild(document.createTextNode(" · "));
      li.appendChild(directLink);
    }

    if (brokenSource) {
      const warnText = document.createElement("span");
      warnText.className = "muted tight";
      warnText.textContent = " · זוהה מקור פגום";
      li.appendChild(warnText);

      const altLink = document.createElement("a");
      altLink.href = buildInternalSourceSearchHref(source, question);
      altLink.target = "_blank";
      altLink.rel = "noopener noreferrer";
      altLink.textContent = "מקור חלופי מומלץ";
      li.appendChild(document.createTextNode(" · "));
      li.appendChild(altLink);
    }

    container.appendChild(li);
  });
}

function makeInfoMessage(text) {
  const node = document.createElement("article");
  node.className = "info-card";

  const p = document.createElement("p");
  p.textContent = text;

  node.appendChild(p);
  return node;
}

function showMessage(node, text, isOk) {
  node.textContent = text;
  node.classList.remove("hidden");
  node.classList.toggle("ok", Boolean(isOk));
}

function hideMessage(node) {
  node.textContent = "";
  node.classList.add("hidden");
  node.classList.remove("ok");
}

function formatDateDisplay(dateValue) {
  if (!dateValue) {
    return "ללא תאריך";
  }

  const [year, month, day] = String(dateValue).split("-");
  if (!year || !month || !day) {
    return dateValue;
  }

  return `${day}.${month}.${year}`;
}

function monthYearLabel(dateValue) {
  const [year, month] = String(dateValue || "").split("-");
  const monthIndex = Number(month) - 1;
  const monthName = HE_MONTHS[monthIndex] || month;
  if (!monthName || !year) {
    return String(dateValue || "");
  }
  return `${monthName} ${year}`;
}

function formatDateTime(isoText) {
  try {
    return new Date(isoText).toLocaleString("he-IL", {
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
    });
  } catch (_err) {
    return isoText;
  }
}

function formatDuration(seconds) {
  const safe = Math.max(0, Number(seconds) || 0);
  const min = Math.floor(safe / 60);
  const sec = safe % 60;
  return `${min}:${String(sec).padStart(2, "0")}`;
}

function formatBytes(value) {
  const size = Number(value) || 0;
  if (size < 1024) {
    return `${size}B`;
  }

  if (size < 1024 * 1024) {
    return `${Math.round(size / 1024)}KB`;
  }

  return `${(size / (1024 * 1024)).toFixed(1)}MB`;
}

function pickRandom(arr, count) {
  const clone = arr.slice();
  for (let i = clone.length - 1; i > 0; i -= 1) {
    const j = Math.floor(Math.random() * (i + 1));
    [clone[i], clone[j]] = [clone[j], clone[i]];
  }
  return clone.slice(0, count);
}

function shuffleArray(arr) {
  return pickRandom(arr, arr.length);
}

function uid(prefix) {
  return `${prefix}_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
}

function clampText(text, maxLength) {
  const clean = String(text || "").replace(/\s+/g, " ").trim();
  if (clean.length <= maxLength) {
    return clean;
  }

  return `${clean.slice(0, maxLength - 1)}…`;
}

function clampNumber(value, min, max) {
  return Math.min(max, Math.max(min, Number(value) || 0));
}

function setDefaultDateFields() {
  const today = new Date();
  const yyyy = today.getFullYear();
  const mm = String(today.getMonth() + 1).padStart(2, "0");
  const dd = String(today.getDate()).padStart(2, "0");
  const value = `${yyyy}-${mm}-${dd}`;

  const activityDateInput = dom.activityForm?.querySelector('input[name="date"]');
  if (activityDateInput) {
    activityDateInput.value = value;
  }

  if (dom.longTextDate) {
    dom.longTextDate.value = value;
  }
}

function isValidUrl(value) {
  try {
    const url = new URL(value);
    return url.protocol === "http:" || url.protocol === "https:";
  } catch (_err) {
    return false;
  }
}

async function extractFileMeta(fileList) {
  const files = Array.from(fileList || []).slice(0, 6);
  const output = [];

  for (const file of files) {
    const meta = {
      name: file.name,
      type: file.type || "application/octet-stream",
      size: file.size,
      previewDataUrl: "",
    };

    const canEmbedPreview = meta.type.startsWith("image/") && file.size <= 380000;
    if (canEmbedPreview) {
      try {
        meta.previewDataUrl = await fileToDataUrl(file);
      } catch (_err) {
        meta.previewDataUrl = "";
      }
    }

    output.push(meta);
  }

  return output;
}

function fileToDataUrl(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(String(reader.result || ""));
    reader.onerror = () => reject(reader.error);
    reader.readAsDataURL(file);
  });
}

function buildBannerImage(question) {
  const identity = `${question.id || ""}-${question.category || ""}`;
  const index = Math.abs(hashText(identity)) % OFFICIAL_BANNER_IMAGES.length;
  return OFFICIAL_BANNER_IMAGES[index];
}

function buildFallbackBannerImage(question) {
  const color = CATEGORY_COLORS[question.category] || {
    start: "#0B427A",
    end: "#072D57",
    code: "MQG",
  };
  const safeCategory = String(question.category || "התנועה לאיכות השלטון")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
  const svg = `
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 375">
      <defs>
        <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
          <stop offset="0%" stop-color="${color.start}" />
          <stop offset="100%" stop-color="${color.end}" />
        </linearGradient>
      </defs>
      <rect width="1200" height="375" fill="url(#g)" />
      <text x="60" y="190" fill="#fff" font-family="Heebo, Arial" font-size="54" font-weight="800">${safeCategory}</text>
    </svg>
  `;
  return `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(svg)}`;
}

function hashText(text) {
  let hash = 0;
  const safe = String(text || "");
  for (let i = 0; i < safe.length; i += 1) {
    hash = (hash << 5) - hash + safe.charCodeAt(i);
    hash |= 0;
  }
  return hash;
}
